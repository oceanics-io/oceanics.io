<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>bathysphere.models API documentation</title>
<meta name="description" content="Base persistence models that can be inherited by services. Classes are listed alphabetically." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bathysphere.models</code></h1>
</header>
<section id="section-intro">
<p>Base persistence models that can be inherited by services. Classes are listed alphabetically.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Base persistence models that can be inherited by services. Classes are listed alphabetically.
&#34;&#34;&#34;
from datetime import datetime
from time import time, sleep
from typing import Any, Callable
from statistics import median
from multiprocessing import Process, Pool, cpu_count
from socket import AF_INET, SOCK_STREAM, socket, create_connection
from time import time, sleep

from connexion import request
import attr

from time import time
from subprocess import Popen, PIPE, STDOUT
from itertools import repeat
from io import BytesIO

from numpy import (
    abs,
    zeros,
    arange,
    ones,
    convolve,
    isnan,
    ceil,
    array,
    repeat,
    floor,
)
from scipy.fftpack import rfft, irfft, fftfreq
from pandas import DataFrame, Series


from bathysphere.utils import interp1d, response, log
from bathysphere.datatypes import (    
    JSONIOWrapper,
)


@attr.s(repr=False)
class Actuators(object):
    &#34;&#34;&#34;
    Actuators are devices that turn messages into physical effects
    &#34;&#34;&#34;

    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    encodingType: str = attr.ib(default=None)  # metadata encoding
    metadata: Any = attr.ib(default=None)

    networkAddress: (str, int) = attr.ib(default=(None, None))

    def startController(
        self,
        host: str,
        port: int,
        relay_id: int,
        banks: int,
        relays: int,
        refresh: int,
        file: str = None,
        verb: bool = False,
    ) -&gt; bool:
        &#34;&#34;&#34;
        Communicate with a single relay

        :param host: hostname
        :param port: port number
        :param relay_id: relay id on board, doesn&#39;t get registered with graph
        :param banks: number of replica banks
        :param relays: total number of relays
        :param refresh: fixed refresh rate, in seconds
        :param file: log file
        :param verb: log to console
        &#34;&#34;&#34;
        timer_id = relay_id + self.metadata[&#34;config&#34;][&#34;timer_id_offset&#34;]
        # state = [[False] * banks] * (relays // banks)
        start = time()

        while True:
            response = self.on(relay_id, timer_id, duration=None)
            if not response:
                print(&#34;breaking loop.&#34;)
            sleep(refresh - ((time() - start) % refresh))

        return True

    @property
    def protocol(self):
        return dict()

    @property
    def defaults(self):
        return {
            &#34;datetime format&#34;: &#34;%Y-%m-%d %H:%M:%S&#34;,
            &#34;host&#34;: &#34;localhost&#34;,
            &#34;sample_period&#34;: 5,
            &#34;log&#34;: &#34;logs/controller_server.log&#34;,
            &#34;gain&#34;: {&#34;p&#34;: None, &#34;i&#34;: None, &#34;d&#34;: None},
            &#34;constant&#34;: {
                &#34;p&#34;: None,
                &#34;i&#34;: None,
                &#34;d&#34;: None,
            },  # persistent integral result term
            &#34;error&#34;: None,  # persistent error last step
            &#34;dt&#34;: None,  # sample period
            &#34;set&#34;: None,
            &#34;run&#34;: False,
            &#34;transform&#34;: lambda val: val,
            &#34;tail&#34;: None,  # trailing time before repeat
            &#34;ramp&#34;: False,  # interpolation if true
            &#34;repeat&#34;: False,  # repeat after tail if true
            &#34;acclimate&#34;: False,
            &#34;fade&#34;: False,
            &#34;current&#34;: None,  # last point passed
            &#34;start&#34;: None,  # first set point
        }

    @staticmethod
    def pulseWidth(
        signal: float, maximum: float = None, width: int = 2, pid: bool = True
    ) -&gt; int:
        return width * floor(5 * abs(signal) / maximum) if pid else width

    @staticmethod
    def signalTransform(
        config: dict, state: dict, raw: float, offset: float = 0.0
    ) -&gt; float:
        &#34;&#34;&#34;
        Returns conditioned PID signal

        :param config:
        :param state:
        :param raw: raw sensor reading
        :param offset: manual offset for integral term
        :return:
        &#34;&#34;&#34;

        def _transform():
            return (
                config[&#34;transform&#34;](state[&#34;set&#34;])
                - config[&#34;transform&#34;](offset)
                - config[&#34;transform&#34;](raw)
            )

        error, state[&#34;error&#34;] = state[&#34;error&#34;], _transform()
        e = state[&#34;error&#34;]
        c = state[&#34;constant&#34;]
        k = state[&#34;gain&#34;]

        c[&#34;p&#34;] = k[&#34;p&#34;] * e  # proportional term
        c[&#34;i&#34;] += e * config[&#34;dt&#34;]  # integral term
        c[&#34;d&#34;] = (e - error) / config[&#34;dt&#34;]  # derivative term

        return c[&#34;p&#34;] + (k[&#34;i&#34;] * c[&#34;i&#34;]) + (k[&#34;d&#34;] * c[&#34;d&#34;])

    @staticmethod
    def rewindControlLoop(state: dict, reset: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Return to playback start position
        :param state
        :param reset: reset to first observation if True
        &#34;&#34;&#34;
        if reset:
            state[&#34;start&#34;] = 0
        state[&#34;current&#34;] = state[&#34;start&#34;]

    @staticmethod
    def startControlLoop(
        relay_id: int,
        host: str,
        port: int,
        send: bool = False,
        refresh: int = 10,
        banks: int = 1,
        relays: int = 1,
        buffer: int = 16,
        file: str = None,
        echo: bool = False,
        verb: bool = False,
    ):
        &#34;&#34;&#34;
        Start the process in the background, and return reference

        :param relay_id: which relay this process controls
        :param host: host of server or client
        :param port: port number to open
        :param send: operate in bathysphere_functions_controller mode
        :param refresh: how often the signals are updated
        :param banks: number of replica relay banks
        :param relays: total number of relays
        :param buffer: length of serial buffer frames
        :param file: logging files
        :param verb: log to console
        :param echo: operate in diagnostic/echo mode

        :return: Process
        &#34;&#34;&#34;
        p = Process(
            target=Actuators.addEventListener,
            kwargs={
                **{
                    &#34;host&#34;: host,
                    &#34;port&#34;: port,
                    &#34;banks&#34;: banks,
                    &#34;file&#34;: file,
                    &#34;verb&#34;: verb,
                },
                **(
                    {&#34;echo&#34;: echo, &#34;buffer&#34;: buffer}
                    if not send
                    else {&#34;relay_id&#34;: relay_id, &#34;relays&#34;: relays, &#34;refresh&#34;: refresh}
                ),
            },
        )
        p.start()
        return p

    @staticmethod
    def addEventListener(
        self,
        banks: int = 1,
        echo: bool = False,
        buffer: int = 16,
        file: str = None,
        verb: bool = False,
    ):
        &#34;&#34;&#34;
        Main loop. Create a listening connection.

        :param host: hostname
        :param port: port number
        :param banks: number of replica banks
        :param echo: bounce back message
        :param buffer: byte chunk size
        :param file: log file
        :param verb: log to console
        &#34;&#34;&#34;

        bank_id = 0
        relay_id = 0
        host, port = self.networkAddress

        tcp = socket(AF_INET, SOCK_STREAM)
        logging = {&#34;file&#34;: file, &#34;console&#34;: verb}
        log(message=&#34;Listening on {} port {}&#34;.format(host, port), **logging)
        tcp.bind((host, port))
        tcp.listen(1)

        while True:
            connection, client = tcp.accept()
            log(message=&#34;Connection from {} on port {}&#34;.format(*client), **logging)
            try:
                while True:
                    data = connection.recv(buffer)
                    log(message=&#34;Received {!r}&#34;.format(data), **logging)
                    if not data:
                        log(
                            message=&#34;No data from {} on port {}&#34;.format(*client),
                            **logging,
                        )
                        break

                    if echo:
                        log(message=&#34;Echoing client&#34;, **logging)
                        connection.sendall(data)
                        continue

                    protocol = self.protocol
                    assert data[0] == protocol[&#34;config&#34;][&#34;start&#34;]
                    if data[1] == protocol[&#34;diagnostic&#34;][&#34;current_bank&#34;]:
                        code = bank_id
                    elif data[1] == protocol[&#34;diagnostic&#34;][&#34;banks&#34;]:
                        code = banks
                    elif data[1] == protocol[&#34;diagnostic&#34;][&#34;board&#34;]:
                        code = relay_id
                    elif data[1] == protocol[&#34;diagnostic&#34;][&#34;test&#34;]:
                        code = protocol[&#34;diagnostic&#34;][&#34;success&#34;]
                    elif data[1] == protocol[&#34;diagnostic&#34;][&#34;status&#34;]:
                        code = protocol[&#34;diagnostic&#34;][&#34;success&#34;]
                    else:
                        code = protocol[&#34;diagnostic&#34;][&#34;error&#34;]

                    log(message=&#34;Responding to the client&#34;, **logging)
                    connection.sendall(bytes([code]))

            finally:
                connection.close()

    @staticmethod
    async def sendMessage(
        self,
        commands: list = None,
        identity: int = None,
        buffer: int = 16,
        debug: bool = False,
    ) -&gt; bool or bytes:
        &#34;&#34;&#34;
        Send a DIAGNOSTIC query

        :param host:
        :param port:
        :param commands:
        :param identity:
        :param buffer:
        :param debug: return response instead of boolean

        :return:
        &#34;&#34;&#34;
        host, port = self.networkAddress
        protocol = self.protocol
        start = protocol[&#34;config&#34;][&#34;start&#34;]
        message = [start] + commands + ([identity] if identity is not None else [])

        with create_connection((host, port)) as tcp:
            try:
                tcp.send(bytes(message))  # send message
                response = tcp.recv(buffer)
            except:
                response = None
            finally:
                tcp.close()

        if debug:
            return response

        if response is not None and response[0] == protocol[&#34;diagnostic&#34;][&#34;success&#34;]:
            return True

        return False

    async def on(self, relay_id, timer_id, duration=None):
        &#34;&#34;&#34;
        Relay on, with optional duration

        :param duration:
        :return:
        &#34;&#34;&#34;
        commands = (
            [self.protocol[&#34;tasks&#34;][&#34;on&#34;]]
            if duration is None
            else [self.protocol[&#34;tasks&#34;][&#34;timer_setup&#34;], timer_id, 0, 0, duration]
        )
        return self.sendMessage(commands, identity=relay_id)

    async def off(self, relay_id=None):
        &#34;&#34;&#34;
        Turn specified relay off
        &#34;&#34;&#34;
        return self.sendMessage([self.protocol[&#34;tasks&#34;][&#34;off&#34;]], identity=relay_id)

    async def recover(self):
        &#34;&#34;&#34;
        Attempt emergency recovery
        &#34;&#34;&#34;
        return self.sendMessage(
            [self.protocol[&#34;diagnostic&#34;][&#34;board&#34;], self.protocol[&#34;tasks&#34;][&#34;recover&#34;]]
        )

    @property
    async def state(self, relay_id=None):
        &#34;&#34;&#34;
        Get current state of specified relay
        &#34;&#34;&#34;
        return self.sendMessage(
            [self.protocol[&#34;diagnostic&#34;][&#34;status&#34;]], identity=relay_id, debug=True
        )


@attr.s(repr=False)
class Assets:
    &#34;&#34;&#34;
    Assets are references to externaldata objects, which may or may not
    be accessible at the time of query.

    These are most likely ndarray/raster or json blobs in object storage

    name: name of resource
    description: annotation
    location: address of resource, including protocol (e.g. postgres://)
    &#34;&#34;&#34;
    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    location: str = attr.ib(default=None)


@attr.s(repr=False)
class Collections:
    &#34;&#34;&#34;
    Collections are arbitrary groupings of entities.
    &#34;&#34;&#34;
    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    extent: (float,) = attr.ib(default=None)
    keywords: str = attr.ib(default=None)
    license: str = attr.ib(default=None)
    version: int = attr.ib(default=None)


@attr.s(repr=False)
class DataStreams:
    &#34;&#34;&#34;
    DataStreams are collections of Observations.
    &#34;&#34;&#34;

    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    unitOfMeasurement = attr.ib(default=None)
    observationType = attr.ib(default=None)
    observedArea: dict = attr.ib(default=None)  # boundary geometry, GeoJSON polygon
    phenomenonTime: (datetime, datetime) = attr.ib(
        default=None
    )  # time interval, ISO8601
    resultTime: (datetime, datetime) = attr.ib(
        default=None
    )  # result times interval, ISO8601

    @staticmethod
    def fourierTransform(dt=1, lowpass=None, highpass=None, fill=False, compress=True):
        &#34;&#34;&#34;
        Perform frequency-domain filtering on regularly spaced time series
        
        Kwargs:
        
            tt, float[] :: time series
            yy, float[] :: reference series
            dt, float :: regular timestep
            lowpass, float :: lower cutoff
            highpass, float :: upper cutoff
        &#34;&#34;&#34;
        series = tuple(item.value for item in request.json)
        spectrum: dict = DataStreams.frequencySpectrum(
            series, dt=dt, fill=fill, compress=compress
        )
        payload: dict = spectrum.get(&#34;payload&#34;)

        freq = payload[&#34;frequency&#34;]
        ww = payload[&#34;index&#34;]

        if highpass is not None:
            mask = ww &lt; highpass
            freq[mask] = 0.0  # zero out low frequency

        if lowpass is not None:
            mask = ww &gt; lowpass
            freq[mask] = 0.0  # zero out high-frequency

        filtered = irfft(freq)

        return response(200, payload=filtered)

    @staticmethod
    def frequencySpectrum(req, dt=1, fill=False, compress=True):

        series = array(tuple(item.value for item in req.json))

        if fill:
            series = series.ffill()  # forward-fill missing values

        index = fftfreq(len(series), d=dt)  # frequency indices
        freq = rfft(series)  # transform to frequency domain
        if compress:
            mask = index &lt; 0.0
            freq[mask] = 0.0  # get rid of negative symmetry

        return response(status=200, payload={&#34;frequency&#34;: freq, &#34;index&#34;: index})

    @staticmethod
    def smoothUsingConvolution(bandwidth, mode=&#34;same&#34;):
        &#34;&#34;&#34;
        Convolve

        :return:
        &#34;&#34;&#34;
        series = tuple(item.value for item in request.json)
        filtered = convolve(series, ones((bandwidth,)) / bandwidth, mode=mode)
        return response(200, payload=filtered)

    @staticmethod
    def resampleSparseSeries(method=&#34;forward&#34;, observations=None, start=None):
        &#34;&#34;&#34;
        Generate filled regular time series of a variable from sparse observations
        using either backward/forward fill, or linear interpolation
        
        Kwargs:
            nobs, int :: number of observations
            start, datetime :: starting time index
            dates, datetime[] :: timestamps of observations
            series, float[] :: magnitude of observations
            method, str :: method if interpolation
            
        returns: array of filled values as single column
        &#34;&#34;&#34;
        dates = tuple(item.time for item in request.json)
        series = tuple(item.value for item in request.json)

        if not observations:
            observations = (dates[-1] - dates[0]).hours + 1

        if not start:
            start = dates[0]

        new = zeros(observations, dtype=float)
        total = 0  # new observations created
        previous = None
        dtdt = None

        for ii in range(len(series)):
            time = dates[ii]
            signal = series[ii]
            if not isnan(signal):
                dt = time - start
                hours = (
                    dt.days * 24 + dt.seconds / 60 / 60
                )  # hours elapsed since first sample
                if hours &gt; 0:  # reference time is after start time
                    end = min(ceil(hours), observations)  # absolute end index
                    span = end - total  # width of subset

                    if method is &#34;forward&#34;:
                        first = total
                        if ii == len(series) - 1:
                            span += observations - end

                        last = total + span  # not including self
                        new[first:last] = (
                            signal if previous is None else previous
                        )  # default to back-fill

                    elif method is &#34;back&#34;:
                        first = total  # including self
                        last = total + span - 1
                        new[first:last] = signal

                    elif method is &#34;interp&#34;:
                        if dtdt is None:
                            fill = signal  # default to forward fill
                        else:
                            delta = end - dtdt  # get step between input obs
                            coefs = (
                                arange(delta) / delta
                            )  # inter-step interpolation coefficient
                            fill = interp1d(coefs, previous, signal)

                        first = max([total - 1, 0])
                        new[first : total + span - 1] = fill

                    dtdt = dt
                    total += span

                previous = signal

        return response(200, payload=new)

    def statisticalOutlierMask(
        self, assumeEvenSpacing: bool = False, threshold: float = 3.5
    ):
        &#34;&#34;&#34;
        Return array of logical values, with true indicating that the value or its 
        first derivative are outliers
        &#34;&#34;&#34;

        dates = tuple(item.time for item in request.json)
        series = tuple(item.value for item in request.json)

        if assumeEvenSpacing:
            dydt = series
        else:
            dydt = [0.0]
            deltat = [0.0]

            for nn in range(1, len(series)):
                deltat.append(dates[nn] - dates[nn - 1])
                dydt.append((series[nn] - series[nn - 1]) / deltat[nn])

        diff = abs(
            series - median(series)
        )  # difference between series and median (anomaly)
        mad = median(diff)  # median of anomaly
        mod_z = 0.6745 * diff / mad
        mask = mod_z &gt; threshold

        return response(200, payload=mask)

    @staticmethod
    def outOfRangeMask(min, max):
        &#34;&#34;&#34;
        Use backend to generate a mask. 
        &#34;&#34;&#34;
        series = tuple(item.value for item in request.json)
        mask = map(lambda x: x.outOfRange(maximum=max, minimum=min), series)

        return response(200, payload=mask)

    def partition(
        self, window: int, horizon: int, batch_size: int, ratio: float, periods: int
    ):
        &#34;&#34;&#34;

        :param window: moving average observations
        :param horizon: look ahead
        :param periods: number of observations
        :param batch_size: length of training segment
        :param ratio: approximate ratio of observations to use for training
    
        :return:
        &#34;&#34;&#34;

        # reshaping functions
        def reshape3d(x):
            return x.values.reshape((x.shape[0], x.shape[1], 1))

        def reshape2d(y):
            return y.values.reshape((y.shape[0], 1))

        start = max(window - 1, horizon - 1)
        nn = int(periods * ratio)
        nn -= nn % batch_size

        # TODO: I think this is pandas.Series
        observations = ()
        series = Series(item.result for item in observations)
        expected = series.rolling(
            window=window, center=False
        ).mean()  # set the target to moving average

        if horizon &gt; 1:
            datastream = DataFrame(repeat(datastream.values, repeats=horizon, axis=1))
            for i, c in enumerate(datastream.columns):
                datastream[c] = datastream[c].shift(
                    i
                )  # shift each by one more, &#34;rolling window view&#34; of data

        end = datastream.shape[0] % batch_size  # match with batch_size

        return {
            &#34;training&#34;: {
                &#34;x&#34;: reshape3d(datastream[start : start + nn]),
                &#34;y&#34;: reshape2d(expected[start : start + nn]),
            },
            &#34;validation&#34;: {
                &#34;x&#34;: reshape3d(
                    datastream[start + nn : -1 * end]
                    if end
                    else datastream[start + nn :]
                ),
                &#34;y&#34;: reshape2d(
                    expected[start + nn : -1 * end] if end else expected[start + nn :]
                ),
            },
        }


@attr.s(repr=False)
class FeaturesOfInterest(object):
    &#34;&#34;&#34;
    FeaturesOfInterest are usually Locations.
    &#34;&#34;&#34;

    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    encodingType: str = attr.ib(default=None)  # metadata encoding
    feature: Any = attr.ib(default=None)


@attr.s(repr=False)
class HistoricalLocations(object):
    &#34;&#34;&#34;
    Private and automatic, should be added to sensor when new location is determined
    &#34;&#34;&#34;

    time: str = attr.ib(
        default=None
    )  # time when thing was at location (ISO-8601 string)


@attr.s(repr=False)
class Locations(object):
    &#34;&#34;&#34;
    Last known `Locations` of `Things`. May be `FeaturesOfInterest`, unless remote sensing.

    location encoding may be `application/vnd.geo+json` or `application/json`
    &#34;&#34;&#34;
    description: str = attr.ib(default=None)
    encodingType: str = attr.ib(default=None)
    location = attr.ib(default=None)  # GeoJSON
    name: str = attr.ib(default=None)


@attr.s(repr=False)
class Observations(object):
    &#34;&#34;&#34;
    Observations are individual time-stamped members of Datastreams
    &#34;&#34;&#34;

    phenomenonTime: datetime = attr.ib(
        default=None
    )  # timestamp, doesn&#39;t enforce specific format
    result: Any = attr.ib(default=None)  # value of the observation
    resultTime: datetime = attr.ib(default=None)
    resultQuality: Any = attr.ib(default=None)
    validTime: (datetime, datetime) = attr.ib(default=None)  # time period
    parameters: dict = attr.ib(default=None)

    @property
    def outOfRange(self, maximum, minimum=0.0):
        &#34;&#34;&#34;
        True if value is outside the given range
        &#34;&#34;&#34;
        return (self.result &gt; maximum) | (self.result &lt; minimum)


@attr.s(repr=False)
class ObservedProperties(object):
    &#34;&#34;&#34;
    Create a property, but do not associate any data streams with it
    &#34;&#34;&#34;

    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    definition: str = attr.ib(default=None)  #  URL to reference defining the property


@attr.s(repr=False)
class Providers(object):
    &#34;&#34;&#34;
    Providers are generally organization or enterprise sub-units. This is used to
    route ingress and determine implicit permissions for data access, sharing, and
    attribution. 
    &#34;&#34;&#34;

    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    domain: str = attr.ib(default=None)
    secretKey: str = attr.ib(default=None)
    apiKey: str = attr.ib(default=None)
    tokenDuration: int = attr.ib(default=None)


@attr.s(repr=False)
class Sensors(object):
    &#34;&#34;&#34;
    Sensors are devices that observe processes
    &#34;&#34;&#34;

    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    encodingType: str = attr.ib(default=None)  # metadata encoding
    metadata: Any = attr.ib(default=None)


@attr.s(repr=False)
class Simulations(object):
    
    @staticmethod
    def batch(config: dict, forcing: array, workers: int = 1) -&gt; dict:
        &#34;&#34;&#34;
        Run a batch, and generate some statistics about execution

        :param config: kwarg dictionary of single or iterable values
        :param forcing: pre-processed data for all simulations, an iterable of iterables
        :param workers: maximum number of workers to request, will be reduced if necessary

        :return: batch of responses with metadata as JSON-like dictionary
        &#34;&#34;&#34;

        def _repeat(value):
            try:
                assert len(value) &gt; 0
                assert type(value) != str
                return value
            except TypeError:
                return repeat(value, n)
            except AssertionError:
                return repeat(value, n)

        def _expand(json):
            new = {key: _repeat(value) for key, value in json.items()}
            return tuple(
                [dict(zip(new, item)) for item in zip(*new.values()) for _ in range(n)]
            )

        processes = min(cpu_count(), workers)
        tempfile = BytesIO()

        with Pool(processes) as pool:
            start = time()
            n = len(forcing)
            JSONIOWrapper.log(&#34;Scheduler ready&#34;, f&#34;spawning {n} workers&#34;, log=tempfile)
            result = pool.starmap(Simulations.job, zip(_expand(config), forcing))
            data, logs = zip(*result)
            finish = time()
            JSONIOWrapper.log(
                &#34;Scheduler done&#34;, f&#34;completed {n} jobs in {finish-start} s&#34;, log=tempfile
            )

        return {
            &#34;data&#34;: data,
            &#34;logs&#34;: logs + (tempfile.getvalue(),),
            &#34;workers&#34;: processes,
            &#34;config&#34;: config,
            &#34;count&#34;: n,
            &#34;start&#34;: start,
            &#34;finish&#34;: finish,
        }

    @staticmethod
    def job(
        config: dict, 
        forcing: array,
        encoding: str = &#34;utf-8&#34;
    ) -&gt; (tuple, bytes):
        &#34;&#34;&#34;
        Execute single simulation with synchronous callback.

        :param config: simulation configuration
        :param forcing: list of forcing vectors
        :param encoding: input/output encoding

        :return: output variables of C# methods, or None
        &#34;&#34;&#34;
        n = len(forcing)
        tempfile = BytesIO()
        process = None
    
        command = [config.get(&#34;executable&#34;), __path__[0] + &#34;/..&#34; + config.get(&#34;exePath&#34;)]
        process = Popen(command, stdin=PIPE, stdout=PIPE, stderr=STDOUT, bufsize=1)
       
        if process is None:
            JSONIOWrapper.log(message=&#34;Mono&#34;, data=&#34;not found&#34;, log=tempfile)
            return ({&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &#34;mono not found&#34;},)

        JSONIOWrapper.log(
            message=f&#34;Spawned process {process.pid}&#34;, data=process.args, log=tempfile
        )
        console = JSONIOWrapper(process.stdin, encoding=encoding, line_buffering=True)
        output = JSONIOWrapper(process.stdout, encoding=encoding, line_buffering=False)

        result = [output.receive(log=tempfile) for _ in range(2)]
        console.send(config, log=tempfile)

        JSONIOWrapper.log(
            message=&#34;Worker ready&#34;, data=f&#34;expecting {n} transactions&#34;, log=tempfile
        )

        for item in forcing:
            console.send(item, log=tempfile)  # send data as serialized dictionary
            state = output.receive(log=tempfile)
            if state[&#34;status&#34;] == &#34;error&#34;:
                JSONIOWrapper.log(message=&#34;Runtime&#34;, data=state[&#34;message&#34;], log=tempfile)
                result += [state]
                break
            result += [state]

        JSONIOWrapper.log(
            message=&#34;Worker done&#34;,
            data=f&#34;completed {len(result)} transactions&#34;,
            log=tempfile,
        )
        process.kill()
        process.wait()
        console.close()
        output.close()
        return tuple(result), tempfile.getvalue()




@attr.s(repr=False)
class TaskingCapabilities(object):
    &#34;&#34;&#34;
    Abstract tasking class mapping I/O and generating signal.
    &#34;&#34;&#34;
    name: str = attr.ib(default=None)
    description: str =  attr.ib(default=None)
    creationTime: float = attr.ib(default=None)
    taskingParameters: dict = attr.ib(default=None)


@attr.s(repr=False)
class Tasks(object):
    &#34;&#34;&#34;
    Tasks are pieces of work that are done asynchronously by humans or machines.
    &#34;&#34;&#34;
    creationTime: float = attr.ib(default=None)
    taskingParameters: dict = attr.ib(default=None)


@attr.s(repr=False)
class Things(object):
    &#34;&#34;&#34;
    A thing is an object of the physical or information world that is capable of of being identified
    and integrated into communication networks.
    &#34;&#34;&#34;

    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    properties: dict = attr.ib(default=None)


@attr.s(repr=False)
class User(object):
    &#34;&#34;&#34;
    Create a user entity. Users contain authorization secrets, and do not enter/leave
    the system through the same routes as normal Entities
    &#34;&#34;&#34;

    ip: str = attr.ib(default=None)
    name: str = attr.ib(default=None)
    alias: str = attr.ib(default=None)
    credential: str = attr.ib(default=None)
    validated: bool = attr.ib(default=True)
    description: str = attr.ib(default=None)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="bathysphere.models.Actuators"><code class="flex name class">
<span>class <span class="ident">Actuators</span></span>
<span>(</span><span>name: str = None, description: str = None, encodingType: str = None, metadata: Any = None, networkAddress: (<class 'str'>, <class 'int'>) = (None, None))</span>
</code></dt>
<dd>
<div class="desc"><p>Actuators are devices that turn messages into physical effects</p>
<p>Method generated by attrs for class Actuators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Actuators(object):
    &#34;&#34;&#34;
    Actuators are devices that turn messages into physical effects
    &#34;&#34;&#34;

    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    encodingType: str = attr.ib(default=None)  # metadata encoding
    metadata: Any = attr.ib(default=None)

    networkAddress: (str, int) = attr.ib(default=(None, None))

    def startController(
        self,
        host: str,
        port: int,
        relay_id: int,
        banks: int,
        relays: int,
        refresh: int,
        file: str = None,
        verb: bool = False,
    ) -&gt; bool:
        &#34;&#34;&#34;
        Communicate with a single relay

        :param host: hostname
        :param port: port number
        :param relay_id: relay id on board, doesn&#39;t get registered with graph
        :param banks: number of replica banks
        :param relays: total number of relays
        :param refresh: fixed refresh rate, in seconds
        :param file: log file
        :param verb: log to console
        &#34;&#34;&#34;
        timer_id = relay_id + self.metadata[&#34;config&#34;][&#34;timer_id_offset&#34;]
        # state = [[False] * banks] * (relays // banks)
        start = time()

        while True:
            response = self.on(relay_id, timer_id, duration=None)
            if not response:
                print(&#34;breaking loop.&#34;)
            sleep(refresh - ((time() - start) % refresh))

        return True

    @property
    def protocol(self):
        return dict()

    @property
    def defaults(self):
        return {
            &#34;datetime format&#34;: &#34;%Y-%m-%d %H:%M:%S&#34;,
            &#34;host&#34;: &#34;localhost&#34;,
            &#34;sample_period&#34;: 5,
            &#34;log&#34;: &#34;logs/controller_server.log&#34;,
            &#34;gain&#34;: {&#34;p&#34;: None, &#34;i&#34;: None, &#34;d&#34;: None},
            &#34;constant&#34;: {
                &#34;p&#34;: None,
                &#34;i&#34;: None,
                &#34;d&#34;: None,
            },  # persistent integral result term
            &#34;error&#34;: None,  # persistent error last step
            &#34;dt&#34;: None,  # sample period
            &#34;set&#34;: None,
            &#34;run&#34;: False,
            &#34;transform&#34;: lambda val: val,
            &#34;tail&#34;: None,  # trailing time before repeat
            &#34;ramp&#34;: False,  # interpolation if true
            &#34;repeat&#34;: False,  # repeat after tail if true
            &#34;acclimate&#34;: False,
            &#34;fade&#34;: False,
            &#34;current&#34;: None,  # last point passed
            &#34;start&#34;: None,  # first set point
        }

    @staticmethod
    def pulseWidth(
        signal: float, maximum: float = None, width: int = 2, pid: bool = True
    ) -&gt; int:
        return width * floor(5 * abs(signal) / maximum) if pid else width

    @staticmethod
    def signalTransform(
        config: dict, state: dict, raw: float, offset: float = 0.0
    ) -&gt; float:
        &#34;&#34;&#34;
        Returns conditioned PID signal

        :param config:
        :param state:
        :param raw: raw sensor reading
        :param offset: manual offset for integral term
        :return:
        &#34;&#34;&#34;

        def _transform():
            return (
                config[&#34;transform&#34;](state[&#34;set&#34;])
                - config[&#34;transform&#34;](offset)
                - config[&#34;transform&#34;](raw)
            )

        error, state[&#34;error&#34;] = state[&#34;error&#34;], _transform()
        e = state[&#34;error&#34;]
        c = state[&#34;constant&#34;]
        k = state[&#34;gain&#34;]

        c[&#34;p&#34;] = k[&#34;p&#34;] * e  # proportional term
        c[&#34;i&#34;] += e * config[&#34;dt&#34;]  # integral term
        c[&#34;d&#34;] = (e - error) / config[&#34;dt&#34;]  # derivative term

        return c[&#34;p&#34;] + (k[&#34;i&#34;] * c[&#34;i&#34;]) + (k[&#34;d&#34;] * c[&#34;d&#34;])

    @staticmethod
    def rewindControlLoop(state: dict, reset: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Return to playback start position
        :param state
        :param reset: reset to first observation if True
        &#34;&#34;&#34;
        if reset:
            state[&#34;start&#34;] = 0
        state[&#34;current&#34;] = state[&#34;start&#34;]

    @staticmethod
    def startControlLoop(
        relay_id: int,
        host: str,
        port: int,
        send: bool = False,
        refresh: int = 10,
        banks: int = 1,
        relays: int = 1,
        buffer: int = 16,
        file: str = None,
        echo: bool = False,
        verb: bool = False,
    ):
        &#34;&#34;&#34;
        Start the process in the background, and return reference

        :param relay_id: which relay this process controls
        :param host: host of server or client
        :param port: port number to open
        :param send: operate in bathysphere_functions_controller mode
        :param refresh: how often the signals are updated
        :param banks: number of replica relay banks
        :param relays: total number of relays
        :param buffer: length of serial buffer frames
        :param file: logging files
        :param verb: log to console
        :param echo: operate in diagnostic/echo mode

        :return: Process
        &#34;&#34;&#34;
        p = Process(
            target=Actuators.addEventListener,
            kwargs={
                **{
                    &#34;host&#34;: host,
                    &#34;port&#34;: port,
                    &#34;banks&#34;: banks,
                    &#34;file&#34;: file,
                    &#34;verb&#34;: verb,
                },
                **(
                    {&#34;echo&#34;: echo, &#34;buffer&#34;: buffer}
                    if not send
                    else {&#34;relay_id&#34;: relay_id, &#34;relays&#34;: relays, &#34;refresh&#34;: refresh}
                ),
            },
        )
        p.start()
        return p

    @staticmethod
    def addEventListener(
        self,
        banks: int = 1,
        echo: bool = False,
        buffer: int = 16,
        file: str = None,
        verb: bool = False,
    ):
        &#34;&#34;&#34;
        Main loop. Create a listening connection.

        :param host: hostname
        :param port: port number
        :param banks: number of replica banks
        :param echo: bounce back message
        :param buffer: byte chunk size
        :param file: log file
        :param verb: log to console
        &#34;&#34;&#34;

        bank_id = 0
        relay_id = 0
        host, port = self.networkAddress

        tcp = socket(AF_INET, SOCK_STREAM)
        logging = {&#34;file&#34;: file, &#34;console&#34;: verb}
        log(message=&#34;Listening on {} port {}&#34;.format(host, port), **logging)
        tcp.bind((host, port))
        tcp.listen(1)

        while True:
            connection, client = tcp.accept()
            log(message=&#34;Connection from {} on port {}&#34;.format(*client), **logging)
            try:
                while True:
                    data = connection.recv(buffer)
                    log(message=&#34;Received {!r}&#34;.format(data), **logging)
                    if not data:
                        log(
                            message=&#34;No data from {} on port {}&#34;.format(*client),
                            **logging,
                        )
                        break

                    if echo:
                        log(message=&#34;Echoing client&#34;, **logging)
                        connection.sendall(data)
                        continue

                    protocol = self.protocol
                    assert data[0] == protocol[&#34;config&#34;][&#34;start&#34;]
                    if data[1] == protocol[&#34;diagnostic&#34;][&#34;current_bank&#34;]:
                        code = bank_id
                    elif data[1] == protocol[&#34;diagnostic&#34;][&#34;banks&#34;]:
                        code = banks
                    elif data[1] == protocol[&#34;diagnostic&#34;][&#34;board&#34;]:
                        code = relay_id
                    elif data[1] == protocol[&#34;diagnostic&#34;][&#34;test&#34;]:
                        code = protocol[&#34;diagnostic&#34;][&#34;success&#34;]
                    elif data[1] == protocol[&#34;diagnostic&#34;][&#34;status&#34;]:
                        code = protocol[&#34;diagnostic&#34;][&#34;success&#34;]
                    else:
                        code = protocol[&#34;diagnostic&#34;][&#34;error&#34;]

                    log(message=&#34;Responding to the client&#34;, **logging)
                    connection.sendall(bytes([code]))

            finally:
                connection.close()

    @staticmethod
    async def sendMessage(
        self,
        commands: list = None,
        identity: int = None,
        buffer: int = 16,
        debug: bool = False,
    ) -&gt; bool or bytes:
        &#34;&#34;&#34;
        Send a DIAGNOSTIC query

        :param host:
        :param port:
        :param commands:
        :param identity:
        :param buffer:
        :param debug: return response instead of boolean

        :return:
        &#34;&#34;&#34;
        host, port = self.networkAddress
        protocol = self.protocol
        start = protocol[&#34;config&#34;][&#34;start&#34;]
        message = [start] + commands + ([identity] if identity is not None else [])

        with create_connection((host, port)) as tcp:
            try:
                tcp.send(bytes(message))  # send message
                response = tcp.recv(buffer)
            except:
                response = None
            finally:
                tcp.close()

        if debug:
            return response

        if response is not None and response[0] == protocol[&#34;diagnostic&#34;][&#34;success&#34;]:
            return True

        return False

    async def on(self, relay_id, timer_id, duration=None):
        &#34;&#34;&#34;
        Relay on, with optional duration

        :param duration:
        :return:
        &#34;&#34;&#34;
        commands = (
            [self.protocol[&#34;tasks&#34;][&#34;on&#34;]]
            if duration is None
            else [self.protocol[&#34;tasks&#34;][&#34;timer_setup&#34;], timer_id, 0, 0, duration]
        )
        return self.sendMessage(commands, identity=relay_id)

    async def off(self, relay_id=None):
        &#34;&#34;&#34;
        Turn specified relay off
        &#34;&#34;&#34;
        return self.sendMessage([self.protocol[&#34;tasks&#34;][&#34;off&#34;]], identity=relay_id)

    async def recover(self):
        &#34;&#34;&#34;
        Attempt emergency recovery
        &#34;&#34;&#34;
        return self.sendMessage(
            [self.protocol[&#34;diagnostic&#34;][&#34;board&#34;], self.protocol[&#34;tasks&#34;][&#34;recover&#34;]]
        )

    @property
    async def state(self, relay_id=None):
        &#34;&#34;&#34;
        Get current state of specified relay
        &#34;&#34;&#34;
        return self.sendMessage(
            [self.protocol[&#34;diagnostic&#34;][&#34;status&#34;]], identity=relay_id, debug=True
        )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.graph.models.Actuators" href="graph/models.html#bathysphere.graph.models.Actuators">Actuators</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.models.Actuators.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Actuators.encodingType"><code class="name">var <span class="ident">encodingType</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Actuators.metadata"><code class="name">var <span class="ident">metadata</span> : Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Actuators.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Actuators.networkAddress"><code class="name">var <span class="ident">networkAddress</span> : (<class 'str'>, <class 'int'>)</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="bathysphere.models.Actuators.addEventListener"><code class="name flex">
<span>def <span class="ident">addEventListener</span></span>(<span>self, banks: int = 1, echo: bool = False, buffer: int = 16, file: str = None, verb: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Main loop. Create a listening connection.</p>
<p>:param host: hostname
:param port: port number
:param banks: number of replica banks
:param echo: bounce back message
:param buffer: byte chunk size
:param file: log file
:param verb: log to console</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def addEventListener(
    self,
    banks: int = 1,
    echo: bool = False,
    buffer: int = 16,
    file: str = None,
    verb: bool = False,
):
    &#34;&#34;&#34;
    Main loop. Create a listening connection.

    :param host: hostname
    :param port: port number
    :param banks: number of replica banks
    :param echo: bounce back message
    :param buffer: byte chunk size
    :param file: log file
    :param verb: log to console
    &#34;&#34;&#34;

    bank_id = 0
    relay_id = 0
    host, port = self.networkAddress

    tcp = socket(AF_INET, SOCK_STREAM)
    logging = {&#34;file&#34;: file, &#34;console&#34;: verb}
    log(message=&#34;Listening on {} port {}&#34;.format(host, port), **logging)
    tcp.bind((host, port))
    tcp.listen(1)

    while True:
        connection, client = tcp.accept()
        log(message=&#34;Connection from {} on port {}&#34;.format(*client), **logging)
        try:
            while True:
                data = connection.recv(buffer)
                log(message=&#34;Received {!r}&#34;.format(data), **logging)
                if not data:
                    log(
                        message=&#34;No data from {} on port {}&#34;.format(*client),
                        **logging,
                    )
                    break

                if echo:
                    log(message=&#34;Echoing client&#34;, **logging)
                    connection.sendall(data)
                    continue

                protocol = self.protocol
                assert data[0] == protocol[&#34;config&#34;][&#34;start&#34;]
                if data[1] == protocol[&#34;diagnostic&#34;][&#34;current_bank&#34;]:
                    code = bank_id
                elif data[1] == protocol[&#34;diagnostic&#34;][&#34;banks&#34;]:
                    code = banks
                elif data[1] == protocol[&#34;diagnostic&#34;][&#34;board&#34;]:
                    code = relay_id
                elif data[1] == protocol[&#34;diagnostic&#34;][&#34;test&#34;]:
                    code = protocol[&#34;diagnostic&#34;][&#34;success&#34;]
                elif data[1] == protocol[&#34;diagnostic&#34;][&#34;status&#34;]:
                    code = protocol[&#34;diagnostic&#34;][&#34;success&#34;]
                else:
                    code = protocol[&#34;diagnostic&#34;][&#34;error&#34;]

                log(message=&#34;Responding to the client&#34;, **logging)
                connection.sendall(bytes([code]))

        finally:
            connection.close()</code></pre>
</details>
</dd>
<dt id="bathysphere.models.Actuators.pulseWidth"><code class="name flex">
<span>def <span class="ident">pulseWidth</span></span>(<span>signal: float, maximum: float = None, width: int = 2, pid: bool = True) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def pulseWidth(
    signal: float, maximum: float = None, width: int = 2, pid: bool = True
) -&gt; int:
    return width * floor(5 * abs(signal) / maximum) if pid else width</code></pre>
</details>
</dd>
<dt id="bathysphere.models.Actuators.rewindControlLoop"><code class="name flex">
<span>def <span class="ident">rewindControlLoop</span></span>(<span>state: dict, reset: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Return to playback start position
:param state
:param reset: reset to first observation if True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def rewindControlLoop(state: dict, reset: bool = False) -&gt; None:
    &#34;&#34;&#34;
    Return to playback start position
    :param state
    :param reset: reset to first observation if True
    &#34;&#34;&#34;
    if reset:
        state[&#34;start&#34;] = 0
    state[&#34;current&#34;] = state[&#34;start&#34;]</code></pre>
</details>
</dd>
<dt id="bathysphere.models.Actuators.sendMessage"><code class="name flex">
<span>async def <span class="ident">sendMessage</span></span>(<span>self, commands: list = None, identity: int = None, buffer: int = 16, debug: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Send a DIAGNOSTIC query</p>
<p>:param host:
:param port:
:param commands:
:param identity:
:param buffer:
:param debug: return response instead of boolean</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def sendMessage(
    self,
    commands: list = None,
    identity: int = None,
    buffer: int = 16,
    debug: bool = False,
) -&gt; bool or bytes:
    &#34;&#34;&#34;
    Send a DIAGNOSTIC query

    :param host:
    :param port:
    :param commands:
    :param identity:
    :param buffer:
    :param debug: return response instead of boolean

    :return:
    &#34;&#34;&#34;
    host, port = self.networkAddress
    protocol = self.protocol
    start = protocol[&#34;config&#34;][&#34;start&#34;]
    message = [start] + commands + ([identity] if identity is not None else [])

    with create_connection((host, port)) as tcp:
        try:
            tcp.send(bytes(message))  # send message
            response = tcp.recv(buffer)
        except:
            response = None
        finally:
            tcp.close()

    if debug:
        return response

    if response is not None and response[0] == protocol[&#34;diagnostic&#34;][&#34;success&#34;]:
        return True

    return False</code></pre>
</details>
</dd>
<dt id="bathysphere.models.Actuators.signalTransform"><code class="name flex">
<span>def <span class="ident">signalTransform</span></span>(<span>config: dict, state: dict, raw: float, offset: float = 0.0) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns conditioned PID signal</p>
<p>:param config:
:param state:
:param raw: raw sensor reading
:param offset: manual offset for integral term
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def signalTransform(
    config: dict, state: dict, raw: float, offset: float = 0.0
) -&gt; float:
    &#34;&#34;&#34;
    Returns conditioned PID signal

    :param config:
    :param state:
    :param raw: raw sensor reading
    :param offset: manual offset for integral term
    :return:
    &#34;&#34;&#34;

    def _transform():
        return (
            config[&#34;transform&#34;](state[&#34;set&#34;])
            - config[&#34;transform&#34;](offset)
            - config[&#34;transform&#34;](raw)
        )

    error, state[&#34;error&#34;] = state[&#34;error&#34;], _transform()
    e = state[&#34;error&#34;]
    c = state[&#34;constant&#34;]
    k = state[&#34;gain&#34;]

    c[&#34;p&#34;] = k[&#34;p&#34;] * e  # proportional term
    c[&#34;i&#34;] += e * config[&#34;dt&#34;]  # integral term
    c[&#34;d&#34;] = (e - error) / config[&#34;dt&#34;]  # derivative term

    return c[&#34;p&#34;] + (k[&#34;i&#34;] * c[&#34;i&#34;]) + (k[&#34;d&#34;] * c[&#34;d&#34;])</code></pre>
</details>
</dd>
<dt id="bathysphere.models.Actuators.startControlLoop"><code class="name flex">
<span>def <span class="ident">startControlLoop</span></span>(<span>relay_id: int, host: str, port: int, send: bool = False, refresh: int = 10, banks: int = 1, relays: int = 1, buffer: int = 16, file: str = None, echo: bool = False, verb: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the process in the background, and return reference</p>
<p>:param relay_id: which relay this process controls
:param host: host of server or client
:param port: port number to open
:param send: operate in bathysphere_functions_controller mode
:param refresh: how often the signals are updated
:param banks: number of replica relay banks
:param relays: total number of relays
:param buffer: length of serial buffer frames
:param file: logging files
:param verb: log to console
:param echo: operate in diagnostic/echo mode</p>
<p>:return: Process</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def startControlLoop(
    relay_id: int,
    host: str,
    port: int,
    send: bool = False,
    refresh: int = 10,
    banks: int = 1,
    relays: int = 1,
    buffer: int = 16,
    file: str = None,
    echo: bool = False,
    verb: bool = False,
):
    &#34;&#34;&#34;
    Start the process in the background, and return reference

    :param relay_id: which relay this process controls
    :param host: host of server or client
    :param port: port number to open
    :param send: operate in bathysphere_functions_controller mode
    :param refresh: how often the signals are updated
    :param banks: number of replica relay banks
    :param relays: total number of relays
    :param buffer: length of serial buffer frames
    :param file: logging files
    :param verb: log to console
    :param echo: operate in diagnostic/echo mode

    :return: Process
    &#34;&#34;&#34;
    p = Process(
        target=Actuators.addEventListener,
        kwargs={
            **{
                &#34;host&#34;: host,
                &#34;port&#34;: port,
                &#34;banks&#34;: banks,
                &#34;file&#34;: file,
                &#34;verb&#34;: verb,
            },
            **(
                {&#34;echo&#34;: echo, &#34;buffer&#34;: buffer}
                if not send
                else {&#34;relay_id&#34;: relay_id, &#34;relays&#34;: relays, &#34;refresh&#34;: refresh}
            ),
        },
    )
    p.start()
    return p</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="bathysphere.models.Actuators.defaults"><code class="name">var <span class="ident">defaults</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def defaults(self):
    return {
        &#34;datetime format&#34;: &#34;%Y-%m-%d %H:%M:%S&#34;,
        &#34;host&#34;: &#34;localhost&#34;,
        &#34;sample_period&#34;: 5,
        &#34;log&#34;: &#34;logs/controller_server.log&#34;,
        &#34;gain&#34;: {&#34;p&#34;: None, &#34;i&#34;: None, &#34;d&#34;: None},
        &#34;constant&#34;: {
            &#34;p&#34;: None,
            &#34;i&#34;: None,
            &#34;d&#34;: None,
        },  # persistent integral result term
        &#34;error&#34;: None,  # persistent error last step
        &#34;dt&#34;: None,  # sample period
        &#34;set&#34;: None,
        &#34;run&#34;: False,
        &#34;transform&#34;: lambda val: val,
        &#34;tail&#34;: None,  # trailing time before repeat
        &#34;ramp&#34;: False,  # interpolation if true
        &#34;repeat&#34;: False,  # repeat after tail if true
        &#34;acclimate&#34;: False,
        &#34;fade&#34;: False,
        &#34;current&#34;: None,  # last point passed
        &#34;start&#34;: None,  # first set point
    }</code></pre>
</details>
</dd>
<dt id="bathysphere.models.Actuators.protocol"><code class="name">var <span class="ident">protocol</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def protocol(self):
    return dict()</code></pre>
</details>
</dd>
<dt id="bathysphere.models.Actuators.state"><code class="name">var <span class="ident">state</span></code></dt>
<dd>
<div class="desc"><p>Get current state of specified relay</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
async def state(self, relay_id=None):
    &#34;&#34;&#34;
    Get current state of specified relay
    &#34;&#34;&#34;
    return self.sendMessage(
        [self.protocol[&#34;diagnostic&#34;][&#34;status&#34;]], identity=relay_id, debug=True
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="bathysphere.models.Actuators.off"><code class="name flex">
<span>async def <span class="ident">off</span></span>(<span>self, relay_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Turn specified relay off</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def off(self, relay_id=None):
    &#34;&#34;&#34;
    Turn specified relay off
    &#34;&#34;&#34;
    return self.sendMessage([self.protocol[&#34;tasks&#34;][&#34;off&#34;]], identity=relay_id)</code></pre>
</details>
</dd>
<dt id="bathysphere.models.Actuators.on"><code class="name flex">
<span>async def <span class="ident">on</span></span>(<span>self, relay_id, timer_id, duration=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Relay on, with optional duration</p>
<p>:param duration:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on(self, relay_id, timer_id, duration=None):
    &#34;&#34;&#34;
    Relay on, with optional duration

    :param duration:
    :return:
    &#34;&#34;&#34;
    commands = (
        [self.protocol[&#34;tasks&#34;][&#34;on&#34;]]
        if duration is None
        else [self.protocol[&#34;tasks&#34;][&#34;timer_setup&#34;], timer_id, 0, 0, duration]
    )
    return self.sendMessage(commands, identity=relay_id)</code></pre>
</details>
</dd>
<dt id="bathysphere.models.Actuators.recover"><code class="name flex">
<span>async def <span class="ident">recover</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Attempt emergency recovery</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def recover(self):
    &#34;&#34;&#34;
    Attempt emergency recovery
    &#34;&#34;&#34;
    return self.sendMessage(
        [self.protocol[&#34;diagnostic&#34;][&#34;board&#34;], self.protocol[&#34;tasks&#34;][&#34;recover&#34;]]
    )</code></pre>
</details>
</dd>
<dt id="bathysphere.models.Actuators.startController"><code class="name flex">
<span>def <span class="ident">startController</span></span>(<span>self, host: str, port: int, relay_id: int, banks: int, relays: int, refresh: int, file: str = None, verb: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Communicate with a single relay</p>
<p>:param host: hostname
:param port: port number
:param relay_id: relay id on board, doesn't get registered with graph
:param banks: number of replica banks
:param relays: total number of relays
:param refresh: fixed refresh rate, in seconds
:param file: log file
:param verb: log to console</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startController(
    self,
    host: str,
    port: int,
    relay_id: int,
    banks: int,
    relays: int,
    refresh: int,
    file: str = None,
    verb: bool = False,
) -&gt; bool:
    &#34;&#34;&#34;
    Communicate with a single relay

    :param host: hostname
    :param port: port number
    :param relay_id: relay id on board, doesn&#39;t get registered with graph
    :param banks: number of replica banks
    :param relays: total number of relays
    :param refresh: fixed refresh rate, in seconds
    :param file: log file
    :param verb: log to console
    &#34;&#34;&#34;
    timer_id = relay_id + self.metadata[&#34;config&#34;][&#34;timer_id_offset&#34;]
    # state = [[False] * banks] * (relays // banks)
    start = time()

    while True:
        response = self.on(relay_id, timer_id, duration=None)
        if not response:
            print(&#34;breaking loop.&#34;)
        sleep(refresh - ((time() - start) % refresh))

    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bathysphere.models.Assets"><code class="flex name class">
<span>class <span class="ident">Assets</span></span>
<span>(</span><span>name: str = None, description: str = None, location: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Assets are references to externaldata objects, which may or may not
be accessible at the time of query.</p>
<p>These are most likely ndarray/raster or json blobs in object storage</p>
<p>name: name of resource
description: annotation
location: address of resource, including protocol (e.g. postgres://)</p>
<p>Method generated by attrs for class Assets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Assets:
    &#34;&#34;&#34;
    Assets are references to externaldata objects, which may or may not
    be accessible at the time of query.

    These are most likely ndarray/raster or json blobs in object storage

    name: name of resource
    description: annotation
    location: address of resource, including protocol (e.g. postgres://)
    &#34;&#34;&#34;
    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    location: str = attr.ib(default=None)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.graph.models.Assets" href="graph/models.html#bathysphere.graph.models.Assets">Assets</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.models.Assets.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Assets.location"><code class="name">var <span class="ident">location</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Assets.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bathysphere.models.Collections"><code class="flex name class">
<span>class <span class="ident">Collections</span></span>
<span>(</span><span>name: str = None, description: str = None, extent: (<class 'float'>,) = None, keywords: str = None, license: str = None, version: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Collections are arbitrary groupings of entities.</p>
<p>Method generated by attrs for class Collections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Collections:
    &#34;&#34;&#34;
    Collections are arbitrary groupings of entities.
    &#34;&#34;&#34;
    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    extent: (float,) = attr.ib(default=None)
    keywords: str = attr.ib(default=None)
    license: str = attr.ib(default=None)
    version: int = attr.ib(default=None)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.graph.models.Collections" href="graph/models.html#bathysphere.graph.models.Collections">Collections</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.models.Collections.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Collections.extent"><code class="name">var <span class="ident">extent</span> : (<class 'float'>,)</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Collections.keywords"><code class="name">var <span class="ident">keywords</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Collections.license"><code class="name">var <span class="ident">license</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Collections.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Collections.version"><code class="name">var <span class="ident">version</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bathysphere.models.DataStreams"><code class="flex name class">
<span>class <span class="ident">DataStreams</span></span>
<span>(</span><span>name: str = None, description: str = None, unitOfMeasurement=None, observationType=None, observedArea: dict = None, phenomenonTime: (<class 'datetime.datetime'>, <class 'datetime.datetime'>) = None, resultTime: (<class 'datetime.datetime'>, <class 'datetime.datetime'>) = None)</span>
</code></dt>
<dd>
<div class="desc"><p>DataStreams are collections of Observations.</p>
<p>Method generated by attrs for class DataStreams.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataStreams:
    &#34;&#34;&#34;
    DataStreams are collections of Observations.
    &#34;&#34;&#34;

    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    unitOfMeasurement = attr.ib(default=None)
    observationType = attr.ib(default=None)
    observedArea: dict = attr.ib(default=None)  # boundary geometry, GeoJSON polygon
    phenomenonTime: (datetime, datetime) = attr.ib(
        default=None
    )  # time interval, ISO8601
    resultTime: (datetime, datetime) = attr.ib(
        default=None
    )  # result times interval, ISO8601

    @staticmethod
    def fourierTransform(dt=1, lowpass=None, highpass=None, fill=False, compress=True):
        &#34;&#34;&#34;
        Perform frequency-domain filtering on regularly spaced time series
        
        Kwargs:
        
            tt, float[] :: time series
            yy, float[] :: reference series
            dt, float :: regular timestep
            lowpass, float :: lower cutoff
            highpass, float :: upper cutoff
        &#34;&#34;&#34;
        series = tuple(item.value for item in request.json)
        spectrum: dict = DataStreams.frequencySpectrum(
            series, dt=dt, fill=fill, compress=compress
        )
        payload: dict = spectrum.get(&#34;payload&#34;)

        freq = payload[&#34;frequency&#34;]
        ww = payload[&#34;index&#34;]

        if highpass is not None:
            mask = ww &lt; highpass
            freq[mask] = 0.0  # zero out low frequency

        if lowpass is not None:
            mask = ww &gt; lowpass
            freq[mask] = 0.0  # zero out high-frequency

        filtered = irfft(freq)

        return response(200, payload=filtered)

    @staticmethod
    def frequencySpectrum(req, dt=1, fill=False, compress=True):

        series = array(tuple(item.value for item in req.json))

        if fill:
            series = series.ffill()  # forward-fill missing values

        index = fftfreq(len(series), d=dt)  # frequency indices
        freq = rfft(series)  # transform to frequency domain
        if compress:
            mask = index &lt; 0.0
            freq[mask] = 0.0  # get rid of negative symmetry

        return response(status=200, payload={&#34;frequency&#34;: freq, &#34;index&#34;: index})

    @staticmethod
    def smoothUsingConvolution(bandwidth, mode=&#34;same&#34;):
        &#34;&#34;&#34;
        Convolve

        :return:
        &#34;&#34;&#34;
        series = tuple(item.value for item in request.json)
        filtered = convolve(series, ones((bandwidth,)) / bandwidth, mode=mode)
        return response(200, payload=filtered)

    @staticmethod
    def resampleSparseSeries(method=&#34;forward&#34;, observations=None, start=None):
        &#34;&#34;&#34;
        Generate filled regular time series of a variable from sparse observations
        using either backward/forward fill, or linear interpolation
        
        Kwargs:
            nobs, int :: number of observations
            start, datetime :: starting time index
            dates, datetime[] :: timestamps of observations
            series, float[] :: magnitude of observations
            method, str :: method if interpolation
            
        returns: array of filled values as single column
        &#34;&#34;&#34;
        dates = tuple(item.time for item in request.json)
        series = tuple(item.value for item in request.json)

        if not observations:
            observations = (dates[-1] - dates[0]).hours + 1

        if not start:
            start = dates[0]

        new = zeros(observations, dtype=float)
        total = 0  # new observations created
        previous = None
        dtdt = None

        for ii in range(len(series)):
            time = dates[ii]
            signal = series[ii]
            if not isnan(signal):
                dt = time - start
                hours = (
                    dt.days * 24 + dt.seconds / 60 / 60
                )  # hours elapsed since first sample
                if hours &gt; 0:  # reference time is after start time
                    end = min(ceil(hours), observations)  # absolute end index
                    span = end - total  # width of subset

                    if method is &#34;forward&#34;:
                        first = total
                        if ii == len(series) - 1:
                            span += observations - end

                        last = total + span  # not including self
                        new[first:last] = (
                            signal if previous is None else previous
                        )  # default to back-fill

                    elif method is &#34;back&#34;:
                        first = total  # including self
                        last = total + span - 1
                        new[first:last] = signal

                    elif method is &#34;interp&#34;:
                        if dtdt is None:
                            fill = signal  # default to forward fill
                        else:
                            delta = end - dtdt  # get step between input obs
                            coefs = (
                                arange(delta) / delta
                            )  # inter-step interpolation coefficient
                            fill = interp1d(coefs, previous, signal)

                        first = max([total - 1, 0])
                        new[first : total + span - 1] = fill

                    dtdt = dt
                    total += span

                previous = signal

        return response(200, payload=new)

    def statisticalOutlierMask(
        self, assumeEvenSpacing: bool = False, threshold: float = 3.5
    ):
        &#34;&#34;&#34;
        Return array of logical values, with true indicating that the value or its 
        first derivative are outliers
        &#34;&#34;&#34;

        dates = tuple(item.time for item in request.json)
        series = tuple(item.value for item in request.json)

        if assumeEvenSpacing:
            dydt = series
        else:
            dydt = [0.0]
            deltat = [0.0]

            for nn in range(1, len(series)):
                deltat.append(dates[nn] - dates[nn - 1])
                dydt.append((series[nn] - series[nn - 1]) / deltat[nn])

        diff = abs(
            series - median(series)
        )  # difference between series and median (anomaly)
        mad = median(diff)  # median of anomaly
        mod_z = 0.6745 * diff / mad
        mask = mod_z &gt; threshold

        return response(200, payload=mask)

    @staticmethod
    def outOfRangeMask(min, max):
        &#34;&#34;&#34;
        Use backend to generate a mask. 
        &#34;&#34;&#34;
        series = tuple(item.value for item in request.json)
        mask = map(lambda x: x.outOfRange(maximum=max, minimum=min), series)

        return response(200, payload=mask)

    def partition(
        self, window: int, horizon: int, batch_size: int, ratio: float, periods: int
    ):
        &#34;&#34;&#34;

        :param window: moving average observations
        :param horizon: look ahead
        :param periods: number of observations
        :param batch_size: length of training segment
        :param ratio: approximate ratio of observations to use for training
    
        :return:
        &#34;&#34;&#34;

        # reshaping functions
        def reshape3d(x):
            return x.values.reshape((x.shape[0], x.shape[1], 1))

        def reshape2d(y):
            return y.values.reshape((y.shape[0], 1))

        start = max(window - 1, horizon - 1)
        nn = int(periods * ratio)
        nn -= nn % batch_size

        # TODO: I think this is pandas.Series
        observations = ()
        series = Series(item.result for item in observations)
        expected = series.rolling(
            window=window, center=False
        ).mean()  # set the target to moving average

        if horizon &gt; 1:
            datastream = DataFrame(repeat(datastream.values, repeats=horizon, axis=1))
            for i, c in enumerate(datastream.columns):
                datastream[c] = datastream[c].shift(
                    i
                )  # shift each by one more, &#34;rolling window view&#34; of data

        end = datastream.shape[0] % batch_size  # match with batch_size

        return {
            &#34;training&#34;: {
                &#34;x&#34;: reshape3d(datastream[start : start + nn]),
                &#34;y&#34;: reshape2d(expected[start : start + nn]),
            },
            &#34;validation&#34;: {
                &#34;x&#34;: reshape3d(
                    datastream[start + nn : -1 * end]
                    if end
                    else datastream[start + nn :]
                ),
                &#34;y&#34;: reshape2d(
                    expected[start + nn : -1 * end] if end else expected[start + nn :]
                ),
            },
        }</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.graph.models.DataStreams" href="graph/models.html#bathysphere.graph.models.DataStreams">DataStreams</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.models.DataStreams.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.DataStreams.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.DataStreams.observedArea"><code class="name">var <span class="ident">observedArea</span> : dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.DataStreams.phenomenonTime"><code class="name">var <span class="ident">phenomenonTime</span> : (<class 'datetime.datetime'>, <class 'datetime.datetime'>)</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.DataStreams.resultTime"><code class="name">var <span class="ident">resultTime</span> : (<class 'datetime.datetime'>, <class 'datetime.datetime'>)</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="bathysphere.models.DataStreams.fourierTransform"><code class="name flex">
<span>def <span class="ident">fourierTransform</span></span>(<span>dt=1, lowpass=None, highpass=None, fill=False, compress=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform frequency-domain filtering on regularly spaced time series</p>
<h2 id="kwargs">Kwargs</h2>
<p>tt, float[] :: time series
yy, float[] :: reference series
dt, float :: regular timestep
lowpass, float :: lower cutoff
highpass, float :: upper cutoff</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fourierTransform(dt=1, lowpass=None, highpass=None, fill=False, compress=True):
    &#34;&#34;&#34;
    Perform frequency-domain filtering on regularly spaced time series
    
    Kwargs:
    
        tt, float[] :: time series
        yy, float[] :: reference series
        dt, float :: regular timestep
        lowpass, float :: lower cutoff
        highpass, float :: upper cutoff
    &#34;&#34;&#34;
    series = tuple(item.value for item in request.json)
    spectrum: dict = DataStreams.frequencySpectrum(
        series, dt=dt, fill=fill, compress=compress
    )
    payload: dict = spectrum.get(&#34;payload&#34;)

    freq = payload[&#34;frequency&#34;]
    ww = payload[&#34;index&#34;]

    if highpass is not None:
        mask = ww &lt; highpass
        freq[mask] = 0.0  # zero out low frequency

    if lowpass is not None:
        mask = ww &gt; lowpass
        freq[mask] = 0.0  # zero out high-frequency

    filtered = irfft(freq)

    return response(200, payload=filtered)</code></pre>
</details>
</dd>
<dt id="bathysphere.models.DataStreams.frequencySpectrum"><code class="name flex">
<span>def <span class="ident">frequencySpectrum</span></span>(<span>req, dt=1, fill=False, compress=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def frequencySpectrum(req, dt=1, fill=False, compress=True):

    series = array(tuple(item.value for item in req.json))

    if fill:
        series = series.ffill()  # forward-fill missing values

    index = fftfreq(len(series), d=dt)  # frequency indices
    freq = rfft(series)  # transform to frequency domain
    if compress:
        mask = index &lt; 0.0
        freq[mask] = 0.0  # get rid of negative symmetry

    return response(status=200, payload={&#34;frequency&#34;: freq, &#34;index&#34;: index})</code></pre>
</details>
</dd>
<dt id="bathysphere.models.DataStreams.outOfRangeMask"><code class="name flex">
<span>def <span class="ident">outOfRangeMask</span></span>(<span>min, max)</span>
</code></dt>
<dd>
<div class="desc"><p>Use backend to generate a mask.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def outOfRangeMask(min, max):
    &#34;&#34;&#34;
    Use backend to generate a mask. 
    &#34;&#34;&#34;
    series = tuple(item.value for item in request.json)
    mask = map(lambda x: x.outOfRange(maximum=max, minimum=min), series)

    return response(200, payload=mask)</code></pre>
</details>
</dd>
<dt id="bathysphere.models.DataStreams.resampleSparseSeries"><code class="name flex">
<span>def <span class="ident">resampleSparseSeries</span></span>(<span>method='forward', observations=None, start=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate filled regular time series of a variable from sparse observations
using either backward/forward fill, or linear interpolation</p>
<h2 id="kwargs">Kwargs</h2>
<p>nobs, int :: number of observations
start, datetime :: starting time index
dates, datetime[] :: timestamps of observations
series, float[] :: magnitude of observations
method, str :: method if interpolation</p>
<p>returns: array of filled values as single column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def resampleSparseSeries(method=&#34;forward&#34;, observations=None, start=None):
    &#34;&#34;&#34;
    Generate filled regular time series of a variable from sparse observations
    using either backward/forward fill, or linear interpolation
    
    Kwargs:
        nobs, int :: number of observations
        start, datetime :: starting time index
        dates, datetime[] :: timestamps of observations
        series, float[] :: magnitude of observations
        method, str :: method if interpolation
        
    returns: array of filled values as single column
    &#34;&#34;&#34;
    dates = tuple(item.time for item in request.json)
    series = tuple(item.value for item in request.json)

    if not observations:
        observations = (dates[-1] - dates[0]).hours + 1

    if not start:
        start = dates[0]

    new = zeros(observations, dtype=float)
    total = 0  # new observations created
    previous = None
    dtdt = None

    for ii in range(len(series)):
        time = dates[ii]
        signal = series[ii]
        if not isnan(signal):
            dt = time - start
            hours = (
                dt.days * 24 + dt.seconds / 60 / 60
            )  # hours elapsed since first sample
            if hours &gt; 0:  # reference time is after start time
                end = min(ceil(hours), observations)  # absolute end index
                span = end - total  # width of subset

                if method is &#34;forward&#34;:
                    first = total
                    if ii == len(series) - 1:
                        span += observations - end

                    last = total + span  # not including self
                    new[first:last] = (
                        signal if previous is None else previous
                    )  # default to back-fill

                elif method is &#34;back&#34;:
                    first = total  # including self
                    last = total + span - 1
                    new[first:last] = signal

                elif method is &#34;interp&#34;:
                    if dtdt is None:
                        fill = signal  # default to forward fill
                    else:
                        delta = end - dtdt  # get step between input obs
                        coefs = (
                            arange(delta) / delta
                        )  # inter-step interpolation coefficient
                        fill = interp1d(coefs, previous, signal)

                    first = max([total - 1, 0])
                    new[first : total + span - 1] = fill

                dtdt = dt
                total += span

            previous = signal

    return response(200, payload=new)</code></pre>
</details>
</dd>
<dt id="bathysphere.models.DataStreams.smoothUsingConvolution"><code class="name flex">
<span>def <span class="ident">smoothUsingConvolution</span></span>(<span>bandwidth, mode='same')</span>
</code></dt>
<dd>
<div class="desc"><p>Convolve</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def smoothUsingConvolution(bandwidth, mode=&#34;same&#34;):
    &#34;&#34;&#34;
    Convolve

    :return:
    &#34;&#34;&#34;
    series = tuple(item.value for item in request.json)
    filtered = convolve(series, ones((bandwidth,)) / bandwidth, mode=mode)
    return response(200, payload=filtered)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="bathysphere.models.DataStreams.partition"><code class="name flex">
<span>def <span class="ident">partition</span></span>(<span>self, window: int, horizon: int, batch_size: int, ratio: float, periods: int)</span>
</code></dt>
<dd>
<div class="desc"><p>:param window: moving average observations
:param horizon: look ahead
:param periods: number of observations
:param batch_size: length of training segment
:param ratio: approximate ratio of observations to use for training</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition(
    self, window: int, horizon: int, batch_size: int, ratio: float, periods: int
):
    &#34;&#34;&#34;

    :param window: moving average observations
    :param horizon: look ahead
    :param periods: number of observations
    :param batch_size: length of training segment
    :param ratio: approximate ratio of observations to use for training

    :return:
    &#34;&#34;&#34;

    # reshaping functions
    def reshape3d(x):
        return x.values.reshape((x.shape[0], x.shape[1], 1))

    def reshape2d(y):
        return y.values.reshape((y.shape[0], 1))

    start = max(window - 1, horizon - 1)
    nn = int(periods * ratio)
    nn -= nn % batch_size

    # TODO: I think this is pandas.Series
    observations = ()
    series = Series(item.result for item in observations)
    expected = series.rolling(
        window=window, center=False
    ).mean()  # set the target to moving average

    if horizon &gt; 1:
        datastream = DataFrame(repeat(datastream.values, repeats=horizon, axis=1))
        for i, c in enumerate(datastream.columns):
            datastream[c] = datastream[c].shift(
                i
            )  # shift each by one more, &#34;rolling window view&#34; of data

    end = datastream.shape[0] % batch_size  # match with batch_size

    return {
        &#34;training&#34;: {
            &#34;x&#34;: reshape3d(datastream[start : start + nn]),
            &#34;y&#34;: reshape2d(expected[start : start + nn]),
        },
        &#34;validation&#34;: {
            &#34;x&#34;: reshape3d(
                datastream[start + nn : -1 * end]
                if end
                else datastream[start + nn :]
            ),
            &#34;y&#34;: reshape2d(
                expected[start + nn : -1 * end] if end else expected[start + nn :]
            ),
        },
    }</code></pre>
</details>
</dd>
<dt id="bathysphere.models.DataStreams.statisticalOutlierMask"><code class="name flex">
<span>def <span class="ident">statisticalOutlierMask</span></span>(<span>self, assumeEvenSpacing: bool = False, threshold: float = 3.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Return array of logical values, with true indicating that the value or its
first derivative are outliers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def statisticalOutlierMask(
    self, assumeEvenSpacing: bool = False, threshold: float = 3.5
):
    &#34;&#34;&#34;
    Return array of logical values, with true indicating that the value or its 
    first derivative are outliers
    &#34;&#34;&#34;

    dates = tuple(item.time for item in request.json)
    series = tuple(item.value for item in request.json)

    if assumeEvenSpacing:
        dydt = series
    else:
        dydt = [0.0]
        deltat = [0.0]

        for nn in range(1, len(series)):
            deltat.append(dates[nn] - dates[nn - 1])
            dydt.append((series[nn] - series[nn - 1]) / deltat[nn])

    diff = abs(
        series - median(series)
    )  # difference between series and median (anomaly)
    mad = median(diff)  # median of anomaly
    mod_z = 0.6745 * diff / mad
    mask = mod_z &gt; threshold

    return response(200, payload=mask)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bathysphere.models.FeaturesOfInterest"><code class="flex name class">
<span>class <span class="ident">FeaturesOfInterest</span></span>
<span>(</span><span>name: str = None, description: str = None, encodingType: str = None, feature: Any = None)</span>
</code></dt>
<dd>
<div class="desc"><p>FeaturesOfInterest are usually Locations.</p>
<p>Method generated by attrs for class FeaturesOfInterest.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeaturesOfInterest(object):
    &#34;&#34;&#34;
    FeaturesOfInterest are usually Locations.
    &#34;&#34;&#34;

    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    encodingType: str = attr.ib(default=None)  # metadata encoding
    feature: Any = attr.ib(default=None)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.graph.models.FeaturesOfInterest" href="graph/models.html#bathysphere.graph.models.FeaturesOfInterest">FeaturesOfInterest</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.models.FeaturesOfInterest.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.FeaturesOfInterest.encodingType"><code class="name">var <span class="ident">encodingType</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.FeaturesOfInterest.feature"><code class="name">var <span class="ident">feature</span> : Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.FeaturesOfInterest.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bathysphere.models.HistoricalLocations"><code class="flex name class">
<span>class <span class="ident">HistoricalLocations</span></span>
<span>(</span><span>time: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Private and automatic, should be added to sensor when new location is determined</p>
<p>Method generated by attrs for class HistoricalLocations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HistoricalLocations(object):
    &#34;&#34;&#34;
    Private and automatic, should be added to sensor when new location is determined
    &#34;&#34;&#34;

    time: str = attr.ib(
        default=None
    )  # time when thing was at location (ISO-8601 string)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.graph.models.HistoricalLocations" href="graph/models.html#bathysphere.graph.models.HistoricalLocations">HistoricalLocations</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.models.HistoricalLocations.time"><code class="name">var <span class="ident">time</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bathysphere.models.Locations"><code class="flex name class">
<span>class <span class="ident">Locations</span></span>
<span>(</span><span>description: str = None, encodingType: str = None, location=None, name: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Last known <code><a title="bathysphere.models.Locations" href="#bathysphere.models.Locations">Locations</a></code> of <code><a title="bathysphere.models.Things" href="#bathysphere.models.Things">Things</a></code>. May be <code><a title="bathysphere.models.FeaturesOfInterest" href="#bathysphere.models.FeaturesOfInterest">FeaturesOfInterest</a></code>, unless remote sensing.</p>
<p>location encoding may be <code>application/vnd.geo+json</code> or <code>application/json</code></p>
<p>Method generated by attrs for class Locations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Locations(object):
    &#34;&#34;&#34;
    Last known `Locations` of `Things`. May be `FeaturesOfInterest`, unless remote sensing.

    location encoding may be `application/vnd.geo+json` or `application/json`
    &#34;&#34;&#34;
    description: str = attr.ib(default=None)
    encodingType: str = attr.ib(default=None)
    location = attr.ib(default=None)  # GeoJSON
    name: str = attr.ib(default=None)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.graph.models.Locations" href="graph/models.html#bathysphere.graph.models.Locations">Locations</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.models.Locations.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Locations.encodingType"><code class="name">var <span class="ident">encodingType</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Locations.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bathysphere.models.Observations"><code class="flex name class">
<span>class <span class="ident">Observations</span></span>
<span>(</span><span>phenomenonTime: datetime.datetime = None, result: Any = None, resultTime: datetime.datetime = None, resultQuality: Any = None, validTime: (<class 'datetime.datetime'>, <class 'datetime.datetime'>) = None, parameters: dict = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Observations are individual time-stamped members of Datastreams</p>
<p>Method generated by attrs for class Observations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Observations(object):
    &#34;&#34;&#34;
    Observations are individual time-stamped members of Datastreams
    &#34;&#34;&#34;

    phenomenonTime: datetime = attr.ib(
        default=None
    )  # timestamp, doesn&#39;t enforce specific format
    result: Any = attr.ib(default=None)  # value of the observation
    resultTime: datetime = attr.ib(default=None)
    resultQuality: Any = attr.ib(default=None)
    validTime: (datetime, datetime) = attr.ib(default=None)  # time period
    parameters: dict = attr.ib(default=None)

    @property
    def outOfRange(self, maximum, minimum=0.0):
        &#34;&#34;&#34;
        True if value is outside the given range
        &#34;&#34;&#34;
        return (self.result &gt; maximum) | (self.result &lt; minimum)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.graph.models.Observations" href="graph/models.html#bathysphere.graph.models.Observations">Observations</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.models.Observations.parameters"><code class="name">var <span class="ident">parameters</span> : dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Observations.phenomenonTime"><code class="name">var <span class="ident">phenomenonTime</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Observations.result"><code class="name">var <span class="ident">result</span> : Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Observations.resultQuality"><code class="name">var <span class="ident">resultQuality</span> : Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Observations.resultTime"><code class="name">var <span class="ident">resultTime</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Observations.validTime"><code class="name">var <span class="ident">validTime</span> : (<class 'datetime.datetime'>, <class 'datetime.datetime'>)</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="bathysphere.models.Observations.outOfRange"><code class="name">var <span class="ident">outOfRange</span></code></dt>
<dd>
<div class="desc"><p>True if value is outside the given range</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def outOfRange(self, maximum, minimum=0.0):
    &#34;&#34;&#34;
    True if value is outside the given range
    &#34;&#34;&#34;
    return (self.result &gt; maximum) | (self.result &lt; minimum)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bathysphere.models.ObservedProperties"><code class="flex name class">
<span>class <span class="ident">ObservedProperties</span></span>
<span>(</span><span>name: str = None, description: str = None, definition: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a property, but do not associate any data streams with it</p>
<p>Method generated by attrs for class ObservedProperties.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ObservedProperties(object):
    &#34;&#34;&#34;
    Create a property, but do not associate any data streams with it
    &#34;&#34;&#34;

    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    definition: str = attr.ib(default=None)  #  URL to reference defining the property</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.graph.models.ObservedProperties" href="graph/models.html#bathysphere.graph.models.ObservedProperties">ObservedProperties</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.models.ObservedProperties.definition"><code class="name">var <span class="ident">definition</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.ObservedProperties.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.ObservedProperties.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bathysphere.models.Providers"><code class="flex name class">
<span>class <span class="ident">Providers</span></span>
<span>(</span><span>name: str = None, description: str = None, domain: str = None, secretKey: str = None, apiKey: str = None, tokenDuration: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Providers are generally organization or enterprise sub-units. This is used to
route ingress and determine implicit permissions for data access, sharing, and
attribution. </p>
<p>Method generated by attrs for class Providers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Providers(object):
    &#34;&#34;&#34;
    Providers are generally organization or enterprise sub-units. This is used to
    route ingress and determine implicit permissions for data access, sharing, and
    attribution. 
    &#34;&#34;&#34;

    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    domain: str = attr.ib(default=None)
    secretKey: str = attr.ib(default=None)
    apiKey: str = attr.ib(default=None)
    tokenDuration: int = attr.ib(default=None)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.graph.models.Providers" href="graph/models.html#bathysphere.graph.models.Providers">Providers</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.models.Providers.apiKey"><code class="name">var <span class="ident">apiKey</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Providers.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Providers.domain"><code class="name">var <span class="ident">domain</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Providers.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Providers.secretKey"><code class="name">var <span class="ident">secretKey</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Providers.tokenDuration"><code class="name">var <span class="ident">tokenDuration</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bathysphere.models.Sensors"><code class="flex name class">
<span>class <span class="ident">Sensors</span></span>
<span>(</span><span>name: str = None, description: str = None, encodingType: str = None, metadata: Any = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sensors are devices that observe processes</p>
<p>Method generated by attrs for class Sensors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sensors(object):
    &#34;&#34;&#34;
    Sensors are devices that observe processes
    &#34;&#34;&#34;

    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    encodingType: str = attr.ib(default=None)  # metadata encoding
    metadata: Any = attr.ib(default=None)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.graph.models.Sensors" href="graph/models.html#bathysphere.graph.models.Sensors">Sensors</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.models.Sensors.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Sensors.encodingType"><code class="name">var <span class="ident">encodingType</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Sensors.metadata"><code class="name">var <span class="ident">metadata</span> : Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Sensors.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bathysphere.models.Simulations"><code class="flex name class">
<span>class <span class="ident">Simulations</span></span>
</code></dt>
<dd>
<div class="desc"><p>Method generated by attrs for class Simulations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Simulations(object):
    
    @staticmethod
    def batch(config: dict, forcing: array, workers: int = 1) -&gt; dict:
        &#34;&#34;&#34;
        Run a batch, and generate some statistics about execution

        :param config: kwarg dictionary of single or iterable values
        :param forcing: pre-processed data for all simulations, an iterable of iterables
        :param workers: maximum number of workers to request, will be reduced if necessary

        :return: batch of responses with metadata as JSON-like dictionary
        &#34;&#34;&#34;

        def _repeat(value):
            try:
                assert len(value) &gt; 0
                assert type(value) != str
                return value
            except TypeError:
                return repeat(value, n)
            except AssertionError:
                return repeat(value, n)

        def _expand(json):
            new = {key: _repeat(value) for key, value in json.items()}
            return tuple(
                [dict(zip(new, item)) for item in zip(*new.values()) for _ in range(n)]
            )

        processes = min(cpu_count(), workers)
        tempfile = BytesIO()

        with Pool(processes) as pool:
            start = time()
            n = len(forcing)
            JSONIOWrapper.log(&#34;Scheduler ready&#34;, f&#34;spawning {n} workers&#34;, log=tempfile)
            result = pool.starmap(Simulations.job, zip(_expand(config), forcing))
            data, logs = zip(*result)
            finish = time()
            JSONIOWrapper.log(
                &#34;Scheduler done&#34;, f&#34;completed {n} jobs in {finish-start} s&#34;, log=tempfile
            )

        return {
            &#34;data&#34;: data,
            &#34;logs&#34;: logs + (tempfile.getvalue(),),
            &#34;workers&#34;: processes,
            &#34;config&#34;: config,
            &#34;count&#34;: n,
            &#34;start&#34;: start,
            &#34;finish&#34;: finish,
        }

    @staticmethod
    def job(
        config: dict, 
        forcing: array,
        encoding: str = &#34;utf-8&#34;
    ) -&gt; (tuple, bytes):
        &#34;&#34;&#34;
        Execute single simulation with synchronous callback.

        :param config: simulation configuration
        :param forcing: list of forcing vectors
        :param encoding: input/output encoding

        :return: output variables of C# methods, or None
        &#34;&#34;&#34;
        n = len(forcing)
        tempfile = BytesIO()
        process = None
    
        command = [config.get(&#34;executable&#34;), __path__[0] + &#34;/..&#34; + config.get(&#34;exePath&#34;)]
        process = Popen(command, stdin=PIPE, stdout=PIPE, stderr=STDOUT, bufsize=1)
       
        if process is None:
            JSONIOWrapper.log(message=&#34;Mono&#34;, data=&#34;not found&#34;, log=tempfile)
            return ({&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &#34;mono not found&#34;},)

        JSONIOWrapper.log(
            message=f&#34;Spawned process {process.pid}&#34;, data=process.args, log=tempfile
        )
        console = JSONIOWrapper(process.stdin, encoding=encoding, line_buffering=True)
        output = JSONIOWrapper(process.stdout, encoding=encoding, line_buffering=False)

        result = [output.receive(log=tempfile) for _ in range(2)]
        console.send(config, log=tempfile)

        JSONIOWrapper.log(
            message=&#34;Worker ready&#34;, data=f&#34;expecting {n} transactions&#34;, log=tempfile
        )

        for item in forcing:
            console.send(item, log=tempfile)  # send data as serialized dictionary
            state = output.receive(log=tempfile)
            if state[&#34;status&#34;] == &#34;error&#34;:
                JSONIOWrapper.log(message=&#34;Runtime&#34;, data=state[&#34;message&#34;], log=tempfile)
                result += [state]
                break
            result += [state]

        JSONIOWrapper.log(
            message=&#34;Worker done&#34;,
            data=f&#34;completed {len(result)} transactions&#34;,
            log=tempfile,
        )
        process.kill()
        process.wait()
        console.close()
        output.close()
        return tuple(result), tempfile.getvalue()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="bathysphere.models.Simulations.batch"><code class="name flex">
<span>def <span class="ident">batch</span></span>(<span>config: dict, forcing: <built-in function array>, workers: int = 1) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Run a batch, and generate some statistics about execution</p>
<p>:param config: kwarg dictionary of single or iterable values
:param forcing: pre-processed data for all simulations, an iterable of iterables
:param workers: maximum number of workers to request, will be reduced if necessary</p>
<p>:return: batch of responses with metadata as JSON-like dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def batch(config: dict, forcing: array, workers: int = 1) -&gt; dict:
    &#34;&#34;&#34;
    Run a batch, and generate some statistics about execution

    :param config: kwarg dictionary of single or iterable values
    :param forcing: pre-processed data for all simulations, an iterable of iterables
    :param workers: maximum number of workers to request, will be reduced if necessary

    :return: batch of responses with metadata as JSON-like dictionary
    &#34;&#34;&#34;

    def _repeat(value):
        try:
            assert len(value) &gt; 0
            assert type(value) != str
            return value
        except TypeError:
            return repeat(value, n)
        except AssertionError:
            return repeat(value, n)

    def _expand(json):
        new = {key: _repeat(value) for key, value in json.items()}
        return tuple(
            [dict(zip(new, item)) for item in zip(*new.values()) for _ in range(n)]
        )

    processes = min(cpu_count(), workers)
    tempfile = BytesIO()

    with Pool(processes) as pool:
        start = time()
        n = len(forcing)
        JSONIOWrapper.log(&#34;Scheduler ready&#34;, f&#34;spawning {n} workers&#34;, log=tempfile)
        result = pool.starmap(Simulations.job, zip(_expand(config), forcing))
        data, logs = zip(*result)
        finish = time()
        JSONIOWrapper.log(
            &#34;Scheduler done&#34;, f&#34;completed {n} jobs in {finish-start} s&#34;, log=tempfile
        )

    return {
        &#34;data&#34;: data,
        &#34;logs&#34;: logs + (tempfile.getvalue(),),
        &#34;workers&#34;: processes,
        &#34;config&#34;: config,
        &#34;count&#34;: n,
        &#34;start&#34;: start,
        &#34;finish&#34;: finish,
    }</code></pre>
</details>
</dd>
<dt id="bathysphere.models.Simulations.job"><code class="name flex">
<span>def <span class="ident">job</span></span>(<span>config: dict, forcing: <built-in function array>, encoding: str = 'utf-8') ‑> (<class 'tuple'>, <class 'bytes'>)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute single simulation with synchronous callback.</p>
<p>:param config: simulation configuration
:param forcing: list of forcing vectors
:param encoding: input/output encoding</p>
<p>:return: output variables of C# methods, or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def job(
    config: dict, 
    forcing: array,
    encoding: str = &#34;utf-8&#34;
) -&gt; (tuple, bytes):
    &#34;&#34;&#34;
    Execute single simulation with synchronous callback.

    :param config: simulation configuration
    :param forcing: list of forcing vectors
    :param encoding: input/output encoding

    :return: output variables of C# methods, or None
    &#34;&#34;&#34;
    n = len(forcing)
    tempfile = BytesIO()
    process = None

    command = [config.get(&#34;executable&#34;), __path__[0] + &#34;/..&#34; + config.get(&#34;exePath&#34;)]
    process = Popen(command, stdin=PIPE, stdout=PIPE, stderr=STDOUT, bufsize=1)
   
    if process is None:
        JSONIOWrapper.log(message=&#34;Mono&#34;, data=&#34;not found&#34;, log=tempfile)
        return ({&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &#34;mono not found&#34;},)

    JSONIOWrapper.log(
        message=f&#34;Spawned process {process.pid}&#34;, data=process.args, log=tempfile
    )
    console = JSONIOWrapper(process.stdin, encoding=encoding, line_buffering=True)
    output = JSONIOWrapper(process.stdout, encoding=encoding, line_buffering=False)

    result = [output.receive(log=tempfile) for _ in range(2)]
    console.send(config, log=tempfile)

    JSONIOWrapper.log(
        message=&#34;Worker ready&#34;, data=f&#34;expecting {n} transactions&#34;, log=tempfile
    )

    for item in forcing:
        console.send(item, log=tempfile)  # send data as serialized dictionary
        state = output.receive(log=tempfile)
        if state[&#34;status&#34;] == &#34;error&#34;:
            JSONIOWrapper.log(message=&#34;Runtime&#34;, data=state[&#34;message&#34;], log=tempfile)
            result += [state]
            break
        result += [state]

    JSONIOWrapper.log(
        message=&#34;Worker done&#34;,
        data=f&#34;completed {len(result)} transactions&#34;,
        log=tempfile,
    )
    process.kill()
    process.wait()
    console.close()
    output.close()
    return tuple(result), tempfile.getvalue()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bathysphere.models.TaskingCapabilities"><code class="flex name class">
<span>class <span class="ident">TaskingCapabilities</span></span>
<span>(</span><span>name: str = None, description: str = None, creationTime: float = None, taskingParameters: dict = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract tasking class mapping I/O and generating signal.</p>
<p>Method generated by attrs for class TaskingCapabilities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TaskingCapabilities(object):
    &#34;&#34;&#34;
    Abstract tasking class mapping I/O and generating signal.
    &#34;&#34;&#34;
    name: str = attr.ib(default=None)
    description: str =  attr.ib(default=None)
    creationTime: float = attr.ib(default=None)
    taskingParameters: dict = attr.ib(default=None)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.graph.models.TaskingCapabilities" href="graph/models.html#bathysphere.graph.models.TaskingCapabilities">TaskingCapabilities</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.models.TaskingCapabilities.creationTime"><code class="name">var <span class="ident">creationTime</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.TaskingCapabilities.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.TaskingCapabilities.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.TaskingCapabilities.taskingParameters"><code class="name">var <span class="ident">taskingParameters</span> : dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bathysphere.models.Tasks"><code class="flex name class">
<span>class <span class="ident">Tasks</span></span>
<span>(</span><span>creationTime: float = None, taskingParameters: dict = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Tasks are pieces of work that are done asynchronously by humans or machines.</p>
<p>Method generated by attrs for class Tasks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tasks(object):
    &#34;&#34;&#34;
    Tasks are pieces of work that are done asynchronously by humans or machines.
    &#34;&#34;&#34;
    creationTime: float = attr.ib(default=None)
    taskingParameters: dict = attr.ib(default=None)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.graph.models.Tasks" href="graph/models.html#bathysphere.graph.models.Tasks">Tasks</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.models.Tasks.creationTime"><code class="name">var <span class="ident">creationTime</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Tasks.taskingParameters"><code class="name">var <span class="ident">taskingParameters</span> : dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bathysphere.models.Things"><code class="flex name class">
<span>class <span class="ident">Things</span></span>
<span>(</span><span>name: str = None, description: str = None, properties: dict = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A thing is an object of the physical or information world that is capable of of being identified
and integrated into communication networks.</p>
<p>Method generated by attrs for class Things.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Things(object):
    &#34;&#34;&#34;
    A thing is an object of the physical or information world that is capable of of being identified
    and integrated into communication networks.
    &#34;&#34;&#34;

    name: str = attr.ib(default=None)
    description: str = attr.ib(default=None)
    properties: dict = attr.ib(default=None)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.graph.models.Things" href="graph/models.html#bathysphere.graph.models.Things">Things</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.models.Things.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Things.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.Things.properties"><code class="name">var <span class="ident">properties</span> : dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bathysphere.models.User"><code class="flex name class">
<span>class <span class="ident">User</span></span>
<span>(</span><span>ip: str = None, name: str = None, alias: str = None, credential: str = None, validated: bool = True, description: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a user entity. Users contain authorization secrets, and do not enter/leave
the system through the same routes as normal Entities</p>
<p>Method generated by attrs for class User.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class User(object):
    &#34;&#34;&#34;
    Create a user entity. Users contain authorization secrets, and do not enter/leave
    the system through the same routes as normal Entities
    &#34;&#34;&#34;

    ip: str = attr.ib(default=None)
    name: str = attr.ib(default=None)
    alias: str = attr.ib(default=None)
    credential: str = attr.ib(default=None)
    validated: bool = attr.ib(default=True)
    description: str = attr.ib(default=None)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.graph.models.User" href="graph/models.html#bathysphere.graph.models.User">User</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.models.User.alias"><code class="name">var <span class="ident">alias</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.User.credential"><code class="name">var <span class="ident">credential</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.User.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.User.ip"><code class="name">var <span class="ident">ip</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.User.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bathysphere.models.User.validated"><code class="name">var <span class="ident">validated</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bathysphere" href="index.html">bathysphere</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="bathysphere.models.Actuators" href="#bathysphere.models.Actuators">Actuators</a></code></h4>
<ul class="two-column">
<li><code><a title="bathysphere.models.Actuators.addEventListener" href="#bathysphere.models.Actuators.addEventListener">addEventListener</a></code></li>
<li><code><a title="bathysphere.models.Actuators.defaults" href="#bathysphere.models.Actuators.defaults">defaults</a></code></li>
<li><code><a title="bathysphere.models.Actuators.description" href="#bathysphere.models.Actuators.description">description</a></code></li>
<li><code><a title="bathysphere.models.Actuators.encodingType" href="#bathysphere.models.Actuators.encodingType">encodingType</a></code></li>
<li><code><a title="bathysphere.models.Actuators.metadata" href="#bathysphere.models.Actuators.metadata">metadata</a></code></li>
<li><code><a title="bathysphere.models.Actuators.name" href="#bathysphere.models.Actuators.name">name</a></code></li>
<li><code><a title="bathysphere.models.Actuators.networkAddress" href="#bathysphere.models.Actuators.networkAddress">networkAddress</a></code></li>
<li><code><a title="bathysphere.models.Actuators.off" href="#bathysphere.models.Actuators.off">off</a></code></li>
<li><code><a title="bathysphere.models.Actuators.on" href="#bathysphere.models.Actuators.on">on</a></code></li>
<li><code><a title="bathysphere.models.Actuators.protocol" href="#bathysphere.models.Actuators.protocol">protocol</a></code></li>
<li><code><a title="bathysphere.models.Actuators.pulseWidth" href="#bathysphere.models.Actuators.pulseWidth">pulseWidth</a></code></li>
<li><code><a title="bathysphere.models.Actuators.recover" href="#bathysphere.models.Actuators.recover">recover</a></code></li>
<li><code><a title="bathysphere.models.Actuators.rewindControlLoop" href="#bathysphere.models.Actuators.rewindControlLoop">rewindControlLoop</a></code></li>
<li><code><a title="bathysphere.models.Actuators.sendMessage" href="#bathysphere.models.Actuators.sendMessage">sendMessage</a></code></li>
<li><code><a title="bathysphere.models.Actuators.signalTransform" href="#bathysphere.models.Actuators.signalTransform">signalTransform</a></code></li>
<li><code><a title="bathysphere.models.Actuators.startControlLoop" href="#bathysphere.models.Actuators.startControlLoop">startControlLoop</a></code></li>
<li><code><a title="bathysphere.models.Actuators.startController" href="#bathysphere.models.Actuators.startController">startController</a></code></li>
<li><code><a title="bathysphere.models.Actuators.state" href="#bathysphere.models.Actuators.state">state</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.models.Assets" href="#bathysphere.models.Assets">Assets</a></code></h4>
<ul class="">
<li><code><a title="bathysphere.models.Assets.description" href="#bathysphere.models.Assets.description">description</a></code></li>
<li><code><a title="bathysphere.models.Assets.location" href="#bathysphere.models.Assets.location">location</a></code></li>
<li><code><a title="bathysphere.models.Assets.name" href="#bathysphere.models.Assets.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.models.Collections" href="#bathysphere.models.Collections">Collections</a></code></h4>
<ul class="two-column">
<li><code><a title="bathysphere.models.Collections.description" href="#bathysphere.models.Collections.description">description</a></code></li>
<li><code><a title="bathysphere.models.Collections.extent" href="#bathysphere.models.Collections.extent">extent</a></code></li>
<li><code><a title="bathysphere.models.Collections.keywords" href="#bathysphere.models.Collections.keywords">keywords</a></code></li>
<li><code><a title="bathysphere.models.Collections.license" href="#bathysphere.models.Collections.license">license</a></code></li>
<li><code><a title="bathysphere.models.Collections.name" href="#bathysphere.models.Collections.name">name</a></code></li>
<li><code><a title="bathysphere.models.Collections.version" href="#bathysphere.models.Collections.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.models.DataStreams" href="#bathysphere.models.DataStreams">DataStreams</a></code></h4>
<ul class="">
<li><code><a title="bathysphere.models.DataStreams.description" href="#bathysphere.models.DataStreams.description">description</a></code></li>
<li><code><a title="bathysphere.models.DataStreams.fourierTransform" href="#bathysphere.models.DataStreams.fourierTransform">fourierTransform</a></code></li>
<li><code><a title="bathysphere.models.DataStreams.frequencySpectrum" href="#bathysphere.models.DataStreams.frequencySpectrum">frequencySpectrum</a></code></li>
<li><code><a title="bathysphere.models.DataStreams.name" href="#bathysphere.models.DataStreams.name">name</a></code></li>
<li><code><a title="bathysphere.models.DataStreams.observedArea" href="#bathysphere.models.DataStreams.observedArea">observedArea</a></code></li>
<li><code><a title="bathysphere.models.DataStreams.outOfRangeMask" href="#bathysphere.models.DataStreams.outOfRangeMask">outOfRangeMask</a></code></li>
<li><code><a title="bathysphere.models.DataStreams.partition" href="#bathysphere.models.DataStreams.partition">partition</a></code></li>
<li><code><a title="bathysphere.models.DataStreams.phenomenonTime" href="#bathysphere.models.DataStreams.phenomenonTime">phenomenonTime</a></code></li>
<li><code><a title="bathysphere.models.DataStreams.resampleSparseSeries" href="#bathysphere.models.DataStreams.resampleSparseSeries">resampleSparseSeries</a></code></li>
<li><code><a title="bathysphere.models.DataStreams.resultTime" href="#bathysphere.models.DataStreams.resultTime">resultTime</a></code></li>
<li><code><a title="bathysphere.models.DataStreams.smoothUsingConvolution" href="#bathysphere.models.DataStreams.smoothUsingConvolution">smoothUsingConvolution</a></code></li>
<li><code><a title="bathysphere.models.DataStreams.statisticalOutlierMask" href="#bathysphere.models.DataStreams.statisticalOutlierMask">statisticalOutlierMask</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.models.FeaturesOfInterest" href="#bathysphere.models.FeaturesOfInterest">FeaturesOfInterest</a></code></h4>
<ul class="">
<li><code><a title="bathysphere.models.FeaturesOfInterest.description" href="#bathysphere.models.FeaturesOfInterest.description">description</a></code></li>
<li><code><a title="bathysphere.models.FeaturesOfInterest.encodingType" href="#bathysphere.models.FeaturesOfInterest.encodingType">encodingType</a></code></li>
<li><code><a title="bathysphere.models.FeaturesOfInterest.feature" href="#bathysphere.models.FeaturesOfInterest.feature">feature</a></code></li>
<li><code><a title="bathysphere.models.FeaturesOfInterest.name" href="#bathysphere.models.FeaturesOfInterest.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.models.HistoricalLocations" href="#bathysphere.models.HistoricalLocations">HistoricalLocations</a></code></h4>
<ul class="">
<li><code><a title="bathysphere.models.HistoricalLocations.time" href="#bathysphere.models.HistoricalLocations.time">time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.models.Locations" href="#bathysphere.models.Locations">Locations</a></code></h4>
<ul class="">
<li><code><a title="bathysphere.models.Locations.description" href="#bathysphere.models.Locations.description">description</a></code></li>
<li><code><a title="bathysphere.models.Locations.encodingType" href="#bathysphere.models.Locations.encodingType">encodingType</a></code></li>
<li><code><a title="bathysphere.models.Locations.name" href="#bathysphere.models.Locations.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.models.Observations" href="#bathysphere.models.Observations">Observations</a></code></h4>
<ul class="two-column">
<li><code><a title="bathysphere.models.Observations.outOfRange" href="#bathysphere.models.Observations.outOfRange">outOfRange</a></code></li>
<li><code><a title="bathysphere.models.Observations.parameters" href="#bathysphere.models.Observations.parameters">parameters</a></code></li>
<li><code><a title="bathysphere.models.Observations.phenomenonTime" href="#bathysphere.models.Observations.phenomenonTime">phenomenonTime</a></code></li>
<li><code><a title="bathysphere.models.Observations.result" href="#bathysphere.models.Observations.result">result</a></code></li>
<li><code><a title="bathysphere.models.Observations.resultQuality" href="#bathysphere.models.Observations.resultQuality">resultQuality</a></code></li>
<li><code><a title="bathysphere.models.Observations.resultTime" href="#bathysphere.models.Observations.resultTime">resultTime</a></code></li>
<li><code><a title="bathysphere.models.Observations.validTime" href="#bathysphere.models.Observations.validTime">validTime</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.models.ObservedProperties" href="#bathysphere.models.ObservedProperties">ObservedProperties</a></code></h4>
<ul class="">
<li><code><a title="bathysphere.models.ObservedProperties.definition" href="#bathysphere.models.ObservedProperties.definition">definition</a></code></li>
<li><code><a title="bathysphere.models.ObservedProperties.description" href="#bathysphere.models.ObservedProperties.description">description</a></code></li>
<li><code><a title="bathysphere.models.ObservedProperties.name" href="#bathysphere.models.ObservedProperties.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.models.Providers" href="#bathysphere.models.Providers">Providers</a></code></h4>
<ul class="two-column">
<li><code><a title="bathysphere.models.Providers.apiKey" href="#bathysphere.models.Providers.apiKey">apiKey</a></code></li>
<li><code><a title="bathysphere.models.Providers.description" href="#bathysphere.models.Providers.description">description</a></code></li>
<li><code><a title="bathysphere.models.Providers.domain" href="#bathysphere.models.Providers.domain">domain</a></code></li>
<li><code><a title="bathysphere.models.Providers.name" href="#bathysphere.models.Providers.name">name</a></code></li>
<li><code><a title="bathysphere.models.Providers.secretKey" href="#bathysphere.models.Providers.secretKey">secretKey</a></code></li>
<li><code><a title="bathysphere.models.Providers.tokenDuration" href="#bathysphere.models.Providers.tokenDuration">tokenDuration</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.models.Sensors" href="#bathysphere.models.Sensors">Sensors</a></code></h4>
<ul class="">
<li><code><a title="bathysphere.models.Sensors.description" href="#bathysphere.models.Sensors.description">description</a></code></li>
<li><code><a title="bathysphere.models.Sensors.encodingType" href="#bathysphere.models.Sensors.encodingType">encodingType</a></code></li>
<li><code><a title="bathysphere.models.Sensors.metadata" href="#bathysphere.models.Sensors.metadata">metadata</a></code></li>
<li><code><a title="bathysphere.models.Sensors.name" href="#bathysphere.models.Sensors.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.models.Simulations" href="#bathysphere.models.Simulations">Simulations</a></code></h4>
<ul class="">
<li><code><a title="bathysphere.models.Simulations.batch" href="#bathysphere.models.Simulations.batch">batch</a></code></li>
<li><code><a title="bathysphere.models.Simulations.job" href="#bathysphere.models.Simulations.job">job</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.models.TaskingCapabilities" href="#bathysphere.models.TaskingCapabilities">TaskingCapabilities</a></code></h4>
<ul class="">
<li><code><a title="bathysphere.models.TaskingCapabilities.creationTime" href="#bathysphere.models.TaskingCapabilities.creationTime">creationTime</a></code></li>
<li><code><a title="bathysphere.models.TaskingCapabilities.description" href="#bathysphere.models.TaskingCapabilities.description">description</a></code></li>
<li><code><a title="bathysphere.models.TaskingCapabilities.name" href="#bathysphere.models.TaskingCapabilities.name">name</a></code></li>
<li><code><a title="bathysphere.models.TaskingCapabilities.taskingParameters" href="#bathysphere.models.TaskingCapabilities.taskingParameters">taskingParameters</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.models.Tasks" href="#bathysphere.models.Tasks">Tasks</a></code></h4>
<ul class="">
<li><code><a title="bathysphere.models.Tasks.creationTime" href="#bathysphere.models.Tasks.creationTime">creationTime</a></code></li>
<li><code><a title="bathysphere.models.Tasks.taskingParameters" href="#bathysphere.models.Tasks.taskingParameters">taskingParameters</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.models.Things" href="#bathysphere.models.Things">Things</a></code></h4>
<ul class="">
<li><code><a title="bathysphere.models.Things.description" href="#bathysphere.models.Things.description">description</a></code></li>
<li><code><a title="bathysphere.models.Things.name" href="#bathysphere.models.Things.name">name</a></code></li>
<li><code><a title="bathysphere.models.Things.properties" href="#bathysphere.models.Things.properties">properties</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.models.User" href="#bathysphere.models.User">User</a></code></h4>
<ul class="two-column">
<li><code><a title="bathysphere.models.User.alias" href="#bathysphere.models.User.alias">alias</a></code></li>
<li><code><a title="bathysphere.models.User.credential" href="#bathysphere.models.User.credential">credential</a></code></li>
<li><code><a title="bathysphere.models.User.description" href="#bathysphere.models.User.description">description</a></code></li>
<li><code><a title="bathysphere.models.User.ip" href="#bathysphere.models.User.ip">ip</a></code></li>
<li><code><a title="bathysphere.models.User.name" href="#bathysphere.models.User.name">name</a></code></li>
<li><code><a title="bathysphere.models.User.validated" href="#bathysphere.models.User.validated">validated</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>bathysphere.utils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bathysphere.utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># pylint: disable=invalid-name
from datetime import datetime, date
from collections import deque
from multiprocessing import Pool
from itertools import repeat
from decimal import Decimal
from typing import Coroutine, Any
from asyncio import new_event_loop, set_event_loop, BaseEventLoop
from json import dumps

from os import getenv
from warnings import simplefilter, warn, catch_warnings
from functools import reduce
from logging import getLogger
from time import sleep

import operator
import pathlib

from requests import get
from yaml import Loader, load as load_yml
from google.cloud import secretmanager
from google.auth.exceptions import DefaultCredentialsError


from numpy import (
    abs,
    append,
    arange,
    arccos,
    argsort,
    array,
    array_split,
    asarray,
    ceil,
    cos,
    cross,
    dot,
    diff,
    empty_like,
    floor,
    hstack,
    intersect1d,
    isnan,
    log,
    mean,
    ma,
    max,
    min,
    NaN,
    ones,
    pi,
    random,
    repeat,
    roll,
    sin,
    stack,
    std,
    sum,
    uint8,
    unique,
    where,
    zeros,
)


from numpy.linalg import norm
from numpy.ma import MaskedArray

from scipy.interpolate import NearestNDInterpolator
from scipy.stats import linregress
from scipy import ndimage

from shapefile import Reader
from netCDF4 import Dataset  # pylint: disable=no-name-in-module
from PIL.Image import Image, fromarray
from pyproj import Proj, transform

from matplotlib.cm import get_cmap
from matplotlib.patches import Path
from matplotlib.tri import CubicTriInterpolator, LinearTriInterpolator

from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

try:
    # pylint: disable=import-error
    import arrayfire as af
except:
    af = None
    gpu = False


CartesianNAD83 = Proj(&#34;epsg:2960&#34;)
SphericalWGS84 = Proj(&#34;epsg:4326&#34;)


log = getLogger(__name__)
try:
    client = secretmanager.SecretManagerServiceClient()
except DefaultCredentialsError as ex:
    warn(&#34;Could not locate cloud provider credentials. Assets are temporary.&#34;)


def loadAppConfig(sources: (str) = (&#34;bathysphere.yml&#34;, &#34;kubernetes.yml&#34;)) -&gt; dict:
    &#34;&#34;&#34;
    Load known entities and services at initialization.
    &#34;&#34;&#34;

    def renderConfig(x: str):
        &#34;&#34;&#34;
        Open the local config directory and process entries into dict structures
        &#34;&#34;&#34;
        with open(pathlib.Path(f&#34;config/{x}&#34;), &#34;r&#34;) as fid:
            items = fid.read().split(&#34;---&#34;)
        return list(map(load_yml, items, repeat(Loader, len(items))))

    def reverseDictionary(a: dict, b: dict) -&gt; dict:
        &#34;&#34;&#34;
        Flip the nestedness of the dict from a list to have top level keys for each `kind`
        &#34;&#34;&#34;
        if not isinstance(a, dict):
            raise ValueError(
                &#34;Expected dictionary values. Type is instead {}.&#34;.format(type(a))
            )

        if b is not None:
            key = b.pop(&#34;kind&#34;)
            if key not in a.keys():
                a[key] = [b]
            else:
                a[key].append(b)
        return a

    items = reduce(operator.add, map(renderConfig, sources), [])
    return reduce(reverseDictionary, items, {})


def googleCloudSecret(secret_name=&#34;my-secret&#34;):
    # type: (str) -&gt; str
    project_id = getenv(&#34;GCP_PROJECT&#34;)  # Google Compute default param
    resource_name = f&#34;projects/{project_id}/secrets/{secret_name}/versions/latest&#34;
    try:
        response = client.access_secret_version(resource_name)
    except NameError as _:
        return None
    return response.payload.data.decode(&#34;UTF-8&#34;)


def generateStream(columns, records):
    &#34;&#34;&#34;
    Send database records as a stream of JSON text
    &#34;&#34;&#34;
    try:
        prev = next(records)  # get first result
    except:
        yield &#34;[]&#34;
        raise StopIteration
    yield &#34;[&#34;
    # Iterate over the releases
    for r in records:
        yield dumps(dict(zip(columns, r))) + &#34;, &#34;
        prev = r
    # Now yield the last iteration without comma but with the closing brackets
    yield dumps(dict(zip(columns, prev))) + &#34;]&#34;


def synchronous(task, loop=None, close=False):
    # type: (Coroutine, BaseEventLoop, bool) -&gt; Any
    &#34;&#34;&#34;
    Run an asynchronous tasks in serial. First build JSON structures with Co-routines in place of data,
    and then render the result of the Co-routines in-place.
    &#34;&#34;&#34;
    if loop is None:
        close = True
        loop = new_event_loop()
    set_event_loop(loop)  # create the event loop
    result = loop.run_until_complete(task)
    if close:
        loop.close()
    return result


def resolveTaskTree(t) -&gt; tuple:
    &#34;&#34;&#34;
    Recursively run and REDUCE an asynchronous task tree which returns an (index, &lt;coroutine&gt;) tuple. The process
    stops when the final inner method is evaluated.

    This is used internally by `metadata()`. The depth of the task structure is set before runtime, for example,
    see `_map_by_date`.
    &#34;&#34;&#34;

    i, inner = synchronous(t)
    if inner is None:
        return (i,)
    yields = ()
    while len(inner):
        yields += tuple(
            [i, *((j,) if type(j) == int else tuple(j))]
            for j in resolveTaskTree(inner.pop())
        )
    return yields


def _parse_str_to_float(string):
    # type: (str) -&gt; float
    try:
        if &#34;K&#34; in string:
            return float(string.replace(&#34;K&#34;, &#34;&#34;))
        else:
            return float(string) / 1000
    except TypeError:
        return -1


def interp1d(coefficient, aa, bb):
    &#34;&#34;&#34;
    Simple linear interpolation in one dimension
    &#34;&#34;&#34;
    return (1.0 - coefficient) * aa + coefficient * bb


def response(status, payload):
    return {
        &#34;status&#34;: status,
        &#34;payload&#34;: list(payload),
    }


def parsePostgresValueIn(value: Any) -&gt; str:
    &#34;&#34;&#34;Convert python to sql values&#34;&#34;&#34;
    parsingTable = {
        datetime: lambda x: x.isoformat(),
        float: lambda x: str(x),
        int: lambda x: f&#34;{x}.0&#34;,
        str: lambda x: f&#34;&#39;{x}&#39;&#34;,
        dict: lambda x: f&#34;ST_GeomFromGeoJSON(&#39;{dumps(x)}&#39;)&#34;,
    }
    return parsingTable.get(type(value), lambda x: &#34;NULL&#34;)(value)


def parsePostgresValueOut(v: Any) -&gt; Any:
    &#34;&#34;&#34;Convert sql driver output to python&#34;&#34;&#34;
    if isinstance(v, Decimal):
        return float(v)
    return v


def join(x: str) -&gt; str:
    &#34;&#34;&#34;Convenience method for mapping query formatting when whitespace is needed&#34;&#34;&#34;
    return &#34;, &#34;.join(x)


def report_buoy_data(request):
    &#34;&#34;&#34;We receive the hashed message in form of a header&#34;&#34;&#34;

    if getenv(&#34;Http_Method&#34;) != &#34;POST&#34;:
        return dumps({&#34;Error&#34;: &#34;Require POST&#34;}), 400
    if not request.body:
        return dumps({&#34;Error&#34;: &#34;No request body&#34;}), 400

    body = request.body

    interval = body.get(&#34;interval&#34;, (None, None))
    limit = body.get(&#34;limit&#34;, None)
    encoding = body.get(&#34;encoding&#34;, &#34;txt&#34;)
    node = body.get(&#34;id&#34;, None)
    fields = body.get(&#34;observedProperties&#34;, None)

    if (
        not any((limit, *interval))
        or not any((fields, node))
        or encoding not in (&#34;txt&#34;, &#34;json&#34;)
    ):
        return dumps({&#34;Error&#34;: &#34;Bad Request&#34;}), 400

    host = getenv(&#34;hostname&#34;, &#34;maine.loboviz.com&#34;)
    times = (
        f&#34;&amp;newest={limit}&#34; if limit else &#34;&amp;min_date={}&amp;max_date={}&#34;.format(*interval)
    )
    url = f&#34;http://{host}/cgi-data/nph-data.cgi?data_format=text&amp;node={node}&amp;y={&#39;,&#39;.join(fields)}{times}&#34;
    response = get(url)
    content = response.content.decode()
    if not response.ok:
        return response

    if encoding == &#34;txt&#34;:
        return content, 200

    lines = deque(filter(lambda x: len(x), content.split(&#34;\n&#34;)))
    name, alias = lines.popleft().split(&#34;-&#34;)
    data = {
        &#34;name&#34;: name,
        &#34;aliases&#34;: list(set(map(str.strip, (alias, lines.popleft())))),
    }
    lines = deque(map(lambda x: tuple(x.split(&#34;\t&#34;)), lines))
    keys = lines.popleft()
    return (
        dumps(
            {
                **data,
                &#34;values&#34;: [
                    dict(zip(k, v)) for k, v in zip(repeat(keys, len(lines)), lines)
                ],
            }
        ),
        200,
    )


def days(date):
    &#34;&#34;&#34;Convert a single datetime to a Julian day number&#34;&#34;&#34;
    delta = date - datetime(date.year, 1, 1, 0, 0, 0)
    result = delta.total_seconds() / 24 / 60 / 60
    return result


def image_to_masked(image: array, m: float = 0.125, b: float = 2.0, hide: bool = True):
    &#34;&#34;&#34;
    Calculate value from greyscale color

    :param image: color value of bathysphere_functions_image
    :param m: slope
    :param b: offset
    :param hide: sometimes there are things like color map bars and shit
    :return: sea surface temperature bathysphere_functions_image
    &#34;&#34;&#34;

    sst = m * image - b
    if hide:
        a, b, c, d = 250, 700, 1, 75
        sst[a:b, c:d] = NaN  # mask color bar
    return sst


def image2arrays(
    path, utm_extent, native=Proj(init=&#34;epsg:2960&#34;), view=Proj(init=&#34;epsg:4326&#34;)
):
    # type: (str, list, Proj, Proj) -&gt; (Array, Array, Array)
    &#34;&#34;&#34;
    Load landsat image and convert to arrays for processing.

    Including the Projection definitions should memoize the defaults between calls
    run in the same context.
    &#34;&#34;&#34;
    fid = open(path, &#34;r&#34;)
    image = Image()
    image.frombytes(data=fid.read())  # read image file
    px = repeat(arange(image.width).reshape(1, image.width), image.height, axis=0)
    py = repeat(arange(image.height).reshape(image.height, 1), image.width, axis=1)

    utm = pix2utm(px, py, utm_extent)
    return (*project(*utm, native=native, view=view), asarray(image))


def array2image(z, cmap):
    # type: (Array, str) -&gt; Image
    &#34;&#34;&#34;
    Create bathysphere_functions_image object in memory
    &#34;&#34;&#34;
    return fromarray(uint8(get_cmap(cmap)(z) * 255)).rotate(90)


def arrays2points(x, y, z=None, dilate=0):
    # type: (Array, Array, Array, int) -&gt; Array
    &#34;&#34;&#34;
    Extract all unmasked pixels as an array of (x,y) points, and an array of (z) values.
    Optionally dilate the mask by some number of pixels.
    &#34;&#34;&#34;
    if z is None:
        return stack((x.reshape(-1, 1), y.reshape(-1, 1)), axis=1)
    if isinstance(dilate, int) and dilate &gt; 0:
        z.mask = ndimage.binary_dilation(ndimage.binary_dilation(z.mask))
    if isinstance(z.mask, bool or None):
        columns = (x.reshape(-1, 1), y.reshape(-1, 1), z.reshape(-1, 1))
    else:
        indices = where(~z.mask.reshape(-1, 1))
        columns = (
            x.reshape(-1, 1)[indices],
            y.reshape(-1, 1)[indices],
            z.reshape(-1, 1)[indices],
        )
    return stack(columns, axis=1)


def normal(u):
    # type: (Array) -&gt; Array
    &#34;&#34;&#34;Normalize array of vectors&#34;&#34;&#34;
    return u / norm(u, axis=1).reshape((-1, 1))


def identity():
    # type: () -&gt; Array
    &#34;&#34;&#34;identity matrix&#34;&#34;&#34;
    matrix = zeros((4, 4))
    for ii in range(4):
        matrix[ii, ii] = 1.0
    return matrix


def multiply(u, v):
    # type: (Array, Array) -&gt; Array
    &#34;&#34;&#34;
    Quaternion matrix multiplication for one or more vertices

    A*B - dotProduct(u,v)
    cross(u,v) + A*v + B*u
    &#34;&#34;&#34;
    ur, _ = u.shape
    vr, _ = v.shape
    rows = max([ur, vr])
    result = zeros((rows, 4), dtype=float)

    result[:, 0] = (
        u[:, 0] * v[:, 0] - u[:, 1] * v[:, 1] - u[:, 2] * v[:, 2] - u[:, 3] * v[:, 3]
    )
    result[:, 1] = (
        u[:, 2] * v[:, 3] - u[:, 3] * v[:, 2] + u[:, 0] * v[:, 1] + v[:, 0] * u[:, 1]
    )
    result[:, 2] = (
        u[:, 3] * v[:, 1] - u[:, 1] * v[:, 3] + u[:, 0] * v[:, 2] + v[:, 0] * u[:, 2]
    )
    result[:, 3] = (
        u[:, 1] * v[:, 2] - u[:, 2] * v[:, 1] + u[:, 0] * v[:, 3] + v[:, 0] * u[:, 3]
    )
    return result


def rotate(vertex_array: array, angle: float, axis: array) -&gt; array:
    &#34;&#34;&#34;
    Rotate list of vectors(/vertices) about any axis by angle in radians. Default to Z-AXIS
    &#34;&#34;&#34;
    a = cos(0.5 * angle)
    b = sin(0.5 * angle) * normal(axis)

    if vertex_array.shape[1] == 4:
        state = vertex_array
    else:
        state = zeros((len(vertex_array), 4), dtype=float)
        state[:, 1:4] = vertex_array[:, :]

    matrix = append(a, b).reshape(1, 4)
    state = multiply(matrix, state)  # intermediate multiplication
    matrix = append(a, -b).reshape(1, 4)  # conjugation
    return multiply(state, matrix)[:, 1:4]  # final step, omit w coordinates


def geo2dist(lat1, long1, lat2, long2):
    # type: (Array or float, Array or float, float, float) -&gt; (Array or float)
    &#34;&#34;&#34;
    Calculate distance on unit sphere and scale up
    &#34;&#34;&#34;
    degrees_to_radians = pi / 180.0
    phi1 = (90.0 - lat1) * degrees_to_radians
    phi2 = (90.0 - lat2) * degrees_to_radians
    theta1 = long1 * degrees_to_radians
    theta2 = long2 * degrees_to_radians
    cosine = sin(phi1) * sin(phi2) * cos(theta1 - theta2) + cos(phi1) * cos(phi2)
    arc = arccos(cosine)
    return arc * 6373000


def extent_overlap_filter(ext, shapes, extents, rec=None):
    # type: (ExtentType, (Array,), (ExtentType,), (dict,)) -&gt; ((Array,), (ExtentType,))
    &#34;&#34;&#34;

    :param ext: data extent
    :param shapes: shapes are passed through
    :param extents: extents to compare
    :param rec: records are passed through
    &#34;&#34;&#34;
    iterator = zip(*((shapes, extents, rec) if rec else (shapes, extents)))
    return tuple(zip(*filter(lambda x: extent_overlap(ext, x[1]), iterator)))


def extent_crop(ext, xyz):
    # type: (ExtentType, Array) -&gt; Array
    &#34;&#34;&#34;Return only the pixels inside the cropping extent&#34;&#34;&#34;
    if xyz.shape[1] &gt; 3:
        a, b = 1, 2
    else:
        a, b = 0, 1
    mask = crop(xyz[:, a], xyz[:, b], ext)
    select = where(~mask)[0]
    return xyz[select, :]


def extent_overlap_iteration(vertex_array, shapes, extents, records=None):
    # type: (Array, (Array, ), (ExtentType, ), (dict, )) -&gt; (Array, (tuple, ))
    &#34;&#34;&#34;Find overlapping extents, and return only pixels inside their bounding extent&#34;&#34;&#34;
    data_ext = extent(*vertex_array)
    filtered = extent_overlap_filter(data_ext, shapes, extents, rec=records)
    cropped = extent_crop(reduce(reduce_extent, filtered[1]), vertex_array)
    return (cropped, *filtered)


def extent_overlap_automatic(xyz, shapes, extents, max_passes=3, rec=None):
    # type: (Array, (Array,), (ExtentType,), int, (dict, )) -&gt; (Array, (Path,))
    &#34;&#34;&#34;
    Use with sparse rasters. Get overall extent, and find shapes with overlapping extent.
    Reduce these to a single extent, and remove xyz values not within that union.
    Repeat until extent stops changing.
    &#34;&#34;&#34;
    warn(
        &#34;Recursive extent culling is unstable. Use looped `extent_overlap_iteration`&#34;,
        DeprecationWarning,
    )

    previous, current = None, extent(xyz[:, 0], xyz[:, 1])
    dat = extent_overlap_filter(current, shapes, extents, rec=rec)
    if rec:
        f, e, r = dat
    else:
        f, e = dat
        r = None

    passes = 0

    while previous != current and passes &lt; max_passes:

        xyz = extent_crop(reduce(reduce_extent, e), xyz)
        previous, current = current, extent(xyz[:, 0], xyz[:, 1])
        dat = extent_overlap_filter(current, f, e, rec=r)
        if rec:
            f, e, r = dat
        else:
            f, e = dat
            r = None

        passes += 1

    return xyz, f, e, r



def hull_overlap(a, b):
    # type: (Array or Path, Array or Path) -&gt; bool
    &#34;&#34;&#34;Two convex hulls overlap&#34;&#34;&#34;
    _a, _b = tuple((x if isinstance(x, Path) else Path(x) for x in (a, b)))
    _av, _bv = tuple((x.vertices if isinstance(x, Path) else x for x in (a, b)))
    return _a.contains_points(_bv).any() or _b.contains_points(_av).any()


def hull_contains(a, b):
    # type: (Path or Array, Path or Array) -&gt; bool
    &#34;&#34;&#34;First convex hull contains second&#34;&#34;&#34;
    _a, _b = tuple((x if isinstance(x, Path) else Path(x) for x in (a, b)))
    return _a.contains_path(_b)


def partition_points_by_shape(path, vertex_array):
    # type: (Path, Array) -&gt; (Array, Array)
    &#34;&#34;&#34;&#34;Split vertex array into points inside and outside of shape&#34;&#34;&#34;
    cols = vertex_array.shape[1]
    if cols == 2:
        xy = vertex_array
    elif cols == 3:
        xy = vertex_array[:2]
    else:
        xy = vertex_array[1:3]

    mask = points_in_path(path, xy)
    _subset = where(mask)[0]
    inside = vertex_array[_subset, :]
    _subset = where(~mask)[0]  # pylint: disable=invalid-unary-operand-type
    outside = vertex_array[_subset, :]
    return inside, outside


def _points_in_path(p, vertex_array):
    # type: ((Path, ), Array) -&gt; Array
    &#34;&#34;&#34;Mask of points inside the Path, used for map parallelism&#34;&#34;&#34;
    return p[0].contains_points(vertex_array)


def points_in_path(path, vertex_array, max_size=10000, processes=1, pool=None):
    # type: (Path, Array, int, int, Pool) -&gt; (Array, Array)
    &#34;&#34;&#34;Break up point stream into chunks by intersecting with polygon collection&#34;&#34;&#34;
    if pool is None:
        pool = Pool(processes=processes)
    sections = len(vertex_array) // max_size + 1
    iterable = zip(
        repeat((path,), sections), array_split(vertex_array, sections, axis=0)
    )
    return hstack(pool.starmap(_points_in_path, iterable))


def multi_polygon_crop(xyz, shapes):
    &#34;&#34;&#34;
    Retain points inside the shapes, along with the shape index that they belong to.

    WARNING: In-place memory operation.
    &#34;&#34;&#34;
    found = []
    for i, s in enumerate(shapes):
        p = Path(s)
        ins, xyz = partition_points_by_shape(p, xyz)
        found.append((ins, i))
        if len(xyz) == 0:
            break
    return hstack(found)


def multi_polygon_cull(xyz, shapes):
    &#34;&#34;&#34;
    Retain only points which are not in any polygon.

    WARNING: In-place memory operation.
    &#34;&#34;&#34;
    for s in shapes:
        p = Path(s)
        _, xyz = partition_points_by_shape(p, xyz)
        if len(xyz) == 0:
            break
    return xyz


def filter_in_range(mask, data, minimum=None, maximum=None, gpu=False):
    # type: (Array, Array, float, float, bool) -&gt; Array
    &#34;&#34;&#34;Mask if outside interval&#34;&#34;&#34;
    if minimum is not None:
        mask |= af.np_to_af_array(data &lt; minimum) if gpu else data &lt; minimum
    if maximum is not None:
        mask |= af.np_to_af_array(data &gt; maximum) if gpu else data &gt; maximum
    return mask


def filter_arrays(x) -&gt; bool:
    &#34;&#34;&#34;Process an iterable of Array-likes to remove null values, used in map parallelism&#34;&#34;&#34;
    try:
        return isinstance(x.shape, tuple)
    except AttributeError:
        return False


def crop(x, y, ext, mask=None, gpu=False):
    # type: (Array, Array, list or tuple, Array, bool) -&gt; Array
    &#34;&#34;&#34;Mask positions outside the given extent&#34;&#34;&#34;
    assert x.shape == y.shape
    if mask is None:
        mask = blank(x.shape)

    mask |= af.np_to_af_array(x &lt; ext[0]) if gpu else x &lt; ext[0]
    mask |= af.np_to_af_array(x &gt; ext[1]) if gpu else x &gt; ext[1]
    mask |= af.np_to_af_array(y &lt; ext[2]) if gpu else y &lt; ext[2]
    mask |= af.np_to_af_array(y &gt; ext[3]) if gpu else y &gt; ext[3]
    return mask


def nan_mask(arr, gpu=False):
    # type: (Array, bool) -&gt; Array
    &#34;&#34;&#34;Reset mask&#34;&#34;&#34;
    if gpu:
        return af.isnan(arr)
    mask = isnan(arr)
    if isinstance(mask, MaskedArray):
        return mask.data
    return mask


def blank(shape, gpu=False, fill=False):
    # type: (tuple, bool, bool) -&gt; Array
    &#34;&#34;&#34;
    Create mask in shape of data, optionally using GPU
    &#34;&#34;&#34;
    template = (ones if fill else zeros)(shape, dtype=bool)
    if gpu:
        return af.Array(src=template.ctypes.data, dims=template.shape, dtype=&#34;b&#34;)
    else:
        return template


def pix2utm(px, py, ext):
    # type: (Array, Array, list) -&gt; (Array, Array)
    &#34;&#34;&#34;
    Convert from pixel indices to UTM coordinates. Technically also works with lon/lat.
    &#34;&#34;&#34;
    utmx = px / max(px) * (ext[2] - ext[0]) + ext[0]
    utmy = py / max(py) * (ext[3] - ext[1]) + ext[1]
    return utmx, utmy


def project(xx, yy, native, view):
    # type: (Array, Array, Proj, Proj) -&gt; (Array, Array)
    &#34;&#34;&#34;Re-project coordinates to/from spherical or cartesian&#34;&#34;&#34;
    assert xx.shape == yy.shape
    xo, yo = transform(native, view, xx.flatten(order=&#34;F&#34;), yy.flatten(order=&#34;F&#34;))
    return xo.reshape(xx.shape), yo.reshape(yy.shape)


def interp1d_lin(x, y, samples, clamp=False):
    # type: ((Array, Array), (Array, Array), Array, bool) -&gt; Array
    &#34;&#34;&#34;Simple linear interpolation, requires pre-calculated coefficients for points&#34;&#34;&#34;
    predicted = (y[1] - y[0]) / (x[1] - x[0]) * (samples - x[0]) + y[0]
    if clamp:
        i = where(x &lt; x[0])
        j = where(x &gt; x[1])
        predicted[i] = y[0]
        predicted[j] = y[1]
    return predicted


def interp2d_tri(xy, z, cubic=False, **kwargs):
    # type: (Array, Array, bool, dict) -&gt; Array
    &#34;&#34;&#34; interpolate 2D field on triangular grid &#34;&#34;&#34;
    engine = (CubicTriInterpolator if cubic else LinearTriInterpolator)(z, **kwargs)
    return engine(xy[:, 0], xy[:, 1])


def interp2d_uv(cells, train, neighbors, layer, shape_coefficient):
    # type: (Array, (Array,), Array, int, Array) -&gt; Array
    &#34;&#34;&#34;
    Interpolate

    :param cells:
    :param neighbors: pre-computed adjacency
    :param train: sample points
    :param layer:
    :param shape_coefficient: pre-computing shape coefficients for static meshes
    &#34;&#34;&#34;
    x, y, e = train
    expected = zeros((len(x), 3), dtype=float)

    for index in unique(cells):
        children = where((cells == index))
        s = shape_coefficient[index, :, :]

        for each in children:
            dx = x[each] - x[index]
            dy = y[each] - y[index]
            indices = append(neighbors[index], index)  # self and neighbors

            for dim in range(3):
                e_i = e[indices, layer, dim]
                expected[each, dim] = e[index, layer, dim] + (s * e_i) * array([dx, dy])
            continue

    return expected


def interp2d_nearest(xy, samples):
    # type: (Array, Array) -&gt; Array
    &#34;&#34;&#34;
    Load low-resolution data (e.g. AVHRR) and interpolate it to pixels of higher-resolution imagery
    (e.g. Landsat) using nearest neighbors. Uses nearest neighbor indexing and search with kd-trees
    from `scipy.spatial`

    - setting `rescale=True` will normalize all dimensions to 0-1
    - `tree_options` allows you to configure the kd-tree
    &#34;&#34;&#34;
    interp = NearestNDInterpolator(xy[:, 0], xy[:, 1], rescale=False, tree_options=None)
    return interp(samples)


def interp3d_tri(xy, z, scalar, layer, cubic=False, clamp=True, **kwargs):
    # type: (Array, Array, Array, int, bool, bool, dict) -&gt; Array
    &#34;&#34;&#34; Interpolate 3D field on triangular grid &#34;&#34;&#34;
    above = interp2d_tri(xy, z=scalar[:, layer], cubic=cubic, **kwargs)
    below = interp2d_tri(xy, z=scalar[:, layer + 1], cubic=cubic, **kwargs)
    return interp1d_lin(
        x=tuple(i for i in z[layer : layer + 2]),
        y=(above, below),
        samples=z,
        clamp=clamp,
    )


def interp3d_slice(z, scalar, layer, clamp=True):
    # type: (Array, Array, int, bool) -&gt; Array
    &#34;&#34;&#34;
    Depth-based interpolation

    :param z: sample depths
    :param scalar: the scalar field
    :param layer: vertical layer in triangular mesh
    :param clamp: values outside the interpolation range are fixed at end member values
    :return: values at sample points
    &#34;&#34;&#34;
    above = scalar[:, layer]
    below = scalar[:, layer + 1]
    return interp1d_lin(
        x=tuple(i for i in z[layer : layer + 2]),
        y=(above, below),
        samples=z,
        clamp=clamp,
    )


def subset(arr, stride):
    # type: (Array, int) -&gt; Array
    &#34;&#34;&#34;Regular-spaced sparse subset of an array&#34;&#34;&#34;
    return arr[1:-1:stride, 1:-1:stride]


def pixel_area(arr, resolution, gpu=False):
    # type: (Array, float, bool) -&gt; Array or None
    &#34;&#34;&#34;Calculate pixel area assuming fixed resolution, may be in GPU memory&#34;&#34;&#34;
    if resolution is not None and arr.mask is not None:
        add = af.sum if gpu else sum
        return add(~arr.mask) * resolution * resolution
    return None


def polygon_area(arr):
    # type: (Array) -&gt; float
    &#34;&#34;&#34;Polygon area, may be negative depending on winding, but this is retaining for shape culling&#34;&#34;&#34;
    xx, yy = arr[:, :2].T
    return 0.5 * (dot(xx, roll(yy, 1)) - dot(yy, roll(xx, 1)))


def extent_area(ext):
    # type: (ExtentType) -&gt; float
    &#34;&#34;&#34;
    Area of a shape extent
    &#34;&#34;&#34;
    return (ext[1] - ext[0]) * (ext[3] - ext[2])


def area_sort(data, pool=None, processes=1, reverse=False):
    # type: (((Array, ),), Pool, int, bool) -&gt; (Array, )
    &#34;&#34;&#34;
    Sort by shape area or extent area.
    &#34;&#34;&#34;
    if pool is None:
        pool = Pool(processes)
    eval_shps = data[0]

    if isinstance(eval_shps[0], tuple) and len(eval_shps[0]) == 4:
        method = extent_area
    else:
        method = polygon_area

    areas = array(pool.starmap(method, ((s,) for s in eval_shps)))
    sorting = argsort(areas)
    if reverse:
        sorting = sorting[::-1]

    inverse = empty_like(sorting)
    inverse[sorting] = arange(sorting.size)
    return tuple(array(x)[sorting] for x in data + (areas,)) + (inverse,)


def center(arr):
    # type: (Array) -&gt; (float, float)
    &#34;&#34;&#34;
    Geometric center
    &#34;&#34;&#34;
    return tuple(mean(arr.data, axis=0))


def spherical_nearest_neighbor(lon, lat, reference):
    # type: (Array, Array, (float, float)) -&gt; (Array, Array)
    &#34;&#34;&#34;
    Calculate distance matrix and indices of closet points
    &#34;&#34;&#34;
    dxy = geo2dist(lat, lon, *reference)
    return dxy, dxy.argmin()


def linear_regression_train(train, target):
    # type: ((Array,), Array) -&gt; (LinearRegression, float)
    &#34;&#34;&#34;
    Train a linear regression model to fit the array data

    :param train: x-value
    :param target: y-value
    :return:
    &#34;&#34;&#34;
    model = LinearRegression()
    model.fit(train, target)
    auto_regress = model.predict(train)
    r_squared = r2_score(target, auto_regress)
    return model, r_squared


def linear_regression_predict(model, predict, order=1):
    # type: (LinearRegression, (Array,), int) -&gt; (Array, float)
    &#34;&#34;&#34;
    Use trained model to predict new values

    :param model:
    :param predict: x-values
    :param order: order of linear model terms (1 or 2)
    :return: y-values
    &#34;&#34;&#34;
    if not 0 &lt; order &lt; 3:
        raise ValueError
    if len(predict) == 2:
        x, y = predict
        z = None
    elif len(predict) == 3:
        x, y, z = predict
    else:
        raise ValueError

    expected = stack((x, y), axis=1)
    if order == 2:
        expected = stack((expected, x * y, x * x, y * y), axis=1)
    if z is not None:
        expected = stack((expected, z), axis=1)
    return model.predict(expected)


def raster2mesh(train, predict, order=1):
    # type: ((Array,), (Array,), int) -&gt; Array
    &#34;&#34;&#34;
    Interpolate 2D field to triangular mesh

    :param train: training points (raster)
    :param predict: prediction points (mesh)
    :param order: order of linear model terms (1 or 2)
    &#34;&#34;&#34;
    if not 0 &lt; order &lt; 3:
        raise ValueError
    if len(train) == 4:
        x, y, z, e = train
        mask = isnan(z) | isnan(e)
    elif len(train) == 3:
        z = None
        x, y, e = train
        mask = isnan(e)
    else:
        raise ValueError

    (ind,) = where(~mask)

    def extract_valid(arr):
        return arr[ind].reshape(-1, 1) if arr is not None else None

    train = (extract_valid(item) for item in (x, y, z, e))
    model, _ = linear_regression_train(train=train, target=e)
    return linear_regression_predict(model, predict=predict, order=order)



def rk4(fcn, y0, t0, dt):
    &#34;&#34;&#34;
    Simple 4th-order Runge-Kutta integration, non boundary checking
    &#34;&#34;&#34;
    k1 = fcn(t0, y0)
    k2 = fcn(t0 + 0.5 * dt, y0 + 0.5 * k1)
    k3 = fcn(t0 + 0.5 * dt, y0 + 0.5 * k2)
    k4 = fcn(t0 + dt, y0 + k3)

    return y0 + dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6


def lin_transform(u, a, b):
    &#34;&#34;&#34;Linear tranformation&#34;&#34;&#34;
    return u * (b - a) + a


def geom_shader(e):
    &#34;&#34;&#34;Emulate geometry shader, create points from single reference&#34;&#34;&#34;
    return array(
        (
            (lin_transform(random.uniform(), *e[:2]), e[2]),
            (e[1], lin_transform(random.uniform(), *e[2:4])),
            (lin_transform(random.uniform(), *e[:2]), e[3]),
            (e[0], lin_transform(random.uniform(), *e[2:4])),
        )
    )


def landsat_sst_regression(raw, lon, lat, roi, samples, outliers, nsub=10):
    # type: (Array, Array, Array, (Array,), tuple, tuple, int ) -&gt; Array or None
    &#34;&#34;&#34;
    Calculate SST by removing outliers
    &#34;&#34;&#34;
    def brightness_temperature(x, m=3.3420e-04, b=0.1, k1=774.89, k2=1321.08):
        # type: (Array, float, float, float, float) -&gt; Array
        &#34;&#34;&#34;Brightness temperature from Band 10 raw counts&#34;&#34;&#34;
        radiance = m * x + b
        return (k2 / log((k1 / radiance) + 1)) - 272.15

    # Load satellite data and subset it
    btemp = brightness_temperature(raw)
    subbt = subset(btemp, nsub)
    samples = interp2d_nearest((lon, lat, btemp), samples=samples)

    # Generate masks
    mask = crop(lon, lat, roi)
    mask = filter_in_range(mask, btemp, maximum=-10)  # mask clouds 124.6
    mask |= (
        (samples &lt; outliers[0]) | (samples &gt; outliers[1]) | (btemp &lt; min(subbt))
    )  # combine masks
    indices = where(~mask)  # get unmasked linear indices
    avhrr_filtered = samples[indices].reshape(-1, 1)  # extract unmasked AVHRR values
    ls_filtered = btemp[indices].reshape(-1, 1)  # extract

    # Regress Landsat and AVHRR
    fit = 0.0
    intercept = None
    slope = None

    while True:
        pairs = hstack((avhrr_filtered, ls_filtered))
        _slope, _intercept, r, _, _ = linregress(pairs)  # regress
        if (abs(r) - abs(fit)) &lt; 0.000001:  # if r-value is improving
            break

        slope = _slope
        intercept = _intercept
        fit = r
        gtruth = avhrr_filtered * _slope + _intercept  # &#34;true&#34; values
        residual = abs(ls_filtered - gtruth)  # difference between observations
        stdv = std(ls_filtered)  # landsat standard deviation
        keepers, _ = where(residual &lt; stdv)
        if len(keepers) == 0:
            break

        ls_filtered = ls_filtered[keepers]
        avhrr_filtered = avhrr_filtered[keepers]

    if not slope or not intercept:
        return None
    sst = (btemp - intercept) / slope  # full resolution version for output

    # if crop:  # sparse sub-sampling
    #     submask = subset(mask, nsub)
    #     subsst = subset(sst, nsub)
    #     sublat = subset(lat, nsub)
    #     sublon = subset(lon, nsub)

    return sst


def avhrr_sst(files, locations, processes=1, chunk=4, delay=1):
    # type: (dict, dict, int, int, int) -&gt; Array
    &#34;&#34;&#34;
    Get year time series of AVHRR temperature

    :param files: files to scrap
    :param locations: get nearest neighbors of these locations
    :param chunk: number to retrieve per batch
    :param delay: Ending (inclusive) datetime day
    :param processes: number of processes to use
    &#34;&#34;&#34;

    total = len(files)
    sst = {key: zeros(total, dtype=float) for key in locations.keys()}
    found = zeros(total, dtype=bool)
    indices = arange(total, dtype=int)

    iteration = 0
    while True:
        pool = Pool(processes)
        jobs = len(indices)
        batches = ceil(jobs / chunk)
        with catch_warnings():
            simplefilter(&#34;ignore&#34;)
            failures = 0
            for ii in range(batches):

                a = ii * chunk
                b = (ii + 1) * chunk
                new = indices[a:b] if b &lt; len(indices) else indices[a:]
                results = pool.map(Dataset.query, files[new])

                for jj in range(len(new)):
                    if results[jj] is not None:
                        _index = new[jj]
                        found[_index] = True
                        for key in results[jj].keys():
                            sst[key][_index] = results[jj][key]
                    else:
                        failures += 1

        (indices,) = where(~found)
        count = sum(found)

        try:
            assert count + failures == total
        except AssertionError:
            break
        if found.all():
            break
        iteration += 1
        sleep(delay)

    return sst





def _advection_terms(solid, open, x, y, AU, neighbors):
    &#34;&#34;&#34;Element terms for calculating advection&#34;&#34;&#34;
    mask = solid + open
    for element in where(~mask):  # for non-boundaries

        indices = neighbors[element]
        dx = x[indices] - x[element]  # distances to neighbor centers
        dy = y[indices] - y[element]
        dxdx = sum(dx ** 2)
        dxdy = sum(dx * dy)
        dydy = sum(dy ** 2)
        average = [sum(dx), sum(dy)]

        AU[element, 0, 0] = cross([dxdy, dydy], average)
        AU[element, 0, 1] = cross(average, [dxdx, dxdy])

        for index in range(3):
            center = [dx[index], dy[index]]
            AU[element, index, 0] = cross(center, [dxdx, dydy])
            AU[element, index, 1] = cross([dxdx, dxdx], center)

        positions = hstack((dx, dy))
        aa = positions[[0, 0, 1], :]
        bb = positions[[1, 2, 2], :]
        delta = sum(cross(aa, bb) ** 2)

        AU[element, :, :] /= delta


def depth(bathymetry: array, elevation: array = None, dry: float = 1e-7) -&gt; MaskedArray:
    &#34;&#34;&#34;
    Time-varying property, free surface height from water level, meters
    &#34;&#34;&#34;
    data = (
        bathymetry if elevation is None else bathymetry + elevation
    )  # water depth, meters
    return ma.masked_array(depth, mask=(data &gt; dry))  # depth threshold to consider dry


def xye(x, y, z):
    &#34;&#34;&#34;Return height-mapped vertex array&#34;&#34;&#34;
    return hstack((x.reshape(-1, 1), y.reshape(-1, 1), z.reshape(-1, 1)))


def mask(shape, masked=None):
    m = zeros(shape, dtype=bool)
    if masked is not None:
        m[masked] = True
    return m


def _reorder(
    node: int, parents: list, neighbors: list, topology: array, tri_neighbors, tri_solid
):
    &#34;&#34;&#34;Reorder elements around a node to clockwise&#34;&#34;&#34;
    parents = parents[node]  # triangle neighbors
    neighbors = neighbors[node]
    start = 0
    (ends,) = where(tri_solid[parents])
    for ii in ends:
        pid = parents[ii]
        pos, _, _ = where(node == topology[pid, :])
        bb = topology[pid, pos - 1]
        shared = intersect1d(parents, parents[bb])
        queue = intersect1d(tri_neighbors[pid], shared)

        if len(queue) &gt; 0:
            parents = roll(parents, -ii)
            neighbors[0] = topology[pid, pos - 2]
            start += 1
        else:
            neighbors[-1] = bb

    np = len(parents)
    if np &gt; 2:
        for ii in range(start, np - 1):
            pid = parents[ii]
            pos, _, _ = where(node == topology[pid, :])
            bb = topology[pid, pos - 1]
            shared = intersect1d(parents, parents[bb])

            while parents[ii + 1] not in shared:
                parents[ii + 1 :] = roll(parents[ii + 1 :], -1)

            neighbors[ii] = topology[pid, pos - 2]


def calc_areas(vertex_buffer: array, topology: array, parents: list, verb=True):
    &#34;&#34;&#34;
    Calculate triangle area and correct windings

    Use numpy cross product of 2 legs to calculate area.
    May be negative still, so correct windings in place
    &#34;&#34;&#34;
    vertex_positions = vertex_buffer[topology]
    x, y = vertex_positions

    dx = (x[:, 1] - x[:, 0]).reshape(-1, 1)
    dy = (y[:, 1] - y[:, 0]).reshape(-1, 1)
    aa = hstack((dx, dy))

    dx = (x[:, 2] - x[:, 0]).reshape(-1, 1)
    dy = (y[:, 2] - y[:, 0]).reshape(-1, 1)
    bb = hstack((dx, dy))

    area = 0.5 * cross(bb, aa)
    (indices,) = where(area &lt; 0)
    tri_area = abs(area), roll(topology[indices, 1:3], 1, axis=1)

    shape = len(vertex_buffer)
    area = zeros(shape, dtype=float)
    art2 = zeros(shape, dtype=float)
    for node in range(shape):  # for each control volume
        art2[node] = tri_area[parents[node]].sum()
        area[node] = art2[node] / 3

    return {&#34;parents&#34;: art2, &#34;triangles&#34;: tri_area, &#34;control volume&#34;: area}




def shapefile(path, gpu=False):
    # type: (str, bool) -&gt; (Array,)
    &#34;&#34;&#34;
    Get array of objects from Shapefile

    :param path:
    :param gpu:
    &#34;&#34;&#34;
    reader = Reader(path)
    fields = reader.fields[1:]  # remove deletion flag
    result = []
    for shape, record in reader.iterShapeRecords():
        assert len(fields) == len(record), (fields, record)
        meta = {key[0]: rec for key, rec in zip(fields, record)}
        vertices = array(shape.points)
        parts = array_split(vertices, shape.parts[1:])
        result.extend(zip(parts, repeat(meta, len(parts))))
    return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="bathysphere.utils.area_sort"><code class="name flex">
<span>def <span class="ident">area_sort</span></span>(<span>data, pool=None, processes=1, reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sort by shape area or extent area.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area_sort(data, pool=None, processes=1, reverse=False):
    # type: (((Array, ),), Pool, int, bool) -&gt; (Array, )
    &#34;&#34;&#34;
    Sort by shape area or extent area.
    &#34;&#34;&#34;
    if pool is None:
        pool = Pool(processes)
    eval_shps = data[0]

    if isinstance(eval_shps[0], tuple) and len(eval_shps[0]) == 4:
        method = extent_area
    else:
        method = polygon_area

    areas = array(pool.starmap(method, ((s,) for s in eval_shps)))
    sorting = argsort(areas)
    if reverse:
        sorting = sorting[::-1]

    inverse = empty_like(sorting)
    inverse[sorting] = arange(sorting.size)
    return tuple(array(x)[sorting] for x in data + (areas,)) + (inverse,)</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.array2image"><code class="name flex">
<span>def <span class="ident">array2image</span></span>(<span>z, cmap)</span>
</code></dt>
<dd>
<div class="desc"><p>Create bathysphere_functions_image object in memory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def array2image(z, cmap):
    # type: (Array, str) -&gt; Image
    &#34;&#34;&#34;
    Create bathysphere_functions_image object in memory
    &#34;&#34;&#34;
    return fromarray(uint8(get_cmap(cmap)(z) * 255)).rotate(90)</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.arrays2points"><code class="name flex">
<span>def <span class="ident">arrays2points</span></span>(<span>x, y, z=None, dilate=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract all unmasked pixels as an array of (x,y) points, and an array of (z) values.
Optionally dilate the mask by some number of pixels.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrays2points(x, y, z=None, dilate=0):
    # type: (Array, Array, Array, int) -&gt; Array
    &#34;&#34;&#34;
    Extract all unmasked pixels as an array of (x,y) points, and an array of (z) values.
    Optionally dilate the mask by some number of pixels.
    &#34;&#34;&#34;
    if z is None:
        return stack((x.reshape(-1, 1), y.reshape(-1, 1)), axis=1)
    if isinstance(dilate, int) and dilate &gt; 0:
        z.mask = ndimage.binary_dilation(ndimage.binary_dilation(z.mask))
    if isinstance(z.mask, bool or None):
        columns = (x.reshape(-1, 1), y.reshape(-1, 1), z.reshape(-1, 1))
    else:
        indices = where(~z.mask.reshape(-1, 1))
        columns = (
            x.reshape(-1, 1)[indices],
            y.reshape(-1, 1)[indices],
            z.reshape(-1, 1)[indices],
        )
    return stack(columns, axis=1)</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.avhrr_sst"><code class="name flex">
<span>def <span class="ident">avhrr_sst</span></span>(<span>files, locations, processes=1, chunk=4, delay=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Get year time series of AVHRR temperature</p>
<p>:param files: files to scrap
:param locations: get nearest neighbors of these locations
:param chunk: number to retrieve per batch
:param delay: Ending (inclusive) datetime day
:param processes: number of processes to use</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def avhrr_sst(files, locations, processes=1, chunk=4, delay=1):
    # type: (dict, dict, int, int, int) -&gt; Array
    &#34;&#34;&#34;
    Get year time series of AVHRR temperature

    :param files: files to scrap
    :param locations: get nearest neighbors of these locations
    :param chunk: number to retrieve per batch
    :param delay: Ending (inclusive) datetime day
    :param processes: number of processes to use
    &#34;&#34;&#34;

    total = len(files)
    sst = {key: zeros(total, dtype=float) for key in locations.keys()}
    found = zeros(total, dtype=bool)
    indices = arange(total, dtype=int)

    iteration = 0
    while True:
        pool = Pool(processes)
        jobs = len(indices)
        batches = ceil(jobs / chunk)
        with catch_warnings():
            simplefilter(&#34;ignore&#34;)
            failures = 0
            for ii in range(batches):

                a = ii * chunk
                b = (ii + 1) * chunk
                new = indices[a:b] if b &lt; len(indices) else indices[a:]
                results = pool.map(Dataset.query, files[new])

                for jj in range(len(new)):
                    if results[jj] is not None:
                        _index = new[jj]
                        found[_index] = True
                        for key in results[jj].keys():
                            sst[key][_index] = results[jj][key]
                    else:
                        failures += 1

        (indices,) = where(~found)
        count = sum(found)

        try:
            assert count + failures == total
        except AssertionError:
            break
        if found.all():
            break
        iteration += 1
        sleep(delay)

    return sst</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.blank"><code class="name flex">
<span>def <span class="ident">blank</span></span>(<span>shape, gpu=False, fill=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create mask in shape of data, optionally using GPU</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blank(shape, gpu=False, fill=False):
    # type: (tuple, bool, bool) -&gt; Array
    &#34;&#34;&#34;
    Create mask in shape of data, optionally using GPU
    &#34;&#34;&#34;
    template = (ones if fill else zeros)(shape, dtype=bool)
    if gpu:
        return af.Array(src=template.ctypes.data, dims=template.shape, dtype=&#34;b&#34;)
    else:
        return template</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.calc_areas"><code class="name flex">
<span>def <span class="ident">calc_areas</span></span>(<span>vertex_buffer: <built-in function array>, topology: <built-in function array>, parents: list, verb=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate triangle area and correct windings</p>
<p>Use numpy cross product of 2 legs to calculate area.
May be negative still, so correct windings in place</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_areas(vertex_buffer: array, topology: array, parents: list, verb=True):
    &#34;&#34;&#34;
    Calculate triangle area and correct windings

    Use numpy cross product of 2 legs to calculate area.
    May be negative still, so correct windings in place
    &#34;&#34;&#34;
    vertex_positions = vertex_buffer[topology]
    x, y = vertex_positions

    dx = (x[:, 1] - x[:, 0]).reshape(-1, 1)
    dy = (y[:, 1] - y[:, 0]).reshape(-1, 1)
    aa = hstack((dx, dy))

    dx = (x[:, 2] - x[:, 0]).reshape(-1, 1)
    dy = (y[:, 2] - y[:, 0]).reshape(-1, 1)
    bb = hstack((dx, dy))

    area = 0.5 * cross(bb, aa)
    (indices,) = where(area &lt; 0)
    tri_area = abs(area), roll(topology[indices, 1:3], 1, axis=1)

    shape = len(vertex_buffer)
    area = zeros(shape, dtype=float)
    art2 = zeros(shape, dtype=float)
    for node in range(shape):  # for each control volume
        art2[node] = tri_area[parents[node]].sum()
        area[node] = art2[node] / 3

    return {&#34;parents&#34;: art2, &#34;triangles&#34;: tri_area, &#34;control volume&#34;: area}</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.center"><code class="name flex">
<span>def <span class="ident">center</span></span>(<span>arr)</span>
</code></dt>
<dd>
<div class="desc"><p>Geometric center</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center(arr):
    # type: (Array) -&gt; (float, float)
    &#34;&#34;&#34;
    Geometric center
    &#34;&#34;&#34;
    return tuple(mean(arr.data, axis=0))</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.crop"><code class="name flex">
<span>def <span class="ident">crop</span></span>(<span>x, y, ext, mask=None, gpu=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Mask positions outside the given extent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop(x, y, ext, mask=None, gpu=False):
    # type: (Array, Array, list or tuple, Array, bool) -&gt; Array
    &#34;&#34;&#34;Mask positions outside the given extent&#34;&#34;&#34;
    assert x.shape == y.shape
    if mask is None:
        mask = blank(x.shape)

    mask |= af.np_to_af_array(x &lt; ext[0]) if gpu else x &lt; ext[0]
    mask |= af.np_to_af_array(x &gt; ext[1]) if gpu else x &gt; ext[1]
    mask |= af.np_to_af_array(y &lt; ext[2]) if gpu else y &lt; ext[2]
    mask |= af.np_to_af_array(y &gt; ext[3]) if gpu else y &gt; ext[3]
    return mask</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.days"><code class="name flex">
<span>def <span class="ident">days</span></span>(<span>date)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a single datetime to a Julian day number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def days(date):
    &#34;&#34;&#34;Convert a single datetime to a Julian day number&#34;&#34;&#34;
    delta = date - datetime(date.year, 1, 1, 0, 0, 0)
    result = delta.total_seconds() / 24 / 60 / 60
    return result</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.depth"><code class="name flex">
<span>def <span class="ident">depth</span></span>(<span>bathymetry: <built-in function array>, elevation: <built-in function array> = None, dry: float = 1e-07) ‑> numpy.ma.core.MaskedArray</span>
</code></dt>
<dd>
<div class="desc"><p>Time-varying property, free surface height from water level, meters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def depth(bathymetry: array, elevation: array = None, dry: float = 1e-7) -&gt; MaskedArray:
    &#34;&#34;&#34;
    Time-varying property, free surface height from water level, meters
    &#34;&#34;&#34;
    data = (
        bathymetry if elevation is None else bathymetry + elevation
    )  # water depth, meters
    return ma.masked_array(depth, mask=(data &gt; dry))  # depth threshold to consider dry</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.extent_area"><code class="name flex">
<span>def <span class="ident">extent_area</span></span>(<span>ext)</span>
</code></dt>
<dd>
<div class="desc"><p>Area of a shape extent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extent_area(ext):
    # type: (ExtentType) -&gt; float
    &#34;&#34;&#34;
    Area of a shape extent
    &#34;&#34;&#34;
    return (ext[1] - ext[0]) * (ext[3] - ext[2])</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.extent_crop"><code class="name flex">
<span>def <span class="ident">extent_crop</span></span>(<span>ext, xyz)</span>
</code></dt>
<dd>
<div class="desc"><p>Return only the pixels inside the cropping extent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extent_crop(ext, xyz):
    # type: (ExtentType, Array) -&gt; Array
    &#34;&#34;&#34;Return only the pixels inside the cropping extent&#34;&#34;&#34;
    if xyz.shape[1] &gt; 3:
        a, b = 1, 2
    else:
        a, b = 0, 1
    mask = crop(xyz[:, a], xyz[:, b], ext)
    select = where(~mask)[0]
    return xyz[select, :]</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.extent_overlap_automatic"><code class="name flex">
<span>def <span class="ident">extent_overlap_automatic</span></span>(<span>xyz, shapes, extents, max_passes=3, rec=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Use with sparse rasters. Get overall extent, and find shapes with overlapping extent.
Reduce these to a single extent, and remove xyz values not within that union.
Repeat until extent stops changing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extent_overlap_automatic(xyz, shapes, extents, max_passes=3, rec=None):
    # type: (Array, (Array,), (ExtentType,), int, (dict, )) -&gt; (Array, (Path,))
    &#34;&#34;&#34;
    Use with sparse rasters. Get overall extent, and find shapes with overlapping extent.
    Reduce these to a single extent, and remove xyz values not within that union.
    Repeat until extent stops changing.
    &#34;&#34;&#34;
    warn(
        &#34;Recursive extent culling is unstable. Use looped `extent_overlap_iteration`&#34;,
        DeprecationWarning,
    )

    previous, current = None, extent(xyz[:, 0], xyz[:, 1])
    dat = extent_overlap_filter(current, shapes, extents, rec=rec)
    if rec:
        f, e, r = dat
    else:
        f, e = dat
        r = None

    passes = 0

    while previous != current and passes &lt; max_passes:

        xyz = extent_crop(reduce(reduce_extent, e), xyz)
        previous, current = current, extent(xyz[:, 0], xyz[:, 1])
        dat = extent_overlap_filter(current, f, e, rec=r)
        if rec:
            f, e, r = dat
        else:
            f, e = dat
            r = None

        passes += 1

    return xyz, f, e, r</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.extent_overlap_filter"><code class="name flex">
<span>def <span class="ident">extent_overlap_filter</span></span>(<span>ext, shapes, extents, rec=None)</span>
</code></dt>
<dd>
<div class="desc"><p>:param ext: data extent
:param shapes: shapes are passed through
:param extents: extents to compare
:param rec: records are passed through</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extent_overlap_filter(ext, shapes, extents, rec=None):
    # type: (ExtentType, (Array,), (ExtentType,), (dict,)) -&gt; ((Array,), (ExtentType,))
    &#34;&#34;&#34;

    :param ext: data extent
    :param shapes: shapes are passed through
    :param extents: extents to compare
    :param rec: records are passed through
    &#34;&#34;&#34;
    iterator = zip(*((shapes, extents, rec) if rec else (shapes, extents)))
    return tuple(zip(*filter(lambda x: extent_overlap(ext, x[1]), iterator)))</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.extent_overlap_iteration"><code class="name flex">
<span>def <span class="ident">extent_overlap_iteration</span></span>(<span>vertex_array, shapes, extents, records=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Find overlapping extents, and return only pixels inside their bounding extent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extent_overlap_iteration(vertex_array, shapes, extents, records=None):
    # type: (Array, (Array, ), (ExtentType, ), (dict, )) -&gt; (Array, (tuple, ))
    &#34;&#34;&#34;Find overlapping extents, and return only pixels inside their bounding extent&#34;&#34;&#34;
    data_ext = extent(*vertex_array)
    filtered = extent_overlap_filter(data_ext, shapes, extents, rec=records)
    cropped = extent_crop(reduce(reduce_extent, filtered[1]), vertex_array)
    return (cropped, *filtered)</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.filter_arrays"><code class="name flex">
<span>def <span class="ident">filter_arrays</span></span>(<span>x) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Process an iterable of Array-likes to remove null values, used in map parallelism</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_arrays(x) -&gt; bool:
    &#34;&#34;&#34;Process an iterable of Array-likes to remove null values, used in map parallelism&#34;&#34;&#34;
    try:
        return isinstance(x.shape, tuple)
    except AttributeError:
        return False</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.filter_in_range"><code class="name flex">
<span>def <span class="ident">filter_in_range</span></span>(<span>mask, data, minimum=None, maximum=None, gpu=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Mask if outside interval</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_in_range(mask, data, minimum=None, maximum=None, gpu=False):
    # type: (Array, Array, float, float, bool) -&gt; Array
    &#34;&#34;&#34;Mask if outside interval&#34;&#34;&#34;
    if minimum is not None:
        mask |= af.np_to_af_array(data &lt; minimum) if gpu else data &lt; minimum
    if maximum is not None:
        mask |= af.np_to_af_array(data &gt; maximum) if gpu else data &gt; maximum
    return mask</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.generateStream"><code class="name flex">
<span>def <span class="ident">generateStream</span></span>(<span>columns, records)</span>
</code></dt>
<dd>
<div class="desc"><p>Send database records as a stream of JSON text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generateStream(columns, records):
    &#34;&#34;&#34;
    Send database records as a stream of JSON text
    &#34;&#34;&#34;
    try:
        prev = next(records)  # get first result
    except:
        yield &#34;[]&#34;
        raise StopIteration
    yield &#34;[&#34;
    # Iterate over the releases
    for r in records:
        yield dumps(dict(zip(columns, r))) + &#34;, &#34;
        prev = r
    # Now yield the last iteration without comma but with the closing brackets
    yield dumps(dict(zip(columns, prev))) + &#34;]&#34;</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.geo2dist"><code class="name flex">
<span>def <span class="ident">geo2dist</span></span>(<span>lat1, long1, lat2, long2)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate distance on unit sphere and scale up</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def geo2dist(lat1, long1, lat2, long2):
    # type: (Array or float, Array or float, float, float) -&gt; (Array or float)
    &#34;&#34;&#34;
    Calculate distance on unit sphere and scale up
    &#34;&#34;&#34;
    degrees_to_radians = pi / 180.0
    phi1 = (90.0 - lat1) * degrees_to_radians
    phi2 = (90.0 - lat2) * degrees_to_radians
    theta1 = long1 * degrees_to_radians
    theta2 = long2 * degrees_to_radians
    cosine = sin(phi1) * sin(phi2) * cos(theta1 - theta2) + cos(phi1) * cos(phi2)
    arc = arccos(cosine)
    return arc * 6373000</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.geom_shader"><code class="name flex">
<span>def <span class="ident">geom_shader</span></span>(<span>e)</span>
</code></dt>
<dd>
<div class="desc"><p>Emulate geometry shader, create points from single reference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def geom_shader(e):
    &#34;&#34;&#34;Emulate geometry shader, create points from single reference&#34;&#34;&#34;
    return array(
        (
            (lin_transform(random.uniform(), *e[:2]), e[2]),
            (e[1], lin_transform(random.uniform(), *e[2:4])),
            (lin_transform(random.uniform(), *e[:2]), e[3]),
            (e[0], lin_transform(random.uniform(), *e[2:4])),
        )
    )</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.googleCloudSecret"><code class="name flex">
<span>def <span class="ident">googleCloudSecret</span></span>(<span>secret_name='my-secret')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def googleCloudSecret(secret_name=&#34;my-secret&#34;):
    # type: (str) -&gt; str
    project_id = getenv(&#34;GCP_PROJECT&#34;)  # Google Compute default param
    resource_name = f&#34;projects/{project_id}/secrets/{secret_name}/versions/latest&#34;
    try:
        response = client.access_secret_version(resource_name)
    except NameError as _:
        return None
    return response.payload.data.decode(&#34;UTF-8&#34;)</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.hull_contains"><code class="name flex">
<span>def <span class="ident">hull_contains</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<div class="desc"><p>First convex hull contains second</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hull_contains(a, b):
    # type: (Path or Array, Path or Array) -&gt; bool
    &#34;&#34;&#34;First convex hull contains second&#34;&#34;&#34;
    _a, _b = tuple((x if isinstance(x, Path) else Path(x) for x in (a, b)))
    return _a.contains_path(_b)</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.hull_overlap"><code class="name flex">
<span>def <span class="ident">hull_overlap</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Two convex hulls overlap</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hull_overlap(a, b):
    # type: (Array or Path, Array or Path) -&gt; bool
    &#34;&#34;&#34;Two convex hulls overlap&#34;&#34;&#34;
    _a, _b = tuple((x if isinstance(x, Path) else Path(x) for x in (a, b)))
    _av, _bv = tuple((x.vertices if isinstance(x, Path) else x for x in (a, b)))
    return _a.contains_points(_bv).any() or _b.contains_points(_av).any()</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.identity"><code class="name flex">
<span>def <span class="ident">identity</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>identity matrix</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identity():
    # type: () -&gt; Array
    &#34;&#34;&#34;identity matrix&#34;&#34;&#34;
    matrix = zeros((4, 4))
    for ii in range(4):
        matrix[ii, ii] = 1.0
    return matrix</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.image2arrays"><code class="name flex">
<span>def <span class="ident">image2arrays</span></span>(<span>path, utm_extent, native=Proj('+proj=utm +zone=19 +ellps=GRS80 +units=m +no_defs', preserve_units=True), view=Proj('+proj=longlat +datum=WGS84 +no_defs', preserve_units=True))</span>
</code></dt>
<dd>
<div class="desc"><p>Load landsat image and convert to arrays for processing.</p>
<p>Including the Projection definitions should memoize the defaults between calls
run in the same context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image2arrays(
    path, utm_extent, native=Proj(init=&#34;epsg:2960&#34;), view=Proj(init=&#34;epsg:4326&#34;)
):
    # type: (str, list, Proj, Proj) -&gt; (Array, Array, Array)
    &#34;&#34;&#34;
    Load landsat image and convert to arrays for processing.

    Including the Projection definitions should memoize the defaults between calls
    run in the same context.
    &#34;&#34;&#34;
    fid = open(path, &#34;r&#34;)
    image = Image()
    image.frombytes(data=fid.read())  # read image file
    px = repeat(arange(image.width).reshape(1, image.width), image.height, axis=0)
    py = repeat(arange(image.height).reshape(image.height, 1), image.width, axis=1)

    utm = pix2utm(px, py, utm_extent)
    return (*project(*utm, native=native, view=view), asarray(image))</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.image_to_masked"><code class="name flex">
<span>def <span class="ident">image_to_masked</span></span>(<span>image: <built-in function array>, m: float = 0.125, b: float = 2.0, hide: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate value from greyscale color</p>
<p>:param image: color value of bathysphere_functions_image
:param m: slope
:param b: offset
:param hide: sometimes there are things like color map bars and shit
:return: sea surface temperature bathysphere_functions_image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image_to_masked(image: array, m: float = 0.125, b: float = 2.0, hide: bool = True):
    &#34;&#34;&#34;
    Calculate value from greyscale color

    :param image: color value of bathysphere_functions_image
    :param m: slope
    :param b: offset
    :param hide: sometimes there are things like color map bars and shit
    :return: sea surface temperature bathysphere_functions_image
    &#34;&#34;&#34;

    sst = m * image - b
    if hide:
        a, b, c, d = 250, 700, 1, 75
        sst[a:b, c:d] = NaN  # mask color bar
    return sst</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.interp1d"><code class="name flex">
<span>def <span class="ident">interp1d</span></span>(<span>coefficient, aa, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple linear interpolation in one dimension</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp1d(coefficient, aa, bb):
    &#34;&#34;&#34;
    Simple linear interpolation in one dimension
    &#34;&#34;&#34;
    return (1.0 - coefficient) * aa + coefficient * bb</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.interp1d_lin"><code class="name flex">
<span>def <span class="ident">interp1d_lin</span></span>(<span>x, y, samples, clamp=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple linear interpolation, requires pre-calculated coefficients for points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp1d_lin(x, y, samples, clamp=False):
    # type: ((Array, Array), (Array, Array), Array, bool) -&gt; Array
    &#34;&#34;&#34;Simple linear interpolation, requires pre-calculated coefficients for points&#34;&#34;&#34;
    predicted = (y[1] - y[0]) / (x[1] - x[0]) * (samples - x[0]) + y[0]
    if clamp:
        i = where(x &lt; x[0])
        j = where(x &gt; x[1])
        predicted[i] = y[0]
        predicted[j] = y[1]
    return predicted</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.interp2d_nearest"><code class="name flex">
<span>def <span class="ident">interp2d_nearest</span></span>(<span>xy, samples)</span>
</code></dt>
<dd>
<div class="desc"><p>Load low-resolution data (e.g. AVHRR) and interpolate it to pixels of higher-resolution imagery
(e.g. Landsat) using nearest neighbors. Uses nearest neighbor indexing and search with kd-trees
from <code>scipy.spatial</code></p>
<ul>
<li>setting <code>rescale=True</code> will normalize all dimensions to 0-1</li>
<li><code>tree_options</code> allows you to configure the kd-tree</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp2d_nearest(xy, samples):
    # type: (Array, Array) -&gt; Array
    &#34;&#34;&#34;
    Load low-resolution data (e.g. AVHRR) and interpolate it to pixels of higher-resolution imagery
    (e.g. Landsat) using nearest neighbors. Uses nearest neighbor indexing and search with kd-trees
    from `scipy.spatial`

    - setting `rescale=True` will normalize all dimensions to 0-1
    - `tree_options` allows you to configure the kd-tree
    &#34;&#34;&#34;
    interp = NearestNDInterpolator(xy[:, 0], xy[:, 1], rescale=False, tree_options=None)
    return interp(samples)</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.interp2d_tri"><code class="name flex">
<span>def <span class="ident">interp2d_tri</span></span>(<span>xy, z, cubic=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>interpolate 2D field on triangular grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp2d_tri(xy, z, cubic=False, **kwargs):
    # type: (Array, Array, bool, dict) -&gt; Array
    &#34;&#34;&#34; interpolate 2D field on triangular grid &#34;&#34;&#34;
    engine = (CubicTriInterpolator if cubic else LinearTriInterpolator)(z, **kwargs)
    return engine(xy[:, 0], xy[:, 1])</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.interp2d_uv"><code class="name flex">
<span>def <span class="ident">interp2d_uv</span></span>(<span>cells, train, neighbors, layer, shape_coefficient)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolate</p>
<p>:param cells:
:param neighbors: pre-computed adjacency
:param train: sample points
:param layer:
:param shape_coefficient: pre-computing shape coefficients for static meshes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp2d_uv(cells, train, neighbors, layer, shape_coefficient):
    # type: (Array, (Array,), Array, int, Array) -&gt; Array
    &#34;&#34;&#34;
    Interpolate

    :param cells:
    :param neighbors: pre-computed adjacency
    :param train: sample points
    :param layer:
    :param shape_coefficient: pre-computing shape coefficients for static meshes
    &#34;&#34;&#34;
    x, y, e = train
    expected = zeros((len(x), 3), dtype=float)

    for index in unique(cells):
        children = where((cells == index))
        s = shape_coefficient[index, :, :]

        for each in children:
            dx = x[each] - x[index]
            dy = y[each] - y[index]
            indices = append(neighbors[index], index)  # self and neighbors

            for dim in range(3):
                e_i = e[indices, layer, dim]
                expected[each, dim] = e[index, layer, dim] + (s * e_i) * array([dx, dy])
            continue

    return expected</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.interp3d_slice"><code class="name flex">
<span>def <span class="ident">interp3d_slice</span></span>(<span>z, scalar, layer, clamp=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Depth-based interpolation</p>
<p>:param z: sample depths
:param scalar: the scalar field
:param layer: vertical layer in triangular mesh
:param clamp: values outside the interpolation range are fixed at end member values
:return: values at sample points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp3d_slice(z, scalar, layer, clamp=True):
    # type: (Array, Array, int, bool) -&gt; Array
    &#34;&#34;&#34;
    Depth-based interpolation

    :param z: sample depths
    :param scalar: the scalar field
    :param layer: vertical layer in triangular mesh
    :param clamp: values outside the interpolation range are fixed at end member values
    :return: values at sample points
    &#34;&#34;&#34;
    above = scalar[:, layer]
    below = scalar[:, layer + 1]
    return interp1d_lin(
        x=tuple(i for i in z[layer : layer + 2]),
        y=(above, below),
        samples=z,
        clamp=clamp,
    )</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.interp3d_tri"><code class="name flex">
<span>def <span class="ident">interp3d_tri</span></span>(<span>xy, z, scalar, layer, cubic=False, clamp=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolate 3D field on triangular grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp3d_tri(xy, z, scalar, layer, cubic=False, clamp=True, **kwargs):
    # type: (Array, Array, Array, int, bool, bool, dict) -&gt; Array
    &#34;&#34;&#34; Interpolate 3D field on triangular grid &#34;&#34;&#34;
    above = interp2d_tri(xy, z=scalar[:, layer], cubic=cubic, **kwargs)
    below = interp2d_tri(xy, z=scalar[:, layer + 1], cubic=cubic, **kwargs)
    return interp1d_lin(
        x=tuple(i for i in z[layer : layer + 2]),
        y=(above, below),
        samples=z,
        clamp=clamp,
    )</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>x: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience method for mapping query formatting when whitespace is needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(x: str) -&gt; str:
    &#34;&#34;&#34;Convenience method for mapping query formatting when whitespace is needed&#34;&#34;&#34;
    return &#34;, &#34;.join(x)</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.landsat_sst_regression"><code class="name flex">
<span>def <span class="ident">landsat_sst_regression</span></span>(<span>raw, lon, lat, roi, samples, outliers, nsub=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate SST by removing outliers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def landsat_sst_regression(raw, lon, lat, roi, samples, outliers, nsub=10):
    # type: (Array, Array, Array, (Array,), tuple, tuple, int ) -&gt; Array or None
    &#34;&#34;&#34;
    Calculate SST by removing outliers
    &#34;&#34;&#34;
    def brightness_temperature(x, m=3.3420e-04, b=0.1, k1=774.89, k2=1321.08):
        # type: (Array, float, float, float, float) -&gt; Array
        &#34;&#34;&#34;Brightness temperature from Band 10 raw counts&#34;&#34;&#34;
        radiance = m * x + b
        return (k2 / log((k1 / radiance) + 1)) - 272.15

    # Load satellite data and subset it
    btemp = brightness_temperature(raw)
    subbt = subset(btemp, nsub)
    samples = interp2d_nearest((lon, lat, btemp), samples=samples)

    # Generate masks
    mask = crop(lon, lat, roi)
    mask = filter_in_range(mask, btemp, maximum=-10)  # mask clouds 124.6
    mask |= (
        (samples &lt; outliers[0]) | (samples &gt; outliers[1]) | (btemp &lt; min(subbt))
    )  # combine masks
    indices = where(~mask)  # get unmasked linear indices
    avhrr_filtered = samples[indices].reshape(-1, 1)  # extract unmasked AVHRR values
    ls_filtered = btemp[indices].reshape(-1, 1)  # extract

    # Regress Landsat and AVHRR
    fit = 0.0
    intercept = None
    slope = None

    while True:
        pairs = hstack((avhrr_filtered, ls_filtered))
        _slope, _intercept, r, _, _ = linregress(pairs)  # regress
        if (abs(r) - abs(fit)) &lt; 0.000001:  # if r-value is improving
            break

        slope = _slope
        intercept = _intercept
        fit = r
        gtruth = avhrr_filtered * _slope + _intercept  # &#34;true&#34; values
        residual = abs(ls_filtered - gtruth)  # difference between observations
        stdv = std(ls_filtered)  # landsat standard deviation
        keepers, _ = where(residual &lt; stdv)
        if len(keepers) == 0:
            break

        ls_filtered = ls_filtered[keepers]
        avhrr_filtered = avhrr_filtered[keepers]

    if not slope or not intercept:
        return None
    sst = (btemp - intercept) / slope  # full resolution version for output

    # if crop:  # sparse sub-sampling
    #     submask = subset(mask, nsub)
    #     subsst = subset(sst, nsub)
    #     sublat = subset(lat, nsub)
    #     sublon = subset(lon, nsub)

    return sst</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.lin_transform"><code class="name flex">
<span>def <span class="ident">lin_transform</span></span>(<span>u, a, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Linear tranformation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lin_transform(u, a, b):
    &#34;&#34;&#34;Linear tranformation&#34;&#34;&#34;
    return u * (b - a) + a</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.linear_regression_predict"><code class="name flex">
<span>def <span class="ident">linear_regression_predict</span></span>(<span>model, predict, order=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Use trained model to predict new values</p>
<p>:param model:
:param predict: x-values
:param order: order of linear model terms (1 or 2)
:return: y-values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linear_regression_predict(model, predict, order=1):
    # type: (LinearRegression, (Array,), int) -&gt; (Array, float)
    &#34;&#34;&#34;
    Use trained model to predict new values

    :param model:
    :param predict: x-values
    :param order: order of linear model terms (1 or 2)
    :return: y-values
    &#34;&#34;&#34;
    if not 0 &lt; order &lt; 3:
        raise ValueError
    if len(predict) == 2:
        x, y = predict
        z = None
    elif len(predict) == 3:
        x, y, z = predict
    else:
        raise ValueError

    expected = stack((x, y), axis=1)
    if order == 2:
        expected = stack((expected, x * y, x * x, y * y), axis=1)
    if z is not None:
        expected = stack((expected, z), axis=1)
    return model.predict(expected)</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.linear_regression_train"><code class="name flex">
<span>def <span class="ident">linear_regression_train</span></span>(<span>train, target)</span>
</code></dt>
<dd>
<div class="desc"><p>Train a linear regression model to fit the array data</p>
<p>:param train: x-value
:param target: y-value
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linear_regression_train(train, target):
    # type: ((Array,), Array) -&gt; (LinearRegression, float)
    &#34;&#34;&#34;
    Train a linear regression model to fit the array data

    :param train: x-value
    :param target: y-value
    :return:
    &#34;&#34;&#34;
    model = LinearRegression()
    model.fit(train, target)
    auto_regress = model.predict(train)
    r_squared = r2_score(target, auto_regress)
    return model, r_squared</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.loadAppConfig"><code class="name flex">
<span>def <span class="ident">loadAppConfig</span></span>(<span>sources: str = ('bathysphere.yml', 'kubernetes.yml')) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Load known entities and services at initialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadAppConfig(sources: (str) = (&#34;bathysphere.yml&#34;, &#34;kubernetes.yml&#34;)) -&gt; dict:
    &#34;&#34;&#34;
    Load known entities and services at initialization.
    &#34;&#34;&#34;

    def renderConfig(x: str):
        &#34;&#34;&#34;
        Open the local config directory and process entries into dict structures
        &#34;&#34;&#34;
        with open(pathlib.Path(f&#34;config/{x}&#34;), &#34;r&#34;) as fid:
            items = fid.read().split(&#34;---&#34;)
        return list(map(load_yml, items, repeat(Loader, len(items))))

    def reverseDictionary(a: dict, b: dict) -&gt; dict:
        &#34;&#34;&#34;
        Flip the nestedness of the dict from a list to have top level keys for each `kind`
        &#34;&#34;&#34;
        if not isinstance(a, dict):
            raise ValueError(
                &#34;Expected dictionary values. Type is instead {}.&#34;.format(type(a))
            )

        if b is not None:
            key = b.pop(&#34;kind&#34;)
            if key not in a.keys():
                a[key] = [b]
            else:
                a[key].append(b)
        return a

    items = reduce(operator.add, map(renderConfig, sources), [])
    return reduce(reverseDictionary, items, {})</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.mask"><code class="name flex">
<span>def <span class="ident">mask</span></span>(<span>shape, masked=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask(shape, masked=None):
    m = zeros(shape, dtype=bool)
    if masked is not None:
        m[masked] = True
    return m</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.multi_polygon_crop"><code class="name flex">
<span>def <span class="ident">multi_polygon_crop</span></span>(<span>xyz, shapes)</span>
</code></dt>
<dd>
<div class="desc"><p>Retain points inside the shapes, along with the shape index that they belong to.</p>
<p>WARNING: In-place memory operation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multi_polygon_crop(xyz, shapes):
    &#34;&#34;&#34;
    Retain points inside the shapes, along with the shape index that they belong to.

    WARNING: In-place memory operation.
    &#34;&#34;&#34;
    found = []
    for i, s in enumerate(shapes):
        p = Path(s)
        ins, xyz = partition_points_by_shape(p, xyz)
        found.append((ins, i))
        if len(xyz) == 0:
            break
    return hstack(found)</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.multi_polygon_cull"><code class="name flex">
<span>def <span class="ident">multi_polygon_cull</span></span>(<span>xyz, shapes)</span>
</code></dt>
<dd>
<div class="desc"><p>Retain only points which are not in any polygon.</p>
<p>WARNING: In-place memory operation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multi_polygon_cull(xyz, shapes):
    &#34;&#34;&#34;
    Retain only points which are not in any polygon.

    WARNING: In-place memory operation.
    &#34;&#34;&#34;
    for s in shapes:
        p = Path(s)
        _, xyz = partition_points_by_shape(p, xyz)
        if len(xyz) == 0:
            break
    return xyz</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.multiply"><code class="name flex">
<span>def <span class="ident">multiply</span></span>(<span>u, v)</span>
</code></dt>
<dd>
<div class="desc"><p>Quaternion matrix multiplication for one or more vertices</p>
<p>A<em>B - dotProduct(u,v)
cross(u,v) + A</em>v + B*u</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiply(u, v):
    # type: (Array, Array) -&gt; Array
    &#34;&#34;&#34;
    Quaternion matrix multiplication for one or more vertices

    A*B - dotProduct(u,v)
    cross(u,v) + A*v + B*u
    &#34;&#34;&#34;
    ur, _ = u.shape
    vr, _ = v.shape
    rows = max([ur, vr])
    result = zeros((rows, 4), dtype=float)

    result[:, 0] = (
        u[:, 0] * v[:, 0] - u[:, 1] * v[:, 1] - u[:, 2] * v[:, 2] - u[:, 3] * v[:, 3]
    )
    result[:, 1] = (
        u[:, 2] * v[:, 3] - u[:, 3] * v[:, 2] + u[:, 0] * v[:, 1] + v[:, 0] * u[:, 1]
    )
    result[:, 2] = (
        u[:, 3] * v[:, 1] - u[:, 1] * v[:, 3] + u[:, 0] * v[:, 2] + v[:, 0] * u[:, 2]
    )
    result[:, 3] = (
        u[:, 1] * v[:, 2] - u[:, 2] * v[:, 1] + u[:, 0] * v[:, 3] + v[:, 0] * u[:, 3]
    )
    return result</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.nan_mask"><code class="name flex">
<span>def <span class="ident">nan_mask</span></span>(<span>arr, gpu=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset mask</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nan_mask(arr, gpu=False):
    # type: (Array, bool) -&gt; Array
    &#34;&#34;&#34;Reset mask&#34;&#34;&#34;
    if gpu:
        return af.isnan(arr)
    mask = isnan(arr)
    if isinstance(mask, MaskedArray):
        return mask.data
    return mask</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.normal"><code class="name flex">
<span>def <span class="ident">normal</span></span>(<span>u)</span>
</code></dt>
<dd>
<div class="desc"><p>Normalize array of vectors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal(u):
    # type: (Array) -&gt; Array
    &#34;&#34;&#34;Normalize array of vectors&#34;&#34;&#34;
    return u / norm(u, axis=1).reshape((-1, 1))</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.parsePostgresValueIn"><code class="name flex">
<span>def <span class="ident">parsePostgresValueIn</span></span>(<span>value: Any) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert python to sql values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parsePostgresValueIn(value: Any) -&gt; str:
    &#34;&#34;&#34;Convert python to sql values&#34;&#34;&#34;
    parsingTable = {
        datetime: lambda x: x.isoformat(),
        float: lambda x: str(x),
        int: lambda x: f&#34;{x}.0&#34;,
        str: lambda x: f&#34;&#39;{x}&#39;&#34;,
        dict: lambda x: f&#34;ST_GeomFromGeoJSON(&#39;{dumps(x)}&#39;)&#34;,
    }
    return parsingTable.get(type(value), lambda x: &#34;NULL&#34;)(value)</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.parsePostgresValueOut"><code class="name flex">
<span>def <span class="ident">parsePostgresValueOut</span></span>(<span>v: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Convert sql driver output to python</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parsePostgresValueOut(v: Any) -&gt; Any:
    &#34;&#34;&#34;Convert sql driver output to python&#34;&#34;&#34;
    if isinstance(v, Decimal):
        return float(v)
    return v</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.partition_points_by_shape"><code class="name flex">
<span>def <span class="ident">partition_points_by_shape</span></span>(<span>path, vertex_array)</span>
</code></dt>
<dd>
<div class="desc"><p>"Split vertex array into points inside and outside of shape</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition_points_by_shape(path, vertex_array):
    # type: (Path, Array) -&gt; (Array, Array)
    &#34;&#34;&#34;&#34;Split vertex array into points inside and outside of shape&#34;&#34;&#34;
    cols = vertex_array.shape[1]
    if cols == 2:
        xy = vertex_array
    elif cols == 3:
        xy = vertex_array[:2]
    else:
        xy = vertex_array[1:3]

    mask = points_in_path(path, xy)
    _subset = where(mask)[0]
    inside = vertex_array[_subset, :]
    _subset = where(~mask)[0]  # pylint: disable=invalid-unary-operand-type
    outside = vertex_array[_subset, :]
    return inside, outside</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.pix2utm"><code class="name flex">
<span>def <span class="ident">pix2utm</span></span>(<span>px, py, ext)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert from pixel indices to UTM coordinates. Technically also works with lon/lat.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pix2utm(px, py, ext):
    # type: (Array, Array, list) -&gt; (Array, Array)
    &#34;&#34;&#34;
    Convert from pixel indices to UTM coordinates. Technically also works with lon/lat.
    &#34;&#34;&#34;
    utmx = px / max(px) * (ext[2] - ext[0]) + ext[0]
    utmy = py / max(py) * (ext[3] - ext[1]) + ext[1]
    return utmx, utmy</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.pixel_area"><code class="name flex">
<span>def <span class="ident">pixel_area</span></span>(<span>arr, resolution, gpu=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate pixel area assuming fixed resolution, may be in GPU memory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pixel_area(arr, resolution, gpu=False):
    # type: (Array, float, bool) -&gt; Array or None
    &#34;&#34;&#34;Calculate pixel area assuming fixed resolution, may be in GPU memory&#34;&#34;&#34;
    if resolution is not None and arr.mask is not None:
        add = af.sum if gpu else sum
        return add(~arr.mask) * resolution * resolution
    return None</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.points_in_path"><code class="name flex">
<span>def <span class="ident">points_in_path</span></span>(<span>path, vertex_array, max_size=10000, processes=1, pool=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Break up point stream into chunks by intersecting with polygon collection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def points_in_path(path, vertex_array, max_size=10000, processes=1, pool=None):
    # type: (Path, Array, int, int, Pool) -&gt; (Array, Array)
    &#34;&#34;&#34;Break up point stream into chunks by intersecting with polygon collection&#34;&#34;&#34;
    if pool is None:
        pool = Pool(processes=processes)
    sections = len(vertex_array) // max_size + 1
    iterable = zip(
        repeat((path,), sections), array_split(vertex_array, sections, axis=0)
    )
    return hstack(pool.starmap(_points_in_path, iterable))</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.polygon_area"><code class="name flex">
<span>def <span class="ident">polygon_area</span></span>(<span>arr)</span>
</code></dt>
<dd>
<div class="desc"><p>Polygon area, may be negative depending on winding, but this is retaining for shape culling</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polygon_area(arr):
    # type: (Array) -&gt; float
    &#34;&#34;&#34;Polygon area, may be negative depending on winding, but this is retaining for shape culling&#34;&#34;&#34;
    xx, yy = arr[:, :2].T
    return 0.5 * (dot(xx, roll(yy, 1)) - dot(yy, roll(xx, 1)))</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.project"><code class="name flex">
<span>def <span class="ident">project</span></span>(<span>xx, yy, native, view)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-project coordinates to/from spherical or cartesian</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project(xx, yy, native, view):
    # type: (Array, Array, Proj, Proj) -&gt; (Array, Array)
    &#34;&#34;&#34;Re-project coordinates to/from spherical or cartesian&#34;&#34;&#34;
    assert xx.shape == yy.shape
    xo, yo = transform(native, view, xx.flatten(order=&#34;F&#34;), yy.flatten(order=&#34;F&#34;))
    return xo.reshape(xx.shape), yo.reshape(yy.shape)</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.raster2mesh"><code class="name flex">
<span>def <span class="ident">raster2mesh</span></span>(<span>train, predict, order=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolate 2D field to triangular mesh</p>
<p>:param train: training points (raster)
:param predict: prediction points (mesh)
:param order: order of linear model terms (1 or 2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def raster2mesh(train, predict, order=1):
    # type: ((Array,), (Array,), int) -&gt; Array
    &#34;&#34;&#34;
    Interpolate 2D field to triangular mesh

    :param train: training points (raster)
    :param predict: prediction points (mesh)
    :param order: order of linear model terms (1 or 2)
    &#34;&#34;&#34;
    if not 0 &lt; order &lt; 3:
        raise ValueError
    if len(train) == 4:
        x, y, z, e = train
        mask = isnan(z) | isnan(e)
    elif len(train) == 3:
        z = None
        x, y, e = train
        mask = isnan(e)
    else:
        raise ValueError

    (ind,) = where(~mask)

    def extract_valid(arr):
        return arr[ind].reshape(-1, 1) if arr is not None else None

    train = (extract_valid(item) for item in (x, y, z, e))
    model, _ = linear_regression_train(train=train, target=e)
    return linear_regression_predict(model, predict=predict, order=order)</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.report_buoy_data"><code class="name flex">
<span>def <span class="ident">report_buoy_data</span></span>(<span>request)</span>
</code></dt>
<dd>
<div class="desc"><p>We receive the hashed message in form of a header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_buoy_data(request):
    &#34;&#34;&#34;We receive the hashed message in form of a header&#34;&#34;&#34;

    if getenv(&#34;Http_Method&#34;) != &#34;POST&#34;:
        return dumps({&#34;Error&#34;: &#34;Require POST&#34;}), 400
    if not request.body:
        return dumps({&#34;Error&#34;: &#34;No request body&#34;}), 400

    body = request.body

    interval = body.get(&#34;interval&#34;, (None, None))
    limit = body.get(&#34;limit&#34;, None)
    encoding = body.get(&#34;encoding&#34;, &#34;txt&#34;)
    node = body.get(&#34;id&#34;, None)
    fields = body.get(&#34;observedProperties&#34;, None)

    if (
        not any((limit, *interval))
        or not any((fields, node))
        or encoding not in (&#34;txt&#34;, &#34;json&#34;)
    ):
        return dumps({&#34;Error&#34;: &#34;Bad Request&#34;}), 400

    host = getenv(&#34;hostname&#34;, &#34;maine.loboviz.com&#34;)
    times = (
        f&#34;&amp;newest={limit}&#34; if limit else &#34;&amp;min_date={}&amp;max_date={}&#34;.format(*interval)
    )
    url = f&#34;http://{host}/cgi-data/nph-data.cgi?data_format=text&amp;node={node}&amp;y={&#39;,&#39;.join(fields)}{times}&#34;
    response = get(url)
    content = response.content.decode()
    if not response.ok:
        return response

    if encoding == &#34;txt&#34;:
        return content, 200

    lines = deque(filter(lambda x: len(x), content.split(&#34;\n&#34;)))
    name, alias = lines.popleft().split(&#34;-&#34;)
    data = {
        &#34;name&#34;: name,
        &#34;aliases&#34;: list(set(map(str.strip, (alias, lines.popleft())))),
    }
    lines = deque(map(lambda x: tuple(x.split(&#34;\t&#34;)), lines))
    keys = lines.popleft()
    return (
        dumps(
            {
                **data,
                &#34;values&#34;: [
                    dict(zip(k, v)) for k, v in zip(repeat(keys, len(lines)), lines)
                ],
            }
        ),
        200,
    )</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.resolveTaskTree"><code class="name flex">
<span>def <span class="ident">resolveTaskTree</span></span>(<span>t) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively run and REDUCE an asynchronous task tree which returns an (index, <coroutine>) tuple. The process
stops when the final inner method is evaluated.</p>
<p>This is used internally by <code>metadata()</code>. The depth of the task structure is set before runtime, for example,
see <code>_map_by_date</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolveTaskTree(t) -&gt; tuple:
    &#34;&#34;&#34;
    Recursively run and REDUCE an asynchronous task tree which returns an (index, &lt;coroutine&gt;) tuple. The process
    stops when the final inner method is evaluated.

    This is used internally by `metadata()`. The depth of the task structure is set before runtime, for example,
    see `_map_by_date`.
    &#34;&#34;&#34;

    i, inner = synchronous(t)
    if inner is None:
        return (i,)
    yields = ()
    while len(inner):
        yields += tuple(
            [i, *((j,) if type(j) == int else tuple(j))]
            for j in resolveTaskTree(inner.pop())
        )
    return yields</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.response"><code class="name flex">
<span>def <span class="ident">response</span></span>(<span>status, payload)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def response(status, payload):
    return {
        &#34;status&#34;: status,
        &#34;payload&#34;: list(payload),
    }</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.rk4"><code class="name flex">
<span>def <span class="ident">rk4</span></span>(<span>fcn, y0, t0, dt)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple 4th-order Runge-Kutta integration, non boundary checking</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rk4(fcn, y0, t0, dt):
    &#34;&#34;&#34;
    Simple 4th-order Runge-Kutta integration, non boundary checking
    &#34;&#34;&#34;
    k1 = fcn(t0, y0)
    k2 = fcn(t0 + 0.5 * dt, y0 + 0.5 * k1)
    k3 = fcn(t0 + 0.5 * dt, y0 + 0.5 * k2)
    k4 = fcn(t0 + dt, y0 + k3)

    return y0 + dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>vertex_array: <built-in function array>, angle: float, axis: <built-in function array>) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>Rotate list of vectors(/vertices) about any axis by angle in radians. Default to Z-AXIS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate(vertex_array: array, angle: float, axis: array) -&gt; array:
    &#34;&#34;&#34;
    Rotate list of vectors(/vertices) about any axis by angle in radians. Default to Z-AXIS
    &#34;&#34;&#34;
    a = cos(0.5 * angle)
    b = sin(0.5 * angle) * normal(axis)

    if vertex_array.shape[1] == 4:
        state = vertex_array
    else:
        state = zeros((len(vertex_array), 4), dtype=float)
        state[:, 1:4] = vertex_array[:, :]

    matrix = append(a, b).reshape(1, 4)
    state = multiply(matrix, state)  # intermediate multiplication
    matrix = append(a, -b).reshape(1, 4)  # conjugation
    return multiply(state, matrix)[:, 1:4]  # final step, omit w coordinates</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.shapefile"><code class="name flex">
<span>def <span class="ident">shapefile</span></span>(<span>path, gpu=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get array of objects from Shapefile</p>
<p>:param path:
:param gpu:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shapefile(path, gpu=False):
    # type: (str, bool) -&gt; (Array,)
    &#34;&#34;&#34;
    Get array of objects from Shapefile

    :param path:
    :param gpu:
    &#34;&#34;&#34;
    reader = Reader(path)
    fields = reader.fields[1:]  # remove deletion flag
    result = []
    for shape, record in reader.iterShapeRecords():
        assert len(fields) == len(record), (fields, record)
        meta = {key[0]: rec for key, rec in zip(fields, record)}
        vertices = array(shape.points)
        parts = array_split(vertices, shape.parts[1:])
        result.extend(zip(parts, repeat(meta, len(parts))))
    return result</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.spherical_nearest_neighbor"><code class="name flex">
<span>def <span class="ident">spherical_nearest_neighbor</span></span>(<span>lon, lat, reference)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate distance matrix and indices of closet points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spherical_nearest_neighbor(lon, lat, reference):
    # type: (Array, Array, (float, float)) -&gt; (Array, Array)
    &#34;&#34;&#34;
    Calculate distance matrix and indices of closet points
    &#34;&#34;&#34;
    dxy = geo2dist(lat, lon, *reference)
    return dxy, dxy.argmin()</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.subset"><code class="name flex">
<span>def <span class="ident">subset</span></span>(<span>arr, stride)</span>
</code></dt>
<dd>
<div class="desc"><p>Regular-spaced sparse subset of an array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subset(arr, stride):
    # type: (Array, int) -&gt; Array
    &#34;&#34;&#34;Regular-spaced sparse subset of an array&#34;&#34;&#34;
    return arr[1:-1:stride, 1:-1:stride]</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.synchronous"><code class="name flex">
<span>def <span class="ident">synchronous</span></span>(<span>task, loop=None, close=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Run an asynchronous tasks in serial. First build JSON structures with Co-routines in place of data,
and then render the result of the Co-routines in-place.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def synchronous(task, loop=None, close=False):
    # type: (Coroutine, BaseEventLoop, bool) -&gt; Any
    &#34;&#34;&#34;
    Run an asynchronous tasks in serial. First build JSON structures with Co-routines in place of data,
    and then render the result of the Co-routines in-place.
    &#34;&#34;&#34;
    if loop is None:
        close = True
        loop = new_event_loop()
    set_event_loop(loop)  # create the event loop
    result = loop.run_until_complete(task)
    if close:
        loop.close()
    return result</code></pre>
</details>
</dd>
<dt id="bathysphere.utils.xye"><code class="name flex">
<span>def <span class="ident">xye</span></span>(<span>x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Return height-mapped vertex array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xye(x, y, z):
    &#34;&#34;&#34;Return height-mapped vertex array&#34;&#34;&#34;
    return hstack((x.reshape(-1, 1), y.reshape(-1, 1), z.reshape(-1, 1)))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bathysphere" href="index.html">bathysphere</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="bathysphere.utils.area_sort" href="#bathysphere.utils.area_sort">area_sort</a></code></li>
<li><code><a title="bathysphere.utils.array2image" href="#bathysphere.utils.array2image">array2image</a></code></li>
<li><code><a title="bathysphere.utils.arrays2points" href="#bathysphere.utils.arrays2points">arrays2points</a></code></li>
<li><code><a title="bathysphere.utils.avhrr_sst" href="#bathysphere.utils.avhrr_sst">avhrr_sst</a></code></li>
<li><code><a title="bathysphere.utils.blank" href="#bathysphere.utils.blank">blank</a></code></li>
<li><code><a title="bathysphere.utils.calc_areas" href="#bathysphere.utils.calc_areas">calc_areas</a></code></li>
<li><code><a title="bathysphere.utils.center" href="#bathysphere.utils.center">center</a></code></li>
<li><code><a title="bathysphere.utils.crop" href="#bathysphere.utils.crop">crop</a></code></li>
<li><code><a title="bathysphere.utils.days" href="#bathysphere.utils.days">days</a></code></li>
<li><code><a title="bathysphere.utils.depth" href="#bathysphere.utils.depth">depth</a></code></li>
<li><code><a title="bathysphere.utils.extent_area" href="#bathysphere.utils.extent_area">extent_area</a></code></li>
<li><code><a title="bathysphere.utils.extent_crop" href="#bathysphere.utils.extent_crop">extent_crop</a></code></li>
<li><code><a title="bathysphere.utils.extent_overlap_automatic" href="#bathysphere.utils.extent_overlap_automatic">extent_overlap_automatic</a></code></li>
<li><code><a title="bathysphere.utils.extent_overlap_filter" href="#bathysphere.utils.extent_overlap_filter">extent_overlap_filter</a></code></li>
<li><code><a title="bathysphere.utils.extent_overlap_iteration" href="#bathysphere.utils.extent_overlap_iteration">extent_overlap_iteration</a></code></li>
<li><code><a title="bathysphere.utils.filter_arrays" href="#bathysphere.utils.filter_arrays">filter_arrays</a></code></li>
<li><code><a title="bathysphere.utils.filter_in_range" href="#bathysphere.utils.filter_in_range">filter_in_range</a></code></li>
<li><code><a title="bathysphere.utils.generateStream" href="#bathysphere.utils.generateStream">generateStream</a></code></li>
<li><code><a title="bathysphere.utils.geo2dist" href="#bathysphere.utils.geo2dist">geo2dist</a></code></li>
<li><code><a title="bathysphere.utils.geom_shader" href="#bathysphere.utils.geom_shader">geom_shader</a></code></li>
<li><code><a title="bathysphere.utils.googleCloudSecret" href="#bathysphere.utils.googleCloudSecret">googleCloudSecret</a></code></li>
<li><code><a title="bathysphere.utils.hull_contains" href="#bathysphere.utils.hull_contains">hull_contains</a></code></li>
<li><code><a title="bathysphere.utils.hull_overlap" href="#bathysphere.utils.hull_overlap">hull_overlap</a></code></li>
<li><code><a title="bathysphere.utils.identity" href="#bathysphere.utils.identity">identity</a></code></li>
<li><code><a title="bathysphere.utils.image2arrays" href="#bathysphere.utils.image2arrays">image2arrays</a></code></li>
<li><code><a title="bathysphere.utils.image_to_masked" href="#bathysphere.utils.image_to_masked">image_to_masked</a></code></li>
<li><code><a title="bathysphere.utils.interp1d" href="#bathysphere.utils.interp1d">interp1d</a></code></li>
<li><code><a title="bathysphere.utils.interp1d_lin" href="#bathysphere.utils.interp1d_lin">interp1d_lin</a></code></li>
<li><code><a title="bathysphere.utils.interp2d_nearest" href="#bathysphere.utils.interp2d_nearest">interp2d_nearest</a></code></li>
<li><code><a title="bathysphere.utils.interp2d_tri" href="#bathysphere.utils.interp2d_tri">interp2d_tri</a></code></li>
<li><code><a title="bathysphere.utils.interp2d_uv" href="#bathysphere.utils.interp2d_uv">interp2d_uv</a></code></li>
<li><code><a title="bathysphere.utils.interp3d_slice" href="#bathysphere.utils.interp3d_slice">interp3d_slice</a></code></li>
<li><code><a title="bathysphere.utils.interp3d_tri" href="#bathysphere.utils.interp3d_tri">interp3d_tri</a></code></li>
<li><code><a title="bathysphere.utils.join" href="#bathysphere.utils.join">join</a></code></li>
<li><code><a title="bathysphere.utils.landsat_sst_regression" href="#bathysphere.utils.landsat_sst_regression">landsat_sst_regression</a></code></li>
<li><code><a title="bathysphere.utils.lin_transform" href="#bathysphere.utils.lin_transform">lin_transform</a></code></li>
<li><code><a title="bathysphere.utils.linear_regression_predict" href="#bathysphere.utils.linear_regression_predict">linear_regression_predict</a></code></li>
<li><code><a title="bathysphere.utils.linear_regression_train" href="#bathysphere.utils.linear_regression_train">linear_regression_train</a></code></li>
<li><code><a title="bathysphere.utils.loadAppConfig" href="#bathysphere.utils.loadAppConfig">loadAppConfig</a></code></li>
<li><code><a title="bathysphere.utils.mask" href="#bathysphere.utils.mask">mask</a></code></li>
<li><code><a title="bathysphere.utils.multi_polygon_crop" href="#bathysphere.utils.multi_polygon_crop">multi_polygon_crop</a></code></li>
<li><code><a title="bathysphere.utils.multi_polygon_cull" href="#bathysphere.utils.multi_polygon_cull">multi_polygon_cull</a></code></li>
<li><code><a title="bathysphere.utils.multiply" href="#bathysphere.utils.multiply">multiply</a></code></li>
<li><code><a title="bathysphere.utils.nan_mask" href="#bathysphere.utils.nan_mask">nan_mask</a></code></li>
<li><code><a title="bathysphere.utils.normal" href="#bathysphere.utils.normal">normal</a></code></li>
<li><code><a title="bathysphere.utils.parsePostgresValueIn" href="#bathysphere.utils.parsePostgresValueIn">parsePostgresValueIn</a></code></li>
<li><code><a title="bathysphere.utils.parsePostgresValueOut" href="#bathysphere.utils.parsePostgresValueOut">parsePostgresValueOut</a></code></li>
<li><code><a title="bathysphere.utils.partition_points_by_shape" href="#bathysphere.utils.partition_points_by_shape">partition_points_by_shape</a></code></li>
<li><code><a title="bathysphere.utils.pix2utm" href="#bathysphere.utils.pix2utm">pix2utm</a></code></li>
<li><code><a title="bathysphere.utils.pixel_area" href="#bathysphere.utils.pixel_area">pixel_area</a></code></li>
<li><code><a title="bathysphere.utils.points_in_path" href="#bathysphere.utils.points_in_path">points_in_path</a></code></li>
<li><code><a title="bathysphere.utils.polygon_area" href="#bathysphere.utils.polygon_area">polygon_area</a></code></li>
<li><code><a title="bathysphere.utils.project" href="#bathysphere.utils.project">project</a></code></li>
<li><code><a title="bathysphere.utils.raster2mesh" href="#bathysphere.utils.raster2mesh">raster2mesh</a></code></li>
<li><code><a title="bathysphere.utils.report_buoy_data" href="#bathysphere.utils.report_buoy_data">report_buoy_data</a></code></li>
<li><code><a title="bathysphere.utils.resolveTaskTree" href="#bathysphere.utils.resolveTaskTree">resolveTaskTree</a></code></li>
<li><code><a title="bathysphere.utils.response" href="#bathysphere.utils.response">response</a></code></li>
<li><code><a title="bathysphere.utils.rk4" href="#bathysphere.utils.rk4">rk4</a></code></li>
<li><code><a title="bathysphere.utils.rotate" href="#bathysphere.utils.rotate">rotate</a></code></li>
<li><code><a title="bathysphere.utils.shapefile" href="#bathysphere.utils.shapefile">shapefile</a></code></li>
<li><code><a title="bathysphere.utils.spherical_nearest_neighbor" href="#bathysphere.utils.spherical_nearest_neighbor">spherical_nearest_neighbor</a></code></li>
<li><code><a title="bathysphere.utils.subset" href="#bathysphere.utils.subset">subset</a></code></li>
<li><code><a title="bathysphere.utils.synchronous" href="#bathysphere.utils.synchronous">synchronous</a></code></li>
<li><code><a title="bathysphere.utils.xye" href="#bathysphere.utils.xye">xye</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>
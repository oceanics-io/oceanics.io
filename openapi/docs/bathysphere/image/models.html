<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>bathysphere.image.models API documentation</title>
<meta name="description" content="Image module models encapulate methods for visualing spatiotemporal data." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bathysphere.image.models</code></h1>
</header>
<section id="section-intro">
<p>Image module models encapulate methods for visualing spatiotemporal data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># pylint: disable=bad-continuation,redefined-builtin,invalid-name,wrong-import-position,arguments-differ
&#34;&#34;&#34;
Image module models encapulate methods for visualing spatiotemporal data.
&#34;&#34;&#34;
from __future__ import annotations
from io import BytesIO
from typing import Any
from datetime import datetime
from itertools import repeat

from matplotlib import use

use(&#34;agg&#34;)  # this has to come first
from matplotlib import rc
from matplotlib.pyplot import subplots, subplots_adjust
from matplotlib.ticker import MultipleLocator, FormatStrFormatter
from matplotlib.patches import Polygon
from matplotlib.dates import DateFormatter, MonthLocator, DayLocator
from numpy import (
    array,
    arange,
    ceil,
    hstack,
    isnan,
    max,
    min,
)


class View:
    &#34;&#34;&#34;
    Views are abstract implementations of plotting contexts, which
    are extended by Spatial and Time
    &#34;&#34;&#34;

    count = 0

    def __init__(self, style, extent=None):
        # type: (dict, (float,)) -&gt; View
        &#34;&#34;&#34;
        Setup and return figure and axis instances
        &#34;&#34;&#34;
        rc(&#34;text&#34;, usetex=False)
        # rc(&#34;font&#34;, **{&#34;family&#34;: &#34;sans-serif&#34;, &#34;sans-serif&#34;: [&#34;Arial&#34;]})
        rc(&#34;mathtext&#34;, default=&#34;sf&#34;)
        rc(&#34;lines&#34;, markeredgewidth=1, linewidth=style[&#34;line&#34;])
        rc(&#34;axes&#34;, labelsize=style[&#34;text&#34;], linewidth=(style[&#34;line&#34;] + 1) // 2)
        rc(&#34;xtick&#34;, labelsize=style[&#34;text&#34;])
        rc(&#34;ytick&#34;, labelsize=style[&#34;text&#34;])
        rc(&#34;xtick.major&#34;, pad=5)
        rc(&#34;ytick.major&#34;, pad=5)

        self.style = style
        self.extent = extent
        self.fig, self.ax = subplots(
            facecolor=style[&#34;bg&#34;], figsize=(style[&#34;width&#34;], style[&#34;height&#34;])
        )
        padding = style[&#34;padding&#34;]
        subplots_adjust(
            left=padding[0], bottom=padding[1], right=1 - padding[2], top=1 - padding[3]
        )

    def format(self, bg: str, contrast: str, **kwargs):
        &#34;&#34;&#34;
        Setup color styles for figure
        &#34;&#34;&#34;
        self.ax.patch.set_facecolor(bg)  # background colors
        self.ax.edgecolor = contrast  # plotting area border
        self.format_axis(&#34;x&#34;, contrast, **kwargs)
        self.format_axis(&#34;y&#34;, contrast, **kwargs)

    def format_axis(
        self, axis: str, contrast: str, label: str, grid: bool, **kwargs: dict
    ):
        &#34;&#34;&#34;
        Style the plotting area
        &#34;&#34;&#34;
        if axis.lower() == &#34;x&#34;:
            apply = self.ax.xaxis
            spines = (&#34;left&#34;, &#34;right&#34;)
        elif axis.lower() == &#34;y&#34;:
            apply = self.ax.yaxis
            spines = (&#34;top&#34;, &#34;bottom&#34;)
        else:
            raise ValueError

        apply.label.set_color(label)
        self.ax.tick_params(axis=axis.lower(), colors=label)
        for each in spines:
            self.ax.spines[each].set_color(contrast)
        apply.grid(grid)

    def pre_push(self):
        &#34;&#34;&#34;
        Convenience method for just-in-time formatting of image
        appearance before saving
        &#34;&#34;&#34;
        self.fig.canvas.draw()
        self.format(**self.style)
        self.ax.set_frame_on(True)

    def push(
        self, encoding: str = &#34;png&#34;, transparent: bool = False, **kwargs: dict
    ) -&gt; BytesIO:
        &#34;&#34;&#34;
        Create and save the file buffer
        &#34;&#34;&#34;
        buffer = BytesIO()
        self.fig.savefig(buffer, format=encoding, transparent=transparent, **kwargs)
        buffer.seek(0)
        return buffer

    def legend(self, loc: str = &#34;best&#34;, fc: str = &#34;none&#34;, ec: str = &#34;none&#34;) -&gt; None:
        &#34;&#34;&#34;
        Format figure legend

        Kwargs:
            loc, str -- location on plotting area
            fc, str/arr -- string or RGBA color for face
            ec, str/arr -- string or RGBA color for edges

        Returns: matplotlib legend object
        &#34;&#34;&#34;
        legend = self.ax.legend(loc=loc)
        frame = legend.get_frame()
        frame.set_facecolor(fc)
        frame.set_edgecolor(ec)

        for text in legend.get_texts():
            text.set_color(self.style[&#34;contrast&#34;])


class Time(View):
    &#34;&#34;&#34;Special case of view for time series data&#34;&#34;&#34;

    def _envelope(
        self, time: array, mean: array = None, deviation: array = None, **kwargs,
    ):
        # type: (array, array, array, str, str, int) -&gt; None
        &#34;&#34;&#34;
        Add envelope to time series plot
        &#34;&#34;&#34;
        return self.ax.fill_between(
            time,
            mean + deviation,
            mean - deviation,
            facecolor=kwargs.get(&#34;facecolor&#34;) or self.style[&#34;face&#34;],
            edgecolor=kwargs.get(&#34;edgecolor&#34;) or &#34;none&#34;,
            zorder=kwargs.get(&#34;zorder&#34;) or 3,
        )

    def __fmt_time_axis(self, label, ticks, dates=False):
        # type: (str, int or float, bool) -&gt; None
        &#34;&#34;&#34;
        Format axes for X,Y plot similar to time series

        Kwargs:
            labs, string[] :: labels for axes
            locs, int[] :: spacing of ticks on axes
        &#34;&#34;&#34;
        if self.extent is not None:
            self.ax.set_xlim(*self.extent[:2])

        self.ax.set_xlabel(label)
        if ticks is not None:
            if dates:
                self.ax.xaxis.set_major_locator(
                    MonthLocator() if ticks &gt;= 30 else DayLocator()
                )

                self.ax.xaxis.set_major_formatter(
                    DateFormatter(&#34;%m/%y&#34;) if ticks &gt;= 30 else DateFormatter(&#34;%m/%d&#34;)
                )

            else:
                self.ax.xaxis.set_major_locator(MultipleLocator(ticks))

    def __fmt_y_axis(self, label, ticks):
        # type: (Spatial, str, float) -&gt; None
        &#34;&#34;&#34;
        Format axes for X,Y plot similar to time series

        Kwargs:
            labs, string[] :: labels for axes
            locs, int[] :: spacing of ticks on axes
        &#34;&#34;&#34;
        if self.extent is not None:
            self.ax.set_ylim(*self.extent[2:4])
        self.ax.set_ylabel(label)
        if ticks is not None:
            self.ax.yaxis.set_major_locator(MultipleLocator(ticks))

    def plot(
        self, time, series, label: str = &#34;Unnamed&#34;, scatter: bool = True, **kwargs: dict
    ):
        &#34;&#34;&#34;Draw times series as scatter plot&#34;&#34;&#34;
        kwargs = {
            &#34;color&#34;: self.style[&#34;colors&#34;][self.count % len(self.style[&#34;colors&#34;])],
            &#34;label&#34;: label,
            &#34;alpha&#34;: self.style[&#34;alpha&#34;],
            **kwargs,
        }
        if scatter:
            kwargs[&#34;s&#34;] = self.style[&#34;marker&#34;]

        (self.ax.scatter if scatter else self.ax.plot)(time, series, **kwargs)
        self.count += 1

    def coverage(
        self, timestamps: [datetime], color: str = None, bins: int = 366
    ) -&gt; None:

        &#34;&#34;&#34;
        Render histogram of calendar coverage
        &#34;&#34;&#34;
        self.ax.hist(
            timestamps,
            bins=arange(bins + 1),
            facecolor=color if color else self.style[&#34;contrast&#34;],
        )

    def frequency(self, datastream: Any, bins: int = 10, **kwargs: dict) -&gt; None:
        &#34;&#34;&#34;
        render histogram of value distribution
        &#34;&#34;&#34;
        if isinstance(datastream, tuple):
            x = datastream
            datastream = hstack(datastream)
        else:
            x = tuple(filter(lambda ob: not isnan(ob), datastream))

        lower = kwargs.get(&#34;lower&#34;, min(datastream))
        span = kwargs.get(&#34;upper&#34;, max(datastream)) - lower

        return self.ax.hist(
            x=x,
            bins=tuple(span * arange(bins + 1) / bins - lower),
            facecolor=kwargs.get(&#34;color&#34;, self.style[&#34;contrast&#34;]),
        )

    def push(
        self,
        ylab: str = None,
        yloc: int or float = 10,
        xlab: str = &#34;Date&#34;,
        xloc: int or float = 30,
        legend: bool = True,
        title: str = None,
        rescale: tuple = None,
    ) -&gt; BytesIO:
        &#34;&#34;&#34;
        Script figure file output

        Kwargs:
            filename :: full path for file output
            ylab :: Y-axis label
            yloc :: Y-axis tick placement
            geo :: is a map
        &#34;&#34;&#34;
        self.pre_push()
        if self.extent is None:
            self.ax.autoscale()

        self.__fmt_time_axis(xlab, ticks=xloc)
        self.__fmt_y_axis(ylab, ticks=yloc)

        # self.fig.tight_layout()
        for tick in self.ax.get_xticklabels():
            tick.set_rotation(60)
        if legend:
            self.legend(loc=&#34;best&#34;, fc=&#34;none&#34;, ec=&#34;none&#34;)
        if title is not None:
            self.ax.set_title(title)

        if rescale is not None:
            y_vals = self.ax.get_yticks()
            self.ax.set_yticklabels((int(ceil(v * rescale[0])) for v in y_vals))

        return super().push(
            edgecolor=self.style[&#34;bg&#34;],
            dpi=self.style[&#34;dpi&#34;],
            facecolor=self.style[&#34;bg&#34;],
        )


class Spatial(View):
    &#34;&#34;&#34;
    Special case of View that implements mapping capabilties
    &#34;&#34;&#34;

    def push(self, encoding=&#34;png&#34;, transparent=False, **kwargs):
        # type: (str, bool, dict) -&gt; BytesIO
        &#34;&#34;&#34;
        Write figure as bathysphere_functions_image to binary output buffer
        &#34;&#34;&#34;
        self.pre_push()
        self.ax.axis(&#34;equal&#34;)
        self.ax.set_xlabel(kwargs.get(&#34;xlabel&#34;, &#34;x&#34;))
        self.ax.set_ylabel(kwargs.get(&#34;ylabel&#34;, &#34;y&#34;))
        if self.extent is not None:
            self.ax.set_xlim(*self.extent[:2])
            self.ax.set_ylim(*self.extent[2:4])
            dx = self.extent[1] - self.extent[0]
            dy = self.extent[3] - self.extent[2]
            inc = min((dx, dy)) / 4
            if inc &lt; 1.0:
                inc = int(inc * 10) / 10
            else:
                inc = int(inc)

            for axis in (self.ax.xaxis, self.ax.yaxis):
                axis.set_major_formatter(FormatStrFormatter(&#34;%.01f&#34;))
                axis.set_major_locator(MultipleLocator(inc))

        self.fig.tight_layout()

        return super().push(
            encoding,
            transparent,
            edgecolor=self.style[&#34;contrast&#34;],
            dpi=self.style[&#34;dpi&#34;],
            fc=[0, 0, 0, 0] if transparent else self.style[&#34;bg&#34;],
            bbox_inches=&#34;tight&#34;,
        )

    def points(self, xy, **kwargs):
        # type: (array, dict) -&gt; None
        &#34;&#34;&#34;
        Add collection of identical points to figure axis
        &#34;&#34;&#34;

        return self.ax.scatter(
            xy[:, 0],
            xy[:, 1],
            s=kwargs.get(&#34;marker&#34;, self.style[&#34;marker&#34;]),
            color=kwargs.get(&#34;color&#34;, self.style[&#34;flag&#34;]),
            alpha=kwargs.get(&#34;alpha&#34;, self.style[&#34;alpha&#34;]),
            label=kwargs.get(&#34;label&#34;, self.style[&#34;label&#34;]),
        )

    def bbox(self, ext: array, **kwargs: dict):
        &#34;&#34;&#34;
        Add extent as styled Polygon
        &#34;&#34;&#34;
        e = ext
        xy = array([[e[0], e[2]], [e[1], e[2]], [e[1], e[3]], [e[0], e[3]]])
        self.shape(xy, **kwargs)

    def topology(
        self, vertex_array: array, topology: array, z: str, **kwargs: dict,
    ) -&gt; None:
        &#34;&#34;&#34;
        Add triangular mesh to figure axis
        &#34;&#34;&#34;

        self.ax.tripcolor(
            *vertex_array,
            topology,
            z,
            cmap=kwargs.pop(&#34;cmap&#34;) or &#34;binary_r&#34;,
            shading=kwargs.pop(&#34;shading&#34;) or &#34;gouraud&#34;,
            edgecolor=kwargs.pop(&#34;edgecolor&#34;) or &#34;none&#34;,
            vmin=kwargs.pop(&#34;vmin&#34;) or z.min(),
            vmax=kwargs.pop(&#34;vmax&#34;) or z.max(),
            **kwargs,
        )

    def draw(
        self: Spatial, 
        data: dict
    ) -&gt; Spatial:
        &#34;&#34;&#34;
        Image of spatial entities. Two formats are accepted. 
        
        Points and Polygons must be given in GeoJSON formats. 
        These are enclosed as a list of Features withing a
        FeatureCollection. 
        
        Raster images, which may be remote sensing data, or actual images,
        are given as external references or hex strings (future). 

        Images are drawn first, then polygons, then points. 
        
        &#34;&#34;&#34;

        collection = data.get(&#34;FeatureCollection&#34;, None)
        images = data.get(&#34;Images&#34;, ())

        if images:
            def composite(imageTuple):
                image, extent = imageTuple
                self.ax.imshow(
                    image, extent=extent, interpolation=self.style[&#34;imageInterp&#34;]
                )
            _ = tuple(map(composite, images))

        if collection:
            features = collection.features
            _ = tuple(
                map(
                    lambda xy, kwargs: self.ax.add_patch(Polygon(xy.geometry[&#34;coordinates&#34;], **kwargs)),
                    filter(lambda x: x.geometry[&#34;type&#34;] == &#34;Polygon&#34;, features),
                    repeat({&#34;edgecolor&#34;: &#34;black&#34;, &#34;facecolor&#34;: &#34;none&#34;}),
                )
            )

            _ = tuple(
                map(
                    self.points, 
                    filter(lambda x: x.geometry[&#34;type&#34;] == &#34;Point&#34;, features)
                )
            )
    
        return self</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="bathysphere.image.models.Spatial"><code class="flex name class">
<span>class <span class="ident">Spatial</span></span>
<span>(</span><span>style, extent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Special case of View that implements mapping capabilties</p>
<p>Setup and return figure and axis instances</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spatial(View):
    &#34;&#34;&#34;
    Special case of View that implements mapping capabilties
    &#34;&#34;&#34;

    def push(self, encoding=&#34;png&#34;, transparent=False, **kwargs):
        # type: (str, bool, dict) -&gt; BytesIO
        &#34;&#34;&#34;
        Write figure as bathysphere_functions_image to binary output buffer
        &#34;&#34;&#34;
        self.pre_push()
        self.ax.axis(&#34;equal&#34;)
        self.ax.set_xlabel(kwargs.get(&#34;xlabel&#34;, &#34;x&#34;))
        self.ax.set_ylabel(kwargs.get(&#34;ylabel&#34;, &#34;y&#34;))
        if self.extent is not None:
            self.ax.set_xlim(*self.extent[:2])
            self.ax.set_ylim(*self.extent[2:4])
            dx = self.extent[1] - self.extent[0]
            dy = self.extent[3] - self.extent[2]
            inc = min((dx, dy)) / 4
            if inc &lt; 1.0:
                inc = int(inc * 10) / 10
            else:
                inc = int(inc)

            for axis in (self.ax.xaxis, self.ax.yaxis):
                axis.set_major_formatter(FormatStrFormatter(&#34;%.01f&#34;))
                axis.set_major_locator(MultipleLocator(inc))

        self.fig.tight_layout()

        return super().push(
            encoding,
            transparent,
            edgecolor=self.style[&#34;contrast&#34;],
            dpi=self.style[&#34;dpi&#34;],
            fc=[0, 0, 0, 0] if transparent else self.style[&#34;bg&#34;],
            bbox_inches=&#34;tight&#34;,
        )

    def points(self, xy, **kwargs):
        # type: (array, dict) -&gt; None
        &#34;&#34;&#34;
        Add collection of identical points to figure axis
        &#34;&#34;&#34;

        return self.ax.scatter(
            xy[:, 0],
            xy[:, 1],
            s=kwargs.get(&#34;marker&#34;, self.style[&#34;marker&#34;]),
            color=kwargs.get(&#34;color&#34;, self.style[&#34;flag&#34;]),
            alpha=kwargs.get(&#34;alpha&#34;, self.style[&#34;alpha&#34;]),
            label=kwargs.get(&#34;label&#34;, self.style[&#34;label&#34;]),
        )

    def bbox(self, ext: array, **kwargs: dict):
        &#34;&#34;&#34;
        Add extent as styled Polygon
        &#34;&#34;&#34;
        e = ext
        xy = array([[e[0], e[2]], [e[1], e[2]], [e[1], e[3]], [e[0], e[3]]])
        self.shape(xy, **kwargs)

    def topology(
        self, vertex_array: array, topology: array, z: str, **kwargs: dict,
    ) -&gt; None:
        &#34;&#34;&#34;
        Add triangular mesh to figure axis
        &#34;&#34;&#34;

        self.ax.tripcolor(
            *vertex_array,
            topology,
            z,
            cmap=kwargs.pop(&#34;cmap&#34;) or &#34;binary_r&#34;,
            shading=kwargs.pop(&#34;shading&#34;) or &#34;gouraud&#34;,
            edgecolor=kwargs.pop(&#34;edgecolor&#34;) or &#34;none&#34;,
            vmin=kwargs.pop(&#34;vmin&#34;) or z.min(),
            vmax=kwargs.pop(&#34;vmax&#34;) or z.max(),
            **kwargs,
        )

    def draw(
        self: Spatial, 
        data: dict
    ) -&gt; Spatial:
        &#34;&#34;&#34;
        Image of spatial entities. Two formats are accepted. 
        
        Points and Polygons must be given in GeoJSON formats. 
        These are enclosed as a list of Features withing a
        FeatureCollection. 
        
        Raster images, which may be remote sensing data, or actual images,
        are given as external references or hex strings (future). 

        Images are drawn first, then polygons, then points. 
        
        &#34;&#34;&#34;

        collection = data.get(&#34;FeatureCollection&#34;, None)
        images = data.get(&#34;Images&#34;, ())

        if images:
            def composite(imageTuple):
                image, extent = imageTuple
                self.ax.imshow(
                    image, extent=extent, interpolation=self.style[&#34;imageInterp&#34;]
                )
            _ = tuple(map(composite, images))

        if collection:
            features = collection.features
            _ = tuple(
                map(
                    lambda xy, kwargs: self.ax.add_patch(Polygon(xy.geometry[&#34;coordinates&#34;], **kwargs)),
                    filter(lambda x: x.geometry[&#34;type&#34;] == &#34;Polygon&#34;, features),
                    repeat({&#34;edgecolor&#34;: &#34;black&#34;, &#34;facecolor&#34;: &#34;none&#34;}),
                )
            )

            _ = tuple(
                map(
                    self.points, 
                    filter(lambda x: x.geometry[&#34;type&#34;] == &#34;Point&#34;, features)
                )
            )
    
        return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="bathysphere.image.models.View" href="#bathysphere.image.models.View">View</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bathysphere.image.models.Spatial.bbox"><code class="name flex">
<span>def <span class="ident">bbox</span></span>(<span>self, ext: array, **kwargs: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Add extent as styled Polygon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bbox(self, ext: array, **kwargs: dict):
    &#34;&#34;&#34;
    Add extent as styled Polygon
    &#34;&#34;&#34;
    e = ext
    xy = array([[e[0], e[2]], [e[1], e[2]], [e[1], e[3]], [e[0], e[3]]])
    self.shape(xy, **kwargs)</code></pre>
</details>
</dd>
<dt id="bathysphere.image.models.Spatial.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self: Spatial, data: dict) -> <a title="bathysphere.image.models.Spatial" href="#bathysphere.image.models.Spatial">Spatial</a></span>
</code></dt>
<dd>
<div class="desc"><p>Image of spatial entities. Two formats are accepted. </p>
<p>Points and Polygons must be given in GeoJSON formats.
These are enclosed as a list of Features withing a
FeatureCollection. </p>
<p>Raster images, which may be remote sensing data, or actual images,
are given as external references or hex strings (future). </p>
<p>Images are drawn first, then polygons, then points.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(
    self: Spatial, 
    data: dict
) -&gt; Spatial:
    &#34;&#34;&#34;
    Image of spatial entities. Two formats are accepted. 
    
    Points and Polygons must be given in GeoJSON formats. 
    These are enclosed as a list of Features withing a
    FeatureCollection. 
    
    Raster images, which may be remote sensing data, or actual images,
    are given as external references or hex strings (future). 

    Images are drawn first, then polygons, then points. 
    
    &#34;&#34;&#34;

    collection = data.get(&#34;FeatureCollection&#34;, None)
    images = data.get(&#34;Images&#34;, ())

    if images:
        def composite(imageTuple):
            image, extent = imageTuple
            self.ax.imshow(
                image, extent=extent, interpolation=self.style[&#34;imageInterp&#34;]
            )
        _ = tuple(map(composite, images))

    if collection:
        features = collection.features
        _ = tuple(
            map(
                lambda xy, kwargs: self.ax.add_patch(Polygon(xy.geometry[&#34;coordinates&#34;], **kwargs)),
                filter(lambda x: x.geometry[&#34;type&#34;] == &#34;Polygon&#34;, features),
                repeat({&#34;edgecolor&#34;: &#34;black&#34;, &#34;facecolor&#34;: &#34;none&#34;}),
            )
        )

        _ = tuple(
            map(
                self.points, 
                filter(lambda x: x.geometry[&#34;type&#34;] == &#34;Point&#34;, features)
            )
        )

    return self</code></pre>
</details>
</dd>
<dt id="bathysphere.image.models.Spatial.points"><code class="name flex">
<span>def <span class="ident">points</span></span>(<span>self, xy, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add collection of identical points to figure axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def points(self, xy, **kwargs):
    # type: (array, dict) -&gt; None
    &#34;&#34;&#34;
    Add collection of identical points to figure axis
    &#34;&#34;&#34;

    return self.ax.scatter(
        xy[:, 0],
        xy[:, 1],
        s=kwargs.get(&#34;marker&#34;, self.style[&#34;marker&#34;]),
        color=kwargs.get(&#34;color&#34;, self.style[&#34;flag&#34;]),
        alpha=kwargs.get(&#34;alpha&#34;, self.style[&#34;alpha&#34;]),
        label=kwargs.get(&#34;label&#34;, self.style[&#34;label&#34;]),
    )</code></pre>
</details>
</dd>
<dt id="bathysphere.image.models.Spatial.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, encoding='png', transparent=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Write figure as bathysphere_functions_image to binary output buffer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, encoding=&#34;png&#34;, transparent=False, **kwargs):
    # type: (str, bool, dict) -&gt; BytesIO
    &#34;&#34;&#34;
    Write figure as bathysphere_functions_image to binary output buffer
    &#34;&#34;&#34;
    self.pre_push()
    self.ax.axis(&#34;equal&#34;)
    self.ax.set_xlabel(kwargs.get(&#34;xlabel&#34;, &#34;x&#34;))
    self.ax.set_ylabel(kwargs.get(&#34;ylabel&#34;, &#34;y&#34;))
    if self.extent is not None:
        self.ax.set_xlim(*self.extent[:2])
        self.ax.set_ylim(*self.extent[2:4])
        dx = self.extent[1] - self.extent[0]
        dy = self.extent[3] - self.extent[2]
        inc = min((dx, dy)) / 4
        if inc &lt; 1.0:
            inc = int(inc * 10) / 10
        else:
            inc = int(inc)

        for axis in (self.ax.xaxis, self.ax.yaxis):
            axis.set_major_formatter(FormatStrFormatter(&#34;%.01f&#34;))
            axis.set_major_locator(MultipleLocator(inc))

    self.fig.tight_layout()

    return super().push(
        encoding,
        transparent,
        edgecolor=self.style[&#34;contrast&#34;],
        dpi=self.style[&#34;dpi&#34;],
        fc=[0, 0, 0, 0] if transparent else self.style[&#34;bg&#34;],
        bbox_inches=&#34;tight&#34;,
    )</code></pre>
</details>
</dd>
<dt id="bathysphere.image.models.Spatial.topology"><code class="name flex">
<span>def <span class="ident">topology</span></span>(<span>self, vertex_array: array, topology: array, z: str, **kwargs: dict) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add triangular mesh to figure axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def topology(
    self, vertex_array: array, topology: array, z: str, **kwargs: dict,
) -&gt; None:
    &#34;&#34;&#34;
    Add triangular mesh to figure axis
    &#34;&#34;&#34;

    self.ax.tripcolor(
        *vertex_array,
        topology,
        z,
        cmap=kwargs.pop(&#34;cmap&#34;) or &#34;binary_r&#34;,
        shading=kwargs.pop(&#34;shading&#34;) or &#34;gouraud&#34;,
        edgecolor=kwargs.pop(&#34;edgecolor&#34;) or &#34;none&#34;,
        vmin=kwargs.pop(&#34;vmin&#34;) or z.min(),
        vmax=kwargs.pop(&#34;vmax&#34;) or z.max(),
        **kwargs,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="bathysphere.image.models.View" href="#bathysphere.image.models.View">View</a></b></code>:
<ul class="hlist">
<li><code><a title="bathysphere.image.models.View.format" href="#bathysphere.image.models.View.format">format</a></code></li>
<li><code><a title="bathysphere.image.models.View.format_axis" href="#bathysphere.image.models.View.format_axis">format_axis</a></code></li>
<li><code><a title="bathysphere.image.models.View.legend" href="#bathysphere.image.models.View.legend">legend</a></code></li>
<li><code><a title="bathysphere.image.models.View.pre_push" href="#bathysphere.image.models.View.pre_push">pre_push</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="bathysphere.image.models.Time"><code class="flex name class">
<span>class <span class="ident">Time</span></span>
<span>(</span><span>style, extent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Special case of view for time series data</p>
<p>Setup and return figure and axis instances</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Time(View):
    &#34;&#34;&#34;Special case of view for time series data&#34;&#34;&#34;

    def _envelope(
        self, time: array, mean: array = None, deviation: array = None, **kwargs,
    ):
        # type: (array, array, array, str, str, int) -&gt; None
        &#34;&#34;&#34;
        Add envelope to time series plot
        &#34;&#34;&#34;
        return self.ax.fill_between(
            time,
            mean + deviation,
            mean - deviation,
            facecolor=kwargs.get(&#34;facecolor&#34;) or self.style[&#34;face&#34;],
            edgecolor=kwargs.get(&#34;edgecolor&#34;) or &#34;none&#34;,
            zorder=kwargs.get(&#34;zorder&#34;) or 3,
        )

    def __fmt_time_axis(self, label, ticks, dates=False):
        # type: (str, int or float, bool) -&gt; None
        &#34;&#34;&#34;
        Format axes for X,Y plot similar to time series

        Kwargs:
            labs, string[] :: labels for axes
            locs, int[] :: spacing of ticks on axes
        &#34;&#34;&#34;
        if self.extent is not None:
            self.ax.set_xlim(*self.extent[:2])

        self.ax.set_xlabel(label)
        if ticks is not None:
            if dates:
                self.ax.xaxis.set_major_locator(
                    MonthLocator() if ticks &gt;= 30 else DayLocator()
                )

                self.ax.xaxis.set_major_formatter(
                    DateFormatter(&#34;%m/%y&#34;) if ticks &gt;= 30 else DateFormatter(&#34;%m/%d&#34;)
                )

            else:
                self.ax.xaxis.set_major_locator(MultipleLocator(ticks))

    def __fmt_y_axis(self, label, ticks):
        # type: (Spatial, str, float) -&gt; None
        &#34;&#34;&#34;
        Format axes for X,Y plot similar to time series

        Kwargs:
            labs, string[] :: labels for axes
            locs, int[] :: spacing of ticks on axes
        &#34;&#34;&#34;
        if self.extent is not None:
            self.ax.set_ylim(*self.extent[2:4])
        self.ax.set_ylabel(label)
        if ticks is not None:
            self.ax.yaxis.set_major_locator(MultipleLocator(ticks))

    def plot(
        self, time, series, label: str = &#34;Unnamed&#34;, scatter: bool = True, **kwargs: dict
    ):
        &#34;&#34;&#34;Draw times series as scatter plot&#34;&#34;&#34;
        kwargs = {
            &#34;color&#34;: self.style[&#34;colors&#34;][self.count % len(self.style[&#34;colors&#34;])],
            &#34;label&#34;: label,
            &#34;alpha&#34;: self.style[&#34;alpha&#34;],
            **kwargs,
        }
        if scatter:
            kwargs[&#34;s&#34;] = self.style[&#34;marker&#34;]

        (self.ax.scatter if scatter else self.ax.plot)(time, series, **kwargs)
        self.count += 1

    def coverage(
        self, timestamps: [datetime], color: str = None, bins: int = 366
    ) -&gt; None:

        &#34;&#34;&#34;
        Render histogram of calendar coverage
        &#34;&#34;&#34;
        self.ax.hist(
            timestamps,
            bins=arange(bins + 1),
            facecolor=color if color else self.style[&#34;contrast&#34;],
        )

    def frequency(self, datastream: Any, bins: int = 10, **kwargs: dict) -&gt; None:
        &#34;&#34;&#34;
        render histogram of value distribution
        &#34;&#34;&#34;
        if isinstance(datastream, tuple):
            x = datastream
            datastream = hstack(datastream)
        else:
            x = tuple(filter(lambda ob: not isnan(ob), datastream))

        lower = kwargs.get(&#34;lower&#34;, min(datastream))
        span = kwargs.get(&#34;upper&#34;, max(datastream)) - lower

        return self.ax.hist(
            x=x,
            bins=tuple(span * arange(bins + 1) / bins - lower),
            facecolor=kwargs.get(&#34;color&#34;, self.style[&#34;contrast&#34;]),
        )

    def push(
        self,
        ylab: str = None,
        yloc: int or float = 10,
        xlab: str = &#34;Date&#34;,
        xloc: int or float = 30,
        legend: bool = True,
        title: str = None,
        rescale: tuple = None,
    ) -&gt; BytesIO:
        &#34;&#34;&#34;
        Script figure file output

        Kwargs:
            filename :: full path for file output
            ylab :: Y-axis label
            yloc :: Y-axis tick placement
            geo :: is a map
        &#34;&#34;&#34;
        self.pre_push()
        if self.extent is None:
            self.ax.autoscale()

        self.__fmt_time_axis(xlab, ticks=xloc)
        self.__fmt_y_axis(ylab, ticks=yloc)

        # self.fig.tight_layout()
        for tick in self.ax.get_xticklabels():
            tick.set_rotation(60)
        if legend:
            self.legend(loc=&#34;best&#34;, fc=&#34;none&#34;, ec=&#34;none&#34;)
        if title is not None:
            self.ax.set_title(title)

        if rescale is not None:
            y_vals = self.ax.get_yticks()
            self.ax.set_yticklabels((int(ceil(v * rescale[0])) for v in y_vals))

        return super().push(
            edgecolor=self.style[&#34;bg&#34;],
            dpi=self.style[&#34;dpi&#34;],
            facecolor=self.style[&#34;bg&#34;],
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="bathysphere.image.models.View" href="#bathysphere.image.models.View">View</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bathysphere.image.models.Time.coverage"><code class="name flex">
<span>def <span class="ident">coverage</span></span>(<span>self, timestamps: [datetime], color: str = None, bins: int = 366) -> 'None'</span>
</code></dt>
<dd>
<div class="desc"><p>Render histogram of calendar coverage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coverage(
    self, timestamps: [datetime], color: str = None, bins: int = 366
) -&gt; None:

    &#34;&#34;&#34;
    Render histogram of calendar coverage
    &#34;&#34;&#34;
    self.ax.hist(
        timestamps,
        bins=arange(bins + 1),
        facecolor=color if color else self.style[&#34;contrast&#34;],
    )</code></pre>
</details>
</dd>
<dt id="bathysphere.image.models.Time.frequency"><code class="name flex">
<span>def <span class="ident">frequency</span></span>(<span>self, datastream: Any, bins: int = 10, **kwargs: dict) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>render histogram of value distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frequency(self, datastream: Any, bins: int = 10, **kwargs: dict) -&gt; None:
    &#34;&#34;&#34;
    render histogram of value distribution
    &#34;&#34;&#34;
    if isinstance(datastream, tuple):
        x = datastream
        datastream = hstack(datastream)
    else:
        x = tuple(filter(lambda ob: not isnan(ob), datastream))

    lower = kwargs.get(&#34;lower&#34;, min(datastream))
    span = kwargs.get(&#34;upper&#34;, max(datastream)) - lower

    return self.ax.hist(
        x=x,
        bins=tuple(span * arange(bins + 1) / bins - lower),
        facecolor=kwargs.get(&#34;color&#34;, self.style[&#34;contrast&#34;]),
    )</code></pre>
</details>
</dd>
<dt id="bathysphere.image.models.Time.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, time, series, label: str = 'Unnamed', scatter: bool = True, **kwargs: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw times series as scatter plot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(
    self, time, series, label: str = &#34;Unnamed&#34;, scatter: bool = True, **kwargs: dict
):
    &#34;&#34;&#34;Draw times series as scatter plot&#34;&#34;&#34;
    kwargs = {
        &#34;color&#34;: self.style[&#34;colors&#34;][self.count % len(self.style[&#34;colors&#34;])],
        &#34;label&#34;: label,
        &#34;alpha&#34;: self.style[&#34;alpha&#34;],
        **kwargs,
    }
    if scatter:
        kwargs[&#34;s&#34;] = self.style[&#34;marker&#34;]

    (self.ax.scatter if scatter else self.ax.plot)(time, series, **kwargs)
    self.count += 1</code></pre>
</details>
</dd>
<dt id="bathysphere.image.models.Time.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, ylab: str = None, yloc: int or float = 10, xlab: str = 'Date', xloc: int or float = 30, legend: bool = True, title: str = None, rescale: tuple = None) -> _io.BytesIO</span>
</code></dt>
<dd>
<div class="desc"><p>Script figure file output</p>
<h2 id="kwargs">Kwargs</h2>
<p>filename :: full path for file output
ylab :: Y-axis label
yloc :: Y-axis tick placement
geo :: is a map</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(
    self,
    ylab: str = None,
    yloc: int or float = 10,
    xlab: str = &#34;Date&#34;,
    xloc: int or float = 30,
    legend: bool = True,
    title: str = None,
    rescale: tuple = None,
) -&gt; BytesIO:
    &#34;&#34;&#34;
    Script figure file output

    Kwargs:
        filename :: full path for file output
        ylab :: Y-axis label
        yloc :: Y-axis tick placement
        geo :: is a map
    &#34;&#34;&#34;
    self.pre_push()
    if self.extent is None:
        self.ax.autoscale()

    self.__fmt_time_axis(xlab, ticks=xloc)
    self.__fmt_y_axis(ylab, ticks=yloc)

    # self.fig.tight_layout()
    for tick in self.ax.get_xticklabels():
        tick.set_rotation(60)
    if legend:
        self.legend(loc=&#34;best&#34;, fc=&#34;none&#34;, ec=&#34;none&#34;)
    if title is not None:
        self.ax.set_title(title)

    if rescale is not None:
        y_vals = self.ax.get_yticks()
        self.ax.set_yticklabels((int(ceil(v * rescale[0])) for v in y_vals))

    return super().push(
        edgecolor=self.style[&#34;bg&#34;],
        dpi=self.style[&#34;dpi&#34;],
        facecolor=self.style[&#34;bg&#34;],
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="bathysphere.image.models.View" href="#bathysphere.image.models.View">View</a></b></code>:
<ul class="hlist">
<li><code><a title="bathysphere.image.models.View.format" href="#bathysphere.image.models.View.format">format</a></code></li>
<li><code><a title="bathysphere.image.models.View.format_axis" href="#bathysphere.image.models.View.format_axis">format_axis</a></code></li>
<li><code><a title="bathysphere.image.models.View.legend" href="#bathysphere.image.models.View.legend">legend</a></code></li>
<li><code><a title="bathysphere.image.models.View.pre_push" href="#bathysphere.image.models.View.pre_push">pre_push</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="bathysphere.image.models.View"><code class="flex name class">
<span>class <span class="ident">View</span></span>
<span>(</span><span>style, extent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Views are abstract implementations of plotting contexts, which
are extended by Spatial and Time</p>
<p>Setup and return figure and axis instances</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class View:
    &#34;&#34;&#34;
    Views are abstract implementations of plotting contexts, which
    are extended by Spatial and Time
    &#34;&#34;&#34;

    count = 0

    def __init__(self, style, extent=None):
        # type: (dict, (float,)) -&gt; View
        &#34;&#34;&#34;
        Setup and return figure and axis instances
        &#34;&#34;&#34;
        rc(&#34;text&#34;, usetex=False)
        # rc(&#34;font&#34;, **{&#34;family&#34;: &#34;sans-serif&#34;, &#34;sans-serif&#34;: [&#34;Arial&#34;]})
        rc(&#34;mathtext&#34;, default=&#34;sf&#34;)
        rc(&#34;lines&#34;, markeredgewidth=1, linewidth=style[&#34;line&#34;])
        rc(&#34;axes&#34;, labelsize=style[&#34;text&#34;], linewidth=(style[&#34;line&#34;] + 1) // 2)
        rc(&#34;xtick&#34;, labelsize=style[&#34;text&#34;])
        rc(&#34;ytick&#34;, labelsize=style[&#34;text&#34;])
        rc(&#34;xtick.major&#34;, pad=5)
        rc(&#34;ytick.major&#34;, pad=5)

        self.style = style
        self.extent = extent
        self.fig, self.ax = subplots(
            facecolor=style[&#34;bg&#34;], figsize=(style[&#34;width&#34;], style[&#34;height&#34;])
        )
        padding = style[&#34;padding&#34;]
        subplots_adjust(
            left=padding[0], bottom=padding[1], right=1 - padding[2], top=1 - padding[3]
        )

    def format(self, bg: str, contrast: str, **kwargs):
        &#34;&#34;&#34;
        Setup color styles for figure
        &#34;&#34;&#34;
        self.ax.patch.set_facecolor(bg)  # background colors
        self.ax.edgecolor = contrast  # plotting area border
        self.format_axis(&#34;x&#34;, contrast, **kwargs)
        self.format_axis(&#34;y&#34;, contrast, **kwargs)

    def format_axis(
        self, axis: str, contrast: str, label: str, grid: bool, **kwargs: dict
    ):
        &#34;&#34;&#34;
        Style the plotting area
        &#34;&#34;&#34;
        if axis.lower() == &#34;x&#34;:
            apply = self.ax.xaxis
            spines = (&#34;left&#34;, &#34;right&#34;)
        elif axis.lower() == &#34;y&#34;:
            apply = self.ax.yaxis
            spines = (&#34;top&#34;, &#34;bottom&#34;)
        else:
            raise ValueError

        apply.label.set_color(label)
        self.ax.tick_params(axis=axis.lower(), colors=label)
        for each in spines:
            self.ax.spines[each].set_color(contrast)
        apply.grid(grid)

    def pre_push(self):
        &#34;&#34;&#34;
        Convenience method for just-in-time formatting of image
        appearance before saving
        &#34;&#34;&#34;
        self.fig.canvas.draw()
        self.format(**self.style)
        self.ax.set_frame_on(True)

    def push(
        self, encoding: str = &#34;png&#34;, transparent: bool = False, **kwargs: dict
    ) -&gt; BytesIO:
        &#34;&#34;&#34;
        Create and save the file buffer
        &#34;&#34;&#34;
        buffer = BytesIO()
        self.fig.savefig(buffer, format=encoding, transparent=transparent, **kwargs)
        buffer.seek(0)
        return buffer

    def legend(self, loc: str = &#34;best&#34;, fc: str = &#34;none&#34;, ec: str = &#34;none&#34;) -&gt; None:
        &#34;&#34;&#34;
        Format figure legend

        Kwargs:
            loc, str -- location on plotting area
            fc, str/arr -- string or RGBA color for face
            ec, str/arr -- string or RGBA color for edges

        Returns: matplotlib legend object
        &#34;&#34;&#34;
        legend = self.ax.legend(loc=loc)
        frame = legend.get_frame()
        frame.set_facecolor(fc)
        frame.set_edgecolor(ec)

        for text in legend.get_texts():
            text.set_color(self.style[&#34;contrast&#34;])</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bathysphere.image.models.Spatial" href="#bathysphere.image.models.Spatial">Spatial</a></li>
<li><a title="bathysphere.image.models.Time" href="#bathysphere.image.models.Time">Time</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bathysphere.image.models.View.count"><code class="name">var <span class="ident">count</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="bathysphere.image.models.View.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, bg: str, contrast: str, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Setup color styles for figure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, bg: str, contrast: str, **kwargs):
    &#34;&#34;&#34;
    Setup color styles for figure
    &#34;&#34;&#34;
    self.ax.patch.set_facecolor(bg)  # background colors
    self.ax.edgecolor = contrast  # plotting area border
    self.format_axis(&#34;x&#34;, contrast, **kwargs)
    self.format_axis(&#34;y&#34;, contrast, **kwargs)</code></pre>
</details>
</dd>
<dt id="bathysphere.image.models.View.format_axis"><code class="name flex">
<span>def <span class="ident">format_axis</span></span>(<span>self, axis: str, contrast: str, label: str, grid: bool, **kwargs: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Style the plotting area</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_axis(
    self, axis: str, contrast: str, label: str, grid: bool, **kwargs: dict
):
    &#34;&#34;&#34;
    Style the plotting area
    &#34;&#34;&#34;
    if axis.lower() == &#34;x&#34;:
        apply = self.ax.xaxis
        spines = (&#34;left&#34;, &#34;right&#34;)
    elif axis.lower() == &#34;y&#34;:
        apply = self.ax.yaxis
        spines = (&#34;top&#34;, &#34;bottom&#34;)
    else:
        raise ValueError

    apply.label.set_color(label)
    self.ax.tick_params(axis=axis.lower(), colors=label)
    for each in spines:
        self.ax.spines[each].set_color(contrast)
    apply.grid(grid)</code></pre>
</details>
</dd>
<dt id="bathysphere.image.models.View.legend"><code class="name flex">
<span>def <span class="ident">legend</span></span>(<span>self, loc: str = 'best', fc: str = 'none', ec: str = 'none') -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Format figure legend</p>
<h2 id="kwargs">Kwargs</h2>
<p>loc, str &ndash; location on plotting area
fc, str/arr &ndash; string or RGBA color for face
ec, str/arr &ndash; string or RGBA color for edges</p>
<p>Returns: matplotlib legend object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def legend(self, loc: str = &#34;best&#34;, fc: str = &#34;none&#34;, ec: str = &#34;none&#34;) -&gt; None:
    &#34;&#34;&#34;
    Format figure legend

    Kwargs:
        loc, str -- location on plotting area
        fc, str/arr -- string or RGBA color for face
        ec, str/arr -- string or RGBA color for edges

    Returns: matplotlib legend object
    &#34;&#34;&#34;
    legend = self.ax.legend(loc=loc)
    frame = legend.get_frame()
    frame.set_facecolor(fc)
    frame.set_edgecolor(ec)

    for text in legend.get_texts():
        text.set_color(self.style[&#34;contrast&#34;])</code></pre>
</details>
</dd>
<dt id="bathysphere.image.models.View.pre_push"><code class="name flex">
<span>def <span class="ident">pre_push</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience method for just-in-time formatting of image
appearance before saving</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pre_push(self):
    &#34;&#34;&#34;
    Convenience method for just-in-time formatting of image
    appearance before saving
    &#34;&#34;&#34;
    self.fig.canvas.draw()
    self.format(**self.style)
    self.ax.set_frame_on(True)</code></pre>
</details>
</dd>
<dt id="bathysphere.image.models.View.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, encoding: str = 'png', transparent: bool = False, **kwargs: dict) -> _io.BytesIO</span>
</code></dt>
<dd>
<div class="desc"><p>Create and save the file buffer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(
    self, encoding: str = &#34;png&#34;, transparent: bool = False, **kwargs: dict
) -&gt; BytesIO:
    &#34;&#34;&#34;
    Create and save the file buffer
    &#34;&#34;&#34;
    buffer = BytesIO()
    self.fig.savefig(buffer, format=encoding, transparent=transparent, **kwargs)
    buffer.seek(0)
    return buffer</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bathysphere.image" href="index.html">bathysphere.image</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="bathysphere.image.models.Spatial" href="#bathysphere.image.models.Spatial">Spatial</a></code></h4>
<ul class="">
<li><code><a title="bathysphere.image.models.Spatial.bbox" href="#bathysphere.image.models.Spatial.bbox">bbox</a></code></li>
<li><code><a title="bathysphere.image.models.Spatial.draw" href="#bathysphere.image.models.Spatial.draw">draw</a></code></li>
<li><code><a title="bathysphere.image.models.Spatial.points" href="#bathysphere.image.models.Spatial.points">points</a></code></li>
<li><code><a title="bathysphere.image.models.Spatial.push" href="#bathysphere.image.models.Spatial.push">push</a></code></li>
<li><code><a title="bathysphere.image.models.Spatial.topology" href="#bathysphere.image.models.Spatial.topology">topology</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.image.models.Time" href="#bathysphere.image.models.Time">Time</a></code></h4>
<ul class="">
<li><code><a title="bathysphere.image.models.Time.coverage" href="#bathysphere.image.models.Time.coverage">coverage</a></code></li>
<li><code><a title="bathysphere.image.models.Time.frequency" href="#bathysphere.image.models.Time.frequency">frequency</a></code></li>
<li><code><a title="bathysphere.image.models.Time.plot" href="#bathysphere.image.models.Time.plot">plot</a></code></li>
<li><code><a title="bathysphere.image.models.Time.push" href="#bathysphere.image.models.Time.push">push</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bathysphere.image.models.View" href="#bathysphere.image.models.View">View</a></code></h4>
<ul class="two-column">
<li><code><a title="bathysphere.image.models.View.count" href="#bathysphere.image.models.View.count">count</a></code></li>
<li><code><a title="bathysphere.image.models.View.format" href="#bathysphere.image.models.View.format">format</a></code></li>
<li><code><a title="bathysphere.image.models.View.format_axis" href="#bathysphere.image.models.View.format_axis">format_axis</a></code></li>
<li><code><a title="bathysphere.image.models.View.legend" href="#bathysphere.image.models.View.legend">legend</a></code></li>
<li><code><a title="bathysphere.image.models.View.pre_push" href="#bathysphere.image.models.View.pre_push">pre_push</a></code></li>
<li><code><a title="bathysphere.image.models.View.push" href="#bathysphere.image.models.View.push">push</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>graph.models API documentation</title>
<meta name="description" content="The models module of the graph API contains extensions to the common
models, for storing and accessing data in a Neo4j database." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>graph.models</code></h1>
</header>
<section id="section-intro">
<p>The models module of the graph API contains extensions to the common
models, for storing and accessing data in a Neo4j database.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># pylint: disable=invalid-name,bad-continuation,protected-access,bad-whitespace
&#34;&#34;&#34;
The models module of the graph API contains extensions to the common
models, for storing and accessing data in a Neo4j database.
&#34;&#34;&#34;
from inspect import isclass
from typing import Type, Callable, Any
from types import MethodType
from datetime import datetime
from pickle import load as unpickle
from uuid import uuid4, UUID
from json import dumps

from requests import get
from neo4j import Driver
import attr

from bathysphere import models
from bathysphere.datatypes import ResponseJSON
from bathysphere.graph import (
    processKeyValueInbound,
    processKeyValueOutbound,
    executeQuery,
    polymorphic,
)


@attr.s(repr=False)
class Link:
    &#34;&#34;&#34;
    Links are the relationships between two entities.
    They are directional.
    &#34;&#34;&#34;

    _symbol: str = attr.ib(default=&#34;r&#34;)
    rank: int = attr.ib(default=None)
    uuid: UUID = attr.ib(default=None)
    props: dict = attr.ib(default=None)
    label: str = attr.ib(default=None)

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Format the Link for making a Cypher language query
        to the Neo4j graph database

        [ r:Label { &lt;key&gt;:&lt;value&gt;, &lt;key&gt;:&lt;value&gt; } ]
        &#34;&#34;&#34;
        labelStr = f&#34;:{self.label}&#34; if self.label else &#34;&#34;
        combined = {&#34;uuid&#34;: self.uuid, &#34;rank&#34;: self.rank, **(self.props or {})}
        nonNullValues = tuple(
            filter(lambda x: x, map(processKeyValueInbound, combined.items()))
        )
        pattern = (
            &#34;&#34; if len(nonNullValues) == 0 else f&#34;&#34;&#34;{{ {&#39;, &#39;.join(nonNullValues)} }}&#34;&#34;&#34;
        )
        return f&#34;[ {self._symbol}{labelStr} {pattern} ]&#34;

    @classmethod
    def drop(cls: Type, db: Driver, nodes: (Type, Type), props: dict) -&gt; None:
        &#34;&#34;&#34;
        Drop the link between two node patterns
        &#34;&#34;&#34;
        r = cls(**props)
        a, b = nodes
        cmd = f&#34;MATCH {repr(a)}-{repr(r)}-{repr(b)} DELETE {r._symbol}&#34;
        return executeQuery(db, lambda tx: tx.run(cmd), read_only=False)

    @polymorphic
    def join(
        self: Type,
        db: Driver,
        nodes: (Any, Any),
        props: dict = None,
        echo: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;
        Create a link between two node patterns. This uses the `polymorphic` decorator
        to work on either classes or isntances.

        If calling as an instance of `Link`, no addtional properties should be supplied.
        Otherwise, a `Link` will be constructed from the `props` arguement.

        There must be exactly 2 entities to link. In the future this will support N-body
        symmetric linking.
        &#34;&#34;&#34;
        if isclass(self):
            L = self(**(props or {}))  # pylint: disable=not-callable
        elif props is not None and len(props) &gt; 0:
            raise ValueError(
                &#34;No additional props allowed when using existing Link instance.&#34;
            )
        else:
            L = self
        try:
            a, b = nodes
        except ValueError:
            raise ValueError(&#34;Join requires a tuple of exactly 2 entities.&#34;)
        if a._symbol == b._symbol:
            a._setSymbol(&#34;a&#34;)
            b._setSymbol(&#34;b&#34;)

        cmd = f&#34;MATCH {repr(a)}, {repr(b)} MERGE ({a._symbol})-{repr(L)}-&gt;({b._symbol})&#34;
        if echo:
            print(cmd)
        executeQuery(db, lambda tx: tx.run(cmd), read_only=False)

    @polymorphic
    def query(
        self: Type,
        db: Driver,
        nodes: (Any, Any),
        props: dict = None,
        result: str = &#34;labels(b)&#34;,
    ) -&gt; (Any,):
        &#34;&#34;&#34;
        Match and return the label set for connected entities.

        Increment the pageRank every time the link is traversed.
        &#34;&#34;&#34;
        if isclass(self):
            L = self(**(props or {}))  # pylint: disable=not-callable
        elif props is not None and len(props) &gt; 0:
            raise ValueError(
                &#34;No additional props allowed when using existing Link instance.&#34;
            )
        else:
            L = self
        try:
            a, b = nodes
        except ValueError:
            raise ValueError(&#34;Join requires a tuple of exactly 2 entities.&#34;)
        a._setSymbol(&#34;a&#34;)
        b._setSymbol(&#34;b&#34;)

        cmd = (
            f&#34;MATCH {repr(a)}-{repr(L)}-{repr(b)}&#34;
            f&#34;SET r.rank = r.rank + 1 &#34;
            f&#34;RETURN {result}&#34;
        )
        return executeQuery(db, lambda tx: tx.run(cmd).values(), read_only=True)


@attr.s(repr=False)
class Entity:
    &#34;&#34;&#34;
    Primitive object/entity, may have name and location
    &#34;&#34;&#34;

    uuid: UUID = attr.ib(default=None)
    _symbol: str = attr.ib(default=&#34;n&#34;)

    def __repr__(self):
        &#34;&#34;&#34;
        Format the entity as a Neo4j style node string compatible with
        the Cypher query language:

        (&lt;symbol&gt;:&lt;class&gt; { &lt;var&gt;: $&lt;var&gt;, &lt;k&gt;: &lt;v&gt;, &lt;k&gt;: &lt;v&gt; })
        &#34;&#34;&#34;
        className = str(self)
        entity = &#34;&#34; if className == Entity.__name__ else f&#34;:{className}&#34;

        try:
            pattern = tuple(
                filter(
                    lambda x: x is not None,
                    map(processKeyValueInbound, self._properties().items()),
                )
            )
        except ValueError as _:
            raise ValueError(dumps(self._properties()))

        return f&#34;( {self._symbol}{entity} {{ {&#39;, &#39;.join(pattern)} }} )&#34;

    def __str__(self):
        return type(self).__name__

    def _setSymbol(
        self, symbol: str,
    ):
        &#34;&#34;&#34;
        Convenience setter for changing symbol if there are multiple patterns.

        Some common classes have special symbols, e.g. User is `u`
        &#34;&#34;&#34;
        self._symbol = symbol
        return self

    def _properties(self, select: (str) = (), private: str = &#34;&#34;) -&gt; dict:
        &#34;&#34;&#34;
        Create a filtered dictionary from the object properties.

        Remove not serializable or resticted members:
        - functions
        - keys beginning with a private prefix
        - keys not in a selected set, IFF provided
        &#34;&#34;&#34;

        def _filter(keyValue):
            &#34;&#34;&#34;Remove private or non-serializable data&#34;&#34;&#34;
            key, value = keyValue
            return (
                not isinstance(value, Callable)
                and isinstance(key, str)
                and (key[: len(private)] != private if private else True)
                and (key in select if select else True)
            )

        return dict(filter(_filter, self.__dict__.items()))

    @classmethod
    def addConstraint(cls, db: Driver, by: str) -&gt; Callable:
        &#34;&#34;&#34;
        Create a unique constraint on one type of labeled node.

        Usually this will be by name.
        &#34;&#34;&#34;
        query = lambda tx: tx.run(
            f&#34;CREATE CONSTRAINT ON (n:{cls.__name__}) ASSERT n.{by} IS UNIQUE&#34;
        )
        return executeQuery(db, query, read_only=False)

    @classmethod
    def addIndex(cls, db: Driver, by: str) -&gt; Callable:
        &#34;&#34;&#34;
        Indexes add a unqie constraint as well as speeding up queries
        on the graph database.
        &#34;&#34;&#34;
        query = lambda tx: tx.run(f&#34;CREATE INDEX ON : {cls.__name__}({by})&#34;)
        return executeQuery(db, query, read_only=False)

    @classmethod
    def addLabel(cls, db: Driver, label: str, **kwargs: dict) -&gt; list or None:
        &#34;&#34;&#34;
        Apply new label to nodes of this class, or a specific node.
        &#34;&#34;&#34;
        entity = cls(**kwargs)
        query = lambda tx: tx.run(
            f&#34;MATCH {repr(entity)} SET {entity._symbol}:{label}&#34;
        ).values()
        return executeQuery(db, query, read_only=False)

    @classmethod
    def count(cls, db: Driver, **kwargs: dict) -&gt; int:
        &#34;&#34;&#34;
        Count occurrence of a class label or pattern in Neo4j.
        &#34;&#34;&#34;
        entity = cls(**kwargs)
        query = lambda tx: tx.run(
            f&#34;MATCH {repr(entity)} RETURN count({entity._symbol})&#34;
        ).single()[0]
        return executeQuery(db, query, read_only=True)

    @polymorphic
    def create(
        self,
        db: Driver,
        bind: (Callable) = (),
        uuid: str = uuid4().hex,
        private: str = &#34;_&#34;,
        **kwargs: dict,
    ) -&gt; Any or None:

        &#34;&#34;&#34;
        Create a new node(s) in graph.

        Format object properties dictionary as list of key:&#34;value&#34; strings,
        automatically converting each object to string using its built-in __str__ converter.
        Special values can be given unique string serialization methods by overloading __str__.

        Blank values are ignored and will not result in graph attributes. Blank values are:
        - None (python value)
        - &#34;None&#34; (string)
        &#34;&#34;&#34;

        if isclass(self):
            entity = self(uuid=uuid, **kwargs)  # pylint: disable=not-callable
        else:
            entity = self

        executeQuery(db, lambda tx: tx.run(f&#34;MERGE {repr(entity)}&#34;))

        for fcn in bind:
            setattr(entity, fcn.__name__, MethodType(fcn, entity))

        existingCapabilities: dict = {
            x.name: x.uuid for x in TaskingCapabilities().load(db)
        }

        _generator = filter(
            lambda x: isinstance(x[1], Callable), entity.__dict__.items()
        )
        boundMethods = set(y[0] for y in _generator)
        classMethods = set(filter(lambda x: x[: len(private)] != private, dir(entity)))
        instanceKeys: set = (boundMethods | classMethods) - set(entity._properties())
        existingKeys = set(existingCapabilities.keys())

        # for key in (existingKeys &amp; instanceKeys):
        #     Link.join(
        #         db,
        #         (e, TaskingCapabilities(id=existingCapabilities[key])),
        #         props={&#34;label&#34;: &#34;Has&#34;}
        #     )

        # for key in (instanceKeys - existingKeys):
        #     fcn = eval(f&#34;{cls.__name__}.{key}&#34;)
        #     _ = TaskingCapabilities.create(
        #         db=db,
        #         link=(),
        #         name=key,
        #         description=fcn.__doc__,
        #         taskingParameters=(
        #             {
        #                 &#34;name&#34;: b.name,
        #                 &#34;description&#34;: &#34;&#34;,
        #                 &#34;type&#34;: &#34;&#34;,
        #                 &#34;allowedTokens&#34;: [&#34;&#34;],
        #             }
        #             for b in signature(fcn).parameters.values()
        #         ),
        #     )
        #     Link.join(
        #         db,
        #         (e, TaskingCapabilities(id=existingCapabilities[key])),
        #         props={&#34;label&#34;: &#34;Has&#34;}
        #     )
        return entity

    @polymorphic
    def delete(self, db: Driver, pattern: dict = None) -&gt; None:
        &#34;&#34;&#34;
        Remove all nodes from the graph, or optionally specify node-matching parameters.

        This method works on both classes and instances.
        &#34;&#34;&#34;
        if isclass(self):
            entity = self(**(pattern or {}))  # pylint: disable=not-callable
        elif pattern is not None:
            raise ValueError(&#34;Pattern supplied for delete from entity instance.&#34;)
        else:
            entity = self

        return executeQuery(
            db=db,
            read_only=False,
            method=lambda tx: tx.run(
                f&#34;MATCH {repr(entity)} DETACH DELETE {entity._symbol}&#34;
            ).values(),
        )

    @classmethod
    def dropIndex(cls, db: Driver, by: str) -&gt; None:
        &#34;&#34;&#34;Drop an existing index&#34;&#34;&#34;
        query = lambda tx: tx.run(f&#34;DROP INDEX ON : {cls.__name__}({by})&#34;)
        executeQuery(db, query, read_only=False)

    @polymorphic
    def load(
        self,
        db: Driver,
        user: Type = None,
        private: str = &#34;_&#34;,
        annotate: str = &#34;Get&#34;,
        result: str = None,
        echo: bool = False,
        **kwargs: dict,
    ) -&gt; [Type]:
        &#34;&#34;&#34;
        Create entity instance from a dictionary or Neo4j &lt;Node&gt;, which has an items() method
        that works the same as the dictionary method.
        &#34;&#34;&#34;
        if isclass(self):
            entity = self(**(kwargs or {}))  # pylint: disable=not-callable
            cls = self
        else:
            entity = self
            cls = type(self)

        cmd = (
            (
                f&#34;MATCH {repr(entity)}, {repr(user)} &#34;
                f&#34;MERGE ({entity._symbol})&lt;-[r:{annotate}]-({user._symbol}) &#34;
                f&#34;ON CREATE SET r.rank = 1 &#34;
                f&#34;ON MATCH SET r.rank = r.rank + 1 &#34;
                f&#34;RETURN {entity._symbol}{&#39;.{}&#39;.format(result) if result else &#39;&#39;}&#34;
            )
            if user
            else (
                f&#34;MATCH {repr(entity)} &#34;
                f&#34;RETURN {entity._symbol}{&#39;.{}&#39;.format(result) if result else &#39;&#39;}&#34;
            )
        )

        if echo:
            print(cmd)

        payload = []
        for rec in executeQuery(
            db=db, method=lambda tx: tx.run(cmd).values(), read_only=True
        ):
            payload.append(
                cls(**dict(map(processKeyValueOutbound, dict(rec[0]).items())))
            )
        return payload

    @polymorphic
    def mutate(self: Type, db: Driver, data: dict, pattern: dict = None) -&gt; None:
        &#34;&#34;&#34;
        Update/add node properties
        &#34;&#34;&#34;
        if isclass(self):
            entity = self(**pattern)  # pylint: disable=not-callable
        elif pattern is not None:
            raise ValueError(&#34;Pattern supplied for delete from entity instance.&#34;)
        else:
            entity = self

        _updates = &#34;, &#34;.join(map(processKeyValueInbound, data.items()))
        executeQuery(
            db=db,
            read_only=False,
            method=lambda tx: tx.run(
                f&#34;MATCH {repr(entity)} SET {entity._symbol} += {{ {_updates} }}&#34;
            ),
        )

    def serialize(
        self, db: Driver, service: str, protocol: str = &#34;http&#34;, select: (str) = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Format entity as JSON compatible dictionary from either an object instance or a Neo4j &lt;Node&gt;

        Filter properties by selected names, if any.
        Remove private members that include a underscore,
        since SensorThings notation is title case
        &#34;&#34;&#34;
        restricted = {&#34;User&#34;, &#34;Providers&#34;, &#34;Root&#34;}
        props = self._properties(select=select, private=&#34;_&#34;)
        uuid = props.pop(&#34;uuid&#34;)
        cls: str = type(self).__name__
        base_url = f&#34;{protocol}://{service}/api/&#34;
        root_url = f&#34;{base_url}/{cls}&#34;
        self_url = (
            f&#34;{root_url}({uuid})&#34; if isinstance(uuid, int) else f&#34;{base_url}/{uuid}&#34;
        )

        linkedEntities = set()
        if db is not None:
            for each in Link().query(db=db, nodes=(self, Entity())):
                label = each[0][0]
                if label not in restricted:
                    linkedEntities |= {label}

        return {
            &#34;@iot.id&#34;: uuid,
            &#34;@iot.selfLink&#34;: self_url,
            &#34;@iot.collection&#34;: root_url,
            **props,
            **{
                each + &#34;@iot.navigation&#34;: f&#34;{self_url}/{each}&#34;
                for each in linkedEntities
            },
        }


@attr.s(repr=False)
class Actuators(Entity, models.Actuators):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;


@attr.s(repr=False)
class Assets(Entity, models.Assets):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;


@attr.s(repr=False)
class Collections(Entity, models.Collections):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;


@attr.s(repr=False)
class DataStreams(Entity, models.DataStreams):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;


@attr.s(repr=False)
class FeaturesOfInterest(Entity, models.FeaturesOfInterest):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;


@attr.s(repr=False)
class Locations(Entity, models.Locations):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;

    def reportWeather(
        self,
        ts: datetime,
        api_key: str,
        url: str = &#34;https://api.darksky.net/forecast&#34;,
        exclude: (str) = None,
    ) -&gt; ResponseJSON:
        &#34;&#34;&#34;
        Get meteorological conditions in past/present/future.

        :param ts: time stamp, as date time object
        :param api_key: API key to charge against account quotas
        :param url: base route for requests
        :param exclude:
        (&#34;minutely&#34;, &#34;hourly&#34;, &#34;daily&#34;, &#34;flags&#34;, &#34;alerts&#34;)

        :return: calls, timestamp, JSON of conditions
        &#34;&#34;&#34;
        if self.location[&#34;type&#34;] != &#34;Point&#34;:
            return {&#34;message&#34;: &#34;Only GeoJSON Point types are supported&#34;}, 400

        x, y = self.location[&#34;coordinates&#34;][0], self.location[&#34;coordinates&#34;][1]

        inference = f&#34;{x},{y},{ts.isoformat()}&#34;
        return get(
            f&#34;{url}/{api_key}/{inference}?units=si&#34;
            + (f&#34;&amp;exclude={&#39;,&#39;.join(exclude)}&#34; if exclude else &#34;&#34;)
        )


@attr.s(repr=False)
class HistoricalLocations(Entity, models.HistoricalLocations):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;


@attr.s(repr=False)
class Sensors(Entity, models.Sensors):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;


@attr.s(repr=False)
class Observations(Entity, models.Observations):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;


@attr.s(repr=False)
class ObservedProperties(Entity, models.ObservedProperties):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;


@attr.s(repr=False)
class Providers(models.Providers, Entity):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;


@attr.s(repr=False)
class TaskingCapabilities(Entity, models.TaskingCapabilities):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;


@attr.s(repr=False)
class Tasks(Entity, models.Tasks):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;


@attr.s(repr=False)
class Things(Entity, models.Things):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;

    @staticmethod
    def catalog(year: int, month: int = None, day: int = None):
        &#34;&#34;&#34;
        Special catalog method for displaying data conforming to STAC spec,
        not currently in use
        &#34;&#34;&#34;
        try:
            fid = open(&#34;data/remoteCache-{}&#34;.format(year), &#34;rb&#34;)
            data = list(unpickle(fid))
        except FileNotFoundError:
            return {&#34;message&#34;: &#34;No data for year&#34;}, 404

        response = dict()
        for date in data:
            if (not month or date[&#34;date&#34;].month == month) and (
                not day or date[&#34;date&#34;].day == day
            ):
                date[&#34;files&#34;] = [file.serialize() for file in date[&#34;files&#34;]]
                response[date[&#34;name&#34;]] = date

        return response, 200


@attr.s(repr=False)
class User(Entity, models.User):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;

    _symbol: str = attr.ib(default=&#34;u&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="graph.models.Actuators"><code class="flex name class">
<span>class <span class="ident">Actuators</span></span>
<span>(</span><span>uuid: uuid.UUID = None, symbol: str = 'n', name: str = None, description: str = None, encodingType: str = None, metadata: Any = None, networkAddress: (<class 'str'>, <class 'int'>) = (None, None))</span>
</code></dt>
<dd>
<div class="desc"><p>Graph extension to base model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Actuators(Entity, models.Actuators):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></li>
<li>bathysphere.models.Actuators</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graph.models.Assets"><code class="flex name class">
<span>class <span class="ident">Assets</span></span>
<span>(</span><span>uuid: uuid.UUID = None, symbol: str = 'n', name: str = None, description: str = None, location: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Graph extension to base model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Assets(Entity, models.Assets):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></li>
<li>bathysphere.models.Assets</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graph.models.Collections"><code class="flex name class">
<span>class <span class="ident">Collections</span></span>
<span>(</span><span>uuid: uuid.UUID = None, symbol: str = 'n', name: str = None, description: str = None, extent: (<class 'float'>,) = None, keywords: str = None, license: str = None, version: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Graph extension to base model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Collections(Entity, models.Collections):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></li>
<li>bathysphere.models.Collections</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graph.models.DataStreams"><code class="flex name class">
<span>class <span class="ident">DataStreams</span></span>
<span>(</span><span>uuid: uuid.UUID = None, symbol: str = 'n', name: str = None, description: str = None, unitOfMeasurement=None, observationType=None, observedArea: dict = None, phenomenonTime: (<class 'datetime.datetime'>, <class 'datetime.datetime'>) = None, resultTime: (<class 'datetime.datetime'>, <class 'datetime.datetime'>) = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Graph extension to base model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataStreams(Entity, models.DataStreams):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></li>
<li>bathysphere.models.DataStreams</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graph.models.Entity"><code class="flex name class">
<span>class <span class="ident">Entity</span></span>
<span>(</span><span>uuid: uuid.UUID = None, symbol: str = 'n')</span>
</code></dt>
<dd>
<div class="desc"><p>Primitive object/entity, may have name and location</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Entity:
    &#34;&#34;&#34;
    Primitive object/entity, may have name and location
    &#34;&#34;&#34;

    uuid: UUID = attr.ib(default=None)
    _symbol: str = attr.ib(default=&#34;n&#34;)

    def __repr__(self):
        &#34;&#34;&#34;
        Format the entity as a Neo4j style node string compatible with
        the Cypher query language:

        (&lt;symbol&gt;:&lt;class&gt; { &lt;var&gt;: $&lt;var&gt;, &lt;k&gt;: &lt;v&gt;, &lt;k&gt;: &lt;v&gt; })
        &#34;&#34;&#34;
        className = str(self)
        entity = &#34;&#34; if className == Entity.__name__ else f&#34;:{className}&#34;

        try:
            pattern = tuple(
                filter(
                    lambda x: x is not None,
                    map(processKeyValueInbound, self._properties().items()),
                )
            )
        except ValueError as _:
            raise ValueError(dumps(self._properties()))

        return f&#34;( {self._symbol}{entity} {{ {&#39;, &#39;.join(pattern)} }} )&#34;

    def __str__(self):
        return type(self).__name__

    def _setSymbol(
        self, symbol: str,
    ):
        &#34;&#34;&#34;
        Convenience setter for changing symbol if there are multiple patterns.

        Some common classes have special symbols, e.g. User is `u`
        &#34;&#34;&#34;
        self._symbol = symbol
        return self

    def _properties(self, select: (str) = (), private: str = &#34;&#34;) -&gt; dict:
        &#34;&#34;&#34;
        Create a filtered dictionary from the object properties.

        Remove not serializable or resticted members:
        - functions
        - keys beginning with a private prefix
        - keys not in a selected set, IFF provided
        &#34;&#34;&#34;

        def _filter(keyValue):
            &#34;&#34;&#34;Remove private or non-serializable data&#34;&#34;&#34;
            key, value = keyValue
            return (
                not isinstance(value, Callable)
                and isinstance(key, str)
                and (key[: len(private)] != private if private else True)
                and (key in select if select else True)
            )

        return dict(filter(_filter, self.__dict__.items()))

    @classmethod
    def addConstraint(cls, db: Driver, by: str) -&gt; Callable:
        &#34;&#34;&#34;
        Create a unique constraint on one type of labeled node.

        Usually this will be by name.
        &#34;&#34;&#34;
        query = lambda tx: tx.run(
            f&#34;CREATE CONSTRAINT ON (n:{cls.__name__}) ASSERT n.{by} IS UNIQUE&#34;
        )
        return executeQuery(db, query, read_only=False)

    @classmethod
    def addIndex(cls, db: Driver, by: str) -&gt; Callable:
        &#34;&#34;&#34;
        Indexes add a unqie constraint as well as speeding up queries
        on the graph database.
        &#34;&#34;&#34;
        query = lambda tx: tx.run(f&#34;CREATE INDEX ON : {cls.__name__}({by})&#34;)
        return executeQuery(db, query, read_only=False)

    @classmethod
    def addLabel(cls, db: Driver, label: str, **kwargs: dict) -&gt; list or None:
        &#34;&#34;&#34;
        Apply new label to nodes of this class, or a specific node.
        &#34;&#34;&#34;
        entity = cls(**kwargs)
        query = lambda tx: tx.run(
            f&#34;MATCH {repr(entity)} SET {entity._symbol}:{label}&#34;
        ).values()
        return executeQuery(db, query, read_only=False)

    @classmethod
    def count(cls, db: Driver, **kwargs: dict) -&gt; int:
        &#34;&#34;&#34;
        Count occurrence of a class label or pattern in Neo4j.
        &#34;&#34;&#34;
        entity = cls(**kwargs)
        query = lambda tx: tx.run(
            f&#34;MATCH {repr(entity)} RETURN count({entity._symbol})&#34;
        ).single()[0]
        return executeQuery(db, query, read_only=True)

    @polymorphic
    def create(
        self,
        db: Driver,
        bind: (Callable) = (),
        uuid: str = uuid4().hex,
        private: str = &#34;_&#34;,
        **kwargs: dict,
    ) -&gt; Any or None:

        &#34;&#34;&#34;
        Create a new node(s) in graph.

        Format object properties dictionary as list of key:&#34;value&#34; strings,
        automatically converting each object to string using its built-in __str__ converter.
        Special values can be given unique string serialization methods by overloading __str__.

        Blank values are ignored and will not result in graph attributes. Blank values are:
        - None (python value)
        - &#34;None&#34; (string)
        &#34;&#34;&#34;

        if isclass(self):
            entity = self(uuid=uuid, **kwargs)  # pylint: disable=not-callable
        else:
            entity = self

        executeQuery(db, lambda tx: tx.run(f&#34;MERGE {repr(entity)}&#34;))

        for fcn in bind:
            setattr(entity, fcn.__name__, MethodType(fcn, entity))

        existingCapabilities: dict = {
            x.name: x.uuid for x in TaskingCapabilities().load(db)
        }

        _generator = filter(
            lambda x: isinstance(x[1], Callable), entity.__dict__.items()
        )
        boundMethods = set(y[0] for y in _generator)
        classMethods = set(filter(lambda x: x[: len(private)] != private, dir(entity)))
        instanceKeys: set = (boundMethods | classMethods) - set(entity._properties())
        existingKeys = set(existingCapabilities.keys())

        # for key in (existingKeys &amp; instanceKeys):
        #     Link.join(
        #         db,
        #         (e, TaskingCapabilities(id=existingCapabilities[key])),
        #         props={&#34;label&#34;: &#34;Has&#34;}
        #     )

        # for key in (instanceKeys - existingKeys):
        #     fcn = eval(f&#34;{cls.__name__}.{key}&#34;)
        #     _ = TaskingCapabilities.create(
        #         db=db,
        #         link=(),
        #         name=key,
        #         description=fcn.__doc__,
        #         taskingParameters=(
        #             {
        #                 &#34;name&#34;: b.name,
        #                 &#34;description&#34;: &#34;&#34;,
        #                 &#34;type&#34;: &#34;&#34;,
        #                 &#34;allowedTokens&#34;: [&#34;&#34;],
        #             }
        #             for b in signature(fcn).parameters.values()
        #         ),
        #     )
        #     Link.join(
        #         db,
        #         (e, TaskingCapabilities(id=existingCapabilities[key])),
        #         props={&#34;label&#34;: &#34;Has&#34;}
        #     )
        return entity

    @polymorphic
    def delete(self, db: Driver, pattern: dict = None) -&gt; None:
        &#34;&#34;&#34;
        Remove all nodes from the graph, or optionally specify node-matching parameters.

        This method works on both classes and instances.
        &#34;&#34;&#34;
        if isclass(self):
            entity = self(**(pattern or {}))  # pylint: disable=not-callable
        elif pattern is not None:
            raise ValueError(&#34;Pattern supplied for delete from entity instance.&#34;)
        else:
            entity = self

        return executeQuery(
            db=db,
            read_only=False,
            method=lambda tx: tx.run(
                f&#34;MATCH {repr(entity)} DETACH DELETE {entity._symbol}&#34;
            ).values(),
        )

    @classmethod
    def dropIndex(cls, db: Driver, by: str) -&gt; None:
        &#34;&#34;&#34;Drop an existing index&#34;&#34;&#34;
        query = lambda tx: tx.run(f&#34;DROP INDEX ON : {cls.__name__}({by})&#34;)
        executeQuery(db, query, read_only=False)

    @polymorphic
    def load(
        self,
        db: Driver,
        user: Type = None,
        private: str = &#34;_&#34;,
        annotate: str = &#34;Get&#34;,
        result: str = None,
        echo: bool = False,
        **kwargs: dict,
    ) -&gt; [Type]:
        &#34;&#34;&#34;
        Create entity instance from a dictionary or Neo4j &lt;Node&gt;, which has an items() method
        that works the same as the dictionary method.
        &#34;&#34;&#34;
        if isclass(self):
            entity = self(**(kwargs or {}))  # pylint: disable=not-callable
            cls = self
        else:
            entity = self
            cls = type(self)

        cmd = (
            (
                f&#34;MATCH {repr(entity)}, {repr(user)} &#34;
                f&#34;MERGE ({entity._symbol})&lt;-[r:{annotate}]-({user._symbol}) &#34;
                f&#34;ON CREATE SET r.rank = 1 &#34;
                f&#34;ON MATCH SET r.rank = r.rank + 1 &#34;
                f&#34;RETURN {entity._symbol}{&#39;.{}&#39;.format(result) if result else &#39;&#39;}&#34;
            )
            if user
            else (
                f&#34;MATCH {repr(entity)} &#34;
                f&#34;RETURN {entity._symbol}{&#39;.{}&#39;.format(result) if result else &#39;&#39;}&#34;
            )
        )

        if echo:
            print(cmd)

        payload = []
        for rec in executeQuery(
            db=db, method=lambda tx: tx.run(cmd).values(), read_only=True
        ):
            payload.append(
                cls(**dict(map(processKeyValueOutbound, dict(rec[0]).items())))
            )
        return payload

    @polymorphic
    def mutate(self: Type, db: Driver, data: dict, pattern: dict = None) -&gt; None:
        &#34;&#34;&#34;
        Update/add node properties
        &#34;&#34;&#34;
        if isclass(self):
            entity = self(**pattern)  # pylint: disable=not-callable
        elif pattern is not None:
            raise ValueError(&#34;Pattern supplied for delete from entity instance.&#34;)
        else:
            entity = self

        _updates = &#34;, &#34;.join(map(processKeyValueInbound, data.items()))
        executeQuery(
            db=db,
            read_only=False,
            method=lambda tx: tx.run(
                f&#34;MATCH {repr(entity)} SET {entity._symbol} += {{ {_updates} }}&#34;
            ),
        )

    def serialize(
        self, db: Driver, service: str, protocol: str = &#34;http&#34;, select: (str) = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Format entity as JSON compatible dictionary from either an object instance or a Neo4j &lt;Node&gt;

        Filter properties by selected names, if any.
        Remove private members that include a underscore,
        since SensorThings notation is title case
        &#34;&#34;&#34;
        restricted = {&#34;User&#34;, &#34;Providers&#34;, &#34;Root&#34;}
        props = self._properties(select=select, private=&#34;_&#34;)
        uuid = props.pop(&#34;uuid&#34;)
        cls: str = type(self).__name__
        base_url = f&#34;{protocol}://{service}/api/&#34;
        root_url = f&#34;{base_url}/{cls}&#34;
        self_url = (
            f&#34;{root_url}({uuid})&#34; if isinstance(uuid, int) else f&#34;{base_url}/{uuid}&#34;
        )

        linkedEntities = set()
        if db is not None:
            for each in Link().query(db=db, nodes=(self, Entity())):
                label = each[0][0]
                if label not in restricted:
                    linkedEntities |= {label}

        return {
            &#34;@iot.id&#34;: uuid,
            &#34;@iot.selfLink&#34;: self_url,
            &#34;@iot.collection&#34;: root_url,
            **props,
            **{
                each + &#34;@iot.navigation&#34;: f&#34;{self_url}/{each}&#34;
                for each in linkedEntities
            },
        }</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="graph.models.Actuators" href="#graph.models.Actuators">Actuators</a></li>
<li><a title="graph.models.Assets" href="#graph.models.Assets">Assets</a></li>
<li><a title="graph.models.Collections" href="#graph.models.Collections">Collections</a></li>
<li><a title="graph.models.DataStreams" href="#graph.models.DataStreams">DataStreams</a></li>
<li><a title="graph.models.FeaturesOfInterest" href="#graph.models.FeaturesOfInterest">FeaturesOfInterest</a></li>
<li><a title="graph.models.HistoricalLocations" href="#graph.models.HistoricalLocations">HistoricalLocations</a></li>
<li><a title="graph.models.Locations" href="#graph.models.Locations">Locations</a></li>
<li><a title="graph.models.Observations" href="#graph.models.Observations">Observations</a></li>
<li><a title="graph.models.ObservedProperties" href="#graph.models.ObservedProperties">ObservedProperties</a></li>
<li><a title="graph.models.Providers" href="#graph.models.Providers">Providers</a></li>
<li><a title="graph.models.Sensors" href="#graph.models.Sensors">Sensors</a></li>
<li><a title="graph.models.TaskingCapabilities" href="#graph.models.TaskingCapabilities">TaskingCapabilities</a></li>
<li><a title="graph.models.Tasks" href="#graph.models.Tasks">Tasks</a></li>
<li><a title="graph.models.Things" href="#graph.models.Things">Things</a></li>
<li><a title="graph.models.User" href="#graph.models.User">User</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="graph.models.Entity.addConstraint"><code class="name flex">
<span>def <span class="ident">addConstraint</span></span>(<span>db: neo4j.Driver, by: str) -> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Create a unique constraint on one type of labeled node.</p>
<p>Usually this will be by name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def addConstraint(cls, db: Driver, by: str) -&gt; Callable:
    &#34;&#34;&#34;
    Create a unique constraint on one type of labeled node.

    Usually this will be by name.
    &#34;&#34;&#34;
    query = lambda tx: tx.run(
        f&#34;CREATE CONSTRAINT ON (n:{cls.__name__}) ASSERT n.{by} IS UNIQUE&#34;
    )
    return executeQuery(db, query, read_only=False)</code></pre>
</details>
</dd>
<dt id="graph.models.Entity.addIndex"><code class="name flex">
<span>def <span class="ident">addIndex</span></span>(<span>db: neo4j.Driver, by: str) -> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Indexes add a unqie constraint as well as speeding up queries
on the graph database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def addIndex(cls, db: Driver, by: str) -&gt; Callable:
    &#34;&#34;&#34;
    Indexes add a unqie constraint as well as speeding up queries
    on the graph database.
    &#34;&#34;&#34;
    query = lambda tx: tx.run(f&#34;CREATE INDEX ON : {cls.__name__}({by})&#34;)
    return executeQuery(db, query, read_only=False)</code></pre>
</details>
</dd>
<dt id="graph.models.Entity.addLabel"><code class="name flex">
<span>def <span class="ident">addLabel</span></span>(<span>db: neo4j.Driver, label: str, **kwargs: dict) -> list</span>
</code></dt>
<dd>
<div class="desc"><p>Apply new label to nodes of this class, or a specific node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def addLabel(cls, db: Driver, label: str, **kwargs: dict) -&gt; list or None:
    &#34;&#34;&#34;
    Apply new label to nodes of this class, or a specific node.
    &#34;&#34;&#34;
    entity = cls(**kwargs)
    query = lambda tx: tx.run(
        f&#34;MATCH {repr(entity)} SET {entity._symbol}:{label}&#34;
    ).values()
    return executeQuery(db, query, read_only=False)</code></pre>
</details>
</dd>
<dt id="graph.models.Entity.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>db: neo4j.Driver, **kwargs: dict) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Count occurrence of a class label or pattern in Neo4j.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def count(cls, db: Driver, **kwargs: dict) -&gt; int:
    &#34;&#34;&#34;
    Count occurrence of a class label or pattern in Neo4j.
    &#34;&#34;&#34;
    entity = cls(**kwargs)
    query = lambda tx: tx.run(
        f&#34;MATCH {repr(entity)} RETURN count({entity._symbol})&#34;
    ).single()[0]
    return executeQuery(db, query, read_only=True)</code></pre>
</details>
</dd>
<dt id="graph.models.Entity.dropIndex"><code class="name flex">
<span>def <span class="ident">dropIndex</span></span>(<span>db: neo4j.Driver, by: str) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Drop an existing index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def dropIndex(cls, db: Driver, by: str) -&gt; None:
    &#34;&#34;&#34;Drop an existing index&#34;&#34;&#34;
    query = lambda tx: tx.run(f&#34;DROP INDEX ON : {cls.__name__}({by})&#34;)
    executeQuery(db, query, read_only=False)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="graph.models.Entity.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped function that calls the reference method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newfunc(*args, **kwargs):
    &#34;&#34;&#34;
    Wrapped function that calls the reference method
    &#34;&#34;&#34;
    return self.f(wrt, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="graph.models.Entity.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped function that calls the reference method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newfunc(*args, **kwargs):
    &#34;&#34;&#34;
    Wrapped function that calls the reference method
    &#34;&#34;&#34;
    return self.f(wrt, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="graph.models.Entity.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped function that calls the reference method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newfunc(*args, **kwargs):
    &#34;&#34;&#34;
    Wrapped function that calls the reference method
    &#34;&#34;&#34;
    return self.f(wrt, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="graph.models.Entity.mutate"><code class="name flex">
<span>def <span class="ident">mutate</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped function that calls the reference method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newfunc(*args, **kwargs):
    &#34;&#34;&#34;
    Wrapped function that calls the reference method
    &#34;&#34;&#34;
    return self.f(wrt, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="graph.models.Entity.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, db: neo4j.Driver, service: str, protocol: str = 'http', select: str = None) -> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Format entity as JSON compatible dictionary from either an object instance or a Neo4j <Node></p>
<p>Filter properties by selected names, if any.
Remove private members that include a underscore,
since SensorThings notation is title case</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(
    self, db: Driver, service: str, protocol: str = &#34;http&#34;, select: (str) = None
) -&gt; dict:
    &#34;&#34;&#34;
    Format entity as JSON compatible dictionary from either an object instance or a Neo4j &lt;Node&gt;

    Filter properties by selected names, if any.
    Remove private members that include a underscore,
    since SensorThings notation is title case
    &#34;&#34;&#34;
    restricted = {&#34;User&#34;, &#34;Providers&#34;, &#34;Root&#34;}
    props = self._properties(select=select, private=&#34;_&#34;)
    uuid = props.pop(&#34;uuid&#34;)
    cls: str = type(self).__name__
    base_url = f&#34;{protocol}://{service}/api/&#34;
    root_url = f&#34;{base_url}/{cls}&#34;
    self_url = (
        f&#34;{root_url}({uuid})&#34; if isinstance(uuid, int) else f&#34;{base_url}/{uuid}&#34;
    )

    linkedEntities = set()
    if db is not None:
        for each in Link().query(db=db, nodes=(self, Entity())):
            label = each[0][0]
            if label not in restricted:
                linkedEntities |= {label}

    return {
        &#34;@iot.id&#34;: uuid,
        &#34;@iot.selfLink&#34;: self_url,
        &#34;@iot.collection&#34;: root_url,
        **props,
        **{
            each + &#34;@iot.navigation&#34;: f&#34;{self_url}/{each}&#34;
            for each in linkedEntities
        },
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="graph.models.FeaturesOfInterest"><code class="flex name class">
<span>class <span class="ident">FeaturesOfInterest</span></span>
<span>(</span><span>uuid: uuid.UUID = None, symbol: str = 'n', name: str = None, description: str = None, encodingType: str = None, feature: Any = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Graph extension to base model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeaturesOfInterest(Entity, models.FeaturesOfInterest):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></li>
<li>bathysphere.models.FeaturesOfInterest</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graph.models.HistoricalLocations"><code class="flex name class">
<span>class <span class="ident">HistoricalLocations</span></span>
<span>(</span><span>uuid: uuid.UUID = None, symbol: str = 'n', time: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Graph extension to base model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HistoricalLocations(Entity, models.HistoricalLocations):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></li>
<li>bathysphere.models.HistoricalLocations</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graph.models.Link"><code class="flex name class">
<span>class <span class="ident">Link</span></span>
<span>(</span><span>symbol: str = 'r', rank: int = None, uuid: uuid.UUID = None, props: dict = None, label: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Links are the relationships between two entities.
They are directional.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Link:
    &#34;&#34;&#34;
    Links are the relationships between two entities.
    They are directional.
    &#34;&#34;&#34;

    _symbol: str = attr.ib(default=&#34;r&#34;)
    rank: int = attr.ib(default=None)
    uuid: UUID = attr.ib(default=None)
    props: dict = attr.ib(default=None)
    label: str = attr.ib(default=None)

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Format the Link for making a Cypher language query
        to the Neo4j graph database

        [ r:Label { &lt;key&gt;:&lt;value&gt;, &lt;key&gt;:&lt;value&gt; } ]
        &#34;&#34;&#34;
        labelStr = f&#34;:{self.label}&#34; if self.label else &#34;&#34;
        combined = {&#34;uuid&#34;: self.uuid, &#34;rank&#34;: self.rank, **(self.props or {})}
        nonNullValues = tuple(
            filter(lambda x: x, map(processKeyValueInbound, combined.items()))
        )
        pattern = (
            &#34;&#34; if len(nonNullValues) == 0 else f&#34;&#34;&#34;{{ {&#39;, &#39;.join(nonNullValues)} }}&#34;&#34;&#34;
        )
        return f&#34;[ {self._symbol}{labelStr} {pattern} ]&#34;

    @classmethod
    def drop(cls: Type, db: Driver, nodes: (Type, Type), props: dict) -&gt; None:
        &#34;&#34;&#34;
        Drop the link between two node patterns
        &#34;&#34;&#34;
        r = cls(**props)
        a, b = nodes
        cmd = f&#34;MATCH {repr(a)}-{repr(r)}-{repr(b)} DELETE {r._symbol}&#34;
        return executeQuery(db, lambda tx: tx.run(cmd), read_only=False)

    @polymorphic
    def join(
        self: Type,
        db: Driver,
        nodes: (Any, Any),
        props: dict = None,
        echo: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;
        Create a link between two node patterns. This uses the `polymorphic` decorator
        to work on either classes or isntances.

        If calling as an instance of `Link`, no addtional properties should be supplied.
        Otherwise, a `Link` will be constructed from the `props` arguement.

        There must be exactly 2 entities to link. In the future this will support N-body
        symmetric linking.
        &#34;&#34;&#34;
        if isclass(self):
            L = self(**(props or {}))  # pylint: disable=not-callable
        elif props is not None and len(props) &gt; 0:
            raise ValueError(
                &#34;No additional props allowed when using existing Link instance.&#34;
            )
        else:
            L = self
        try:
            a, b = nodes
        except ValueError:
            raise ValueError(&#34;Join requires a tuple of exactly 2 entities.&#34;)
        if a._symbol == b._symbol:
            a._setSymbol(&#34;a&#34;)
            b._setSymbol(&#34;b&#34;)

        cmd = f&#34;MATCH {repr(a)}, {repr(b)} MERGE ({a._symbol})-{repr(L)}-&gt;({b._symbol})&#34;
        if echo:
            print(cmd)
        executeQuery(db, lambda tx: tx.run(cmd), read_only=False)

    @polymorphic
    def query(
        self: Type,
        db: Driver,
        nodes: (Any, Any),
        props: dict = None,
        result: str = &#34;labels(b)&#34;,
    ) -&gt; (Any,):
        &#34;&#34;&#34;
        Match and return the label set for connected entities.

        Increment the pageRank every time the link is traversed.
        &#34;&#34;&#34;
        if isclass(self):
            L = self(**(props or {}))  # pylint: disable=not-callable
        elif props is not None and len(props) &gt; 0:
            raise ValueError(
                &#34;No additional props allowed when using existing Link instance.&#34;
            )
        else:
            L = self
        try:
            a, b = nodes
        except ValueError:
            raise ValueError(&#34;Join requires a tuple of exactly 2 entities.&#34;)
        a._setSymbol(&#34;a&#34;)
        b._setSymbol(&#34;b&#34;)

        cmd = (
            f&#34;MATCH {repr(a)}-{repr(L)}-{repr(b)}&#34;
            f&#34;SET r.rank = r.rank + 1 &#34;
            f&#34;RETURN {result}&#34;
        )
        return executeQuery(db, lambda tx: tx.run(cmd).values(), read_only=True)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="graph.models.Link.drop"><code class="name flex">
<span>def <span class="ident">drop</span></span>(<span>db: neo4j.Driver, nodes: (typing.Type, typing.Type), props: dict) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Drop the link between two node patterns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def drop(cls: Type, db: Driver, nodes: (Type, Type), props: dict) -&gt; None:
    &#34;&#34;&#34;
    Drop the link between two node patterns
    &#34;&#34;&#34;
    r = cls(**props)
    a, b = nodes
    cmd = f&#34;MATCH {repr(a)}-{repr(r)}-{repr(b)} DELETE {r._symbol}&#34;
    return executeQuery(db, lambda tx: tx.run(cmd), read_only=False)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="graph.models.Link.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped function that calls the reference method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newfunc(*args, **kwargs):
    &#34;&#34;&#34;
    Wrapped function that calls the reference method
    &#34;&#34;&#34;
    return self.f(wrt, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="graph.models.Link.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped function that calls the reference method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newfunc(*args, **kwargs):
    &#34;&#34;&#34;
    Wrapped function that calls the reference method
    &#34;&#34;&#34;
    return self.f(wrt, *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="graph.models.Locations"><code class="flex name class">
<span>class <span class="ident">Locations</span></span>
<span>(</span><span>uuid: uuid.UUID = None, symbol: str = 'n', description: str = None, encodingType: str = 'application/vnd.geo+json', location=None, name: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Graph extension to base model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Locations(Entity, models.Locations):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;

    def reportWeather(
        self,
        ts: datetime,
        api_key: str,
        url: str = &#34;https://api.darksky.net/forecast&#34;,
        exclude: (str) = None,
    ) -&gt; ResponseJSON:
        &#34;&#34;&#34;
        Get meteorological conditions in past/present/future.

        :param ts: time stamp, as date time object
        :param api_key: API key to charge against account quotas
        :param url: base route for requests
        :param exclude:
        (&#34;minutely&#34;, &#34;hourly&#34;, &#34;daily&#34;, &#34;flags&#34;, &#34;alerts&#34;)

        :return: calls, timestamp, JSON of conditions
        &#34;&#34;&#34;
        if self.location[&#34;type&#34;] != &#34;Point&#34;:
            return {&#34;message&#34;: &#34;Only GeoJSON Point types are supported&#34;}, 400

        x, y = self.location[&#34;coordinates&#34;][0], self.location[&#34;coordinates&#34;][1]

        inference = f&#34;{x},{y},{ts.isoformat()}&#34;
        return get(
            f&#34;{url}/{api_key}/{inference}?units=si&#34;
            + (f&#34;&amp;exclude={&#39;,&#39;.join(exclude)}&#34; if exclude else &#34;&#34;)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></li>
<li>bathysphere.models.Locations</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="graph.models.Locations.reportWeather"><code class="name flex">
<span>def <span class="ident">reportWeather</span></span>(<span>self, ts: datetime.datetime, api_key: str, url: str = 'https://api.darksky.net/forecast', exclude: str = None) -> (<class 'dict'>, <class 'int'>)</span>
</code></dt>
<dd>
<div class="desc"><p>Get meteorological conditions in past/present/future.</p>
<p>:param ts: time stamp, as date time object
:param api_key: API key to charge against account quotas
:param url: base route for requests
:param exclude:
("minutely", "hourly", "daily", "flags", "alerts")</p>
<p>:return: calls, timestamp, JSON of conditions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reportWeather(
    self,
    ts: datetime,
    api_key: str,
    url: str = &#34;https://api.darksky.net/forecast&#34;,
    exclude: (str) = None,
) -&gt; ResponseJSON:
    &#34;&#34;&#34;
    Get meteorological conditions in past/present/future.

    :param ts: time stamp, as date time object
    :param api_key: API key to charge against account quotas
    :param url: base route for requests
    :param exclude:
    (&#34;minutely&#34;, &#34;hourly&#34;, &#34;daily&#34;, &#34;flags&#34;, &#34;alerts&#34;)

    :return: calls, timestamp, JSON of conditions
    &#34;&#34;&#34;
    if self.location[&#34;type&#34;] != &#34;Point&#34;:
        return {&#34;message&#34;: &#34;Only GeoJSON Point types are supported&#34;}, 400

    x, y = self.location[&#34;coordinates&#34;][0], self.location[&#34;coordinates&#34;][1]

    inference = f&#34;{x},{y},{ts.isoformat()}&#34;
    return get(
        f&#34;{url}/{api_key}/{inference}?units=si&#34;
        + (f&#34;&amp;exclude={&#39;,&#39;.join(exclude)}&#34; if exclude else &#34;&#34;)
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graph.models.Observations"><code class="flex name class">
<span>class <span class="ident">Observations</span></span>
<span>(</span><span>uuid: uuid.UUID = None, symbol: str = 'n', phenomenonTime: datetime.datetime = None, result: Any = None, resultTime: datetime.datetime = None, resultQuality: Any = None, validTime: (<class 'datetime.datetime'>, <class 'datetime.datetime'>) = None, parameters: dict = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Graph extension to base model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Observations(Entity, models.Observations):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></li>
<li>bathysphere.models.Observations</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graph.models.ObservedProperties"><code class="flex name class">
<span>class <span class="ident">ObservedProperties</span></span>
<span>(</span><span>uuid: uuid.UUID = None, symbol: str = 'n', name: str = None, description: str = None, definition: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Graph extension to base model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ObservedProperties(Entity, models.ObservedProperties):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></li>
<li>bathysphere.models.ObservedProperties</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graph.models.Providers"><code class="flex name class">
<span>class <span class="ident">Providers</span></span>
<span>(</span><span>name: str = None, description: str = None, domain: str = None, secretKey: str = None, apiKey: str = None, tokenDuration: int = None, uuid: uuid.UUID = None, symbol: str = 'n')</span>
</code></dt>
<dd>
<div class="desc"><p>Graph extension to base model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Providers(models.Providers, Entity):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bathysphere.models.Providers</li>
<li><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graph.models.Sensors"><code class="flex name class">
<span>class <span class="ident">Sensors</span></span>
<span>(</span><span>uuid: uuid.UUID = None, symbol: str = 'n', name: str = None, description: str = None, encodingType: str = None, metadata: Any = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Graph extension to base model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sensors(Entity, models.Sensors):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></li>
<li>bathysphere.models.Sensors</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graph.models.TaskingCapabilities"><code class="flex name class">
<span>class <span class="ident">TaskingCapabilities</span></span>
<span>(</span><span>uuid: uuid.UUID = None, symbol: str = 'n', name: str = None, creationTime: float = NOTHING, taskingParameters: dict = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Graph extension to base model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TaskingCapabilities(Entity, models.TaskingCapabilities):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></li>
<li>bathysphere.models.TaskingCapabilities</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graph.models.Tasks"><code class="flex name class">
<span>class <span class="ident">Tasks</span></span>
<span>(</span><span>uuid: uuid.UUID = None, symbol: str = 'n', creationTime: float = NOTHING, taskingParameters: dict = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Graph extension to base model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tasks(Entity, models.Tasks):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></li>
<li>bathysphere.models.Tasks</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graph.models.Things"><code class="flex name class">
<span>class <span class="ident">Things</span></span>
<span>(</span><span>uuid: uuid.UUID = None, symbol: str = 'n', name: str = None, description: str = None, properties: dict = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Graph extension to base model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Things(Entity, models.Things):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;

    @staticmethod
    def catalog(year: int, month: int = None, day: int = None):
        &#34;&#34;&#34;
        Special catalog method for displaying data conforming to STAC spec,
        not currently in use
        &#34;&#34;&#34;
        try:
            fid = open(&#34;data/remoteCache-{}&#34;.format(year), &#34;rb&#34;)
            data = list(unpickle(fid))
        except FileNotFoundError:
            return {&#34;message&#34;: &#34;No data for year&#34;}, 404

        response = dict()
        for date in data:
            if (not month or date[&#34;date&#34;].month == month) and (
                not day or date[&#34;date&#34;].day == day
            ):
                date[&#34;files&#34;] = [file.serialize() for file in date[&#34;files&#34;]]
                response[date[&#34;name&#34;]] = date

        return response, 200</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></li>
<li>bathysphere.models.Things</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="graph.models.Things.catalog"><code class="name flex">
<span>def <span class="ident">catalog</span></span>(<span>year: int, month: int = None, day: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Special catalog method for displaying data conforming to STAC spec,
not currently in use</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def catalog(year: int, month: int = None, day: int = None):
    &#34;&#34;&#34;
    Special catalog method for displaying data conforming to STAC spec,
    not currently in use
    &#34;&#34;&#34;
    try:
        fid = open(&#34;data/remoteCache-{}&#34;.format(year), &#34;rb&#34;)
        data = list(unpickle(fid))
    except FileNotFoundError:
        return {&#34;message&#34;: &#34;No data for year&#34;}, 404

    response = dict()
    for date in data:
        if (not month or date[&#34;date&#34;].month == month) and (
            not day or date[&#34;date&#34;].day == day
        ):
            date[&#34;files&#34;] = [file.serialize() for file in date[&#34;files&#34;]]
            response[date[&#34;name&#34;]] = date

    return response, 200</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graph.models.User"><code class="flex name class">
<span>class <span class="ident">User</span></span>
<span>(</span><span>uuid: uuid.UUID = None, ip: str = None, name: str = None, alias: str = None, credential: str = None, validated: bool = True, description: str = None, symbol: str = 'u')</span>
</code></dt>
<dd>
<div class="desc"><p>Graph extension to base model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class User(Entity, models.User):
    &#34;&#34;&#34;Graph extension to base model&#34;&#34;&#34;

    _symbol: str = attr.ib(default=&#34;u&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></li>
<li>bathysphere.models.User</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="graph" href="index.html">graph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="graph.models.Actuators" href="#graph.models.Actuators">Actuators</a></code></h4>
</li>
<li>
<h4><code><a title="graph.models.Assets" href="#graph.models.Assets">Assets</a></code></h4>
</li>
<li>
<h4><code><a title="graph.models.Collections" href="#graph.models.Collections">Collections</a></code></h4>
</li>
<li>
<h4><code><a title="graph.models.DataStreams" href="#graph.models.DataStreams">DataStreams</a></code></h4>
</li>
<li>
<h4><code><a title="graph.models.Entity" href="#graph.models.Entity">Entity</a></code></h4>
<ul class="two-column">
<li><code><a title="graph.models.Entity.addConstraint" href="#graph.models.Entity.addConstraint">addConstraint</a></code></li>
<li><code><a title="graph.models.Entity.addIndex" href="#graph.models.Entity.addIndex">addIndex</a></code></li>
<li><code><a title="graph.models.Entity.addLabel" href="#graph.models.Entity.addLabel">addLabel</a></code></li>
<li><code><a title="graph.models.Entity.count" href="#graph.models.Entity.count">count</a></code></li>
<li><code><a title="graph.models.Entity.create" href="#graph.models.Entity.create">create</a></code></li>
<li><code><a title="graph.models.Entity.delete" href="#graph.models.Entity.delete">delete</a></code></li>
<li><code><a title="graph.models.Entity.dropIndex" href="#graph.models.Entity.dropIndex">dropIndex</a></code></li>
<li><code><a title="graph.models.Entity.load" href="#graph.models.Entity.load">load</a></code></li>
<li><code><a title="graph.models.Entity.mutate" href="#graph.models.Entity.mutate">mutate</a></code></li>
<li><code><a title="graph.models.Entity.serialize" href="#graph.models.Entity.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="graph.models.FeaturesOfInterest" href="#graph.models.FeaturesOfInterest">FeaturesOfInterest</a></code></h4>
</li>
<li>
<h4><code><a title="graph.models.HistoricalLocations" href="#graph.models.HistoricalLocations">HistoricalLocations</a></code></h4>
</li>
<li>
<h4><code><a title="graph.models.Link" href="#graph.models.Link">Link</a></code></h4>
<ul class="">
<li><code><a title="graph.models.Link.drop" href="#graph.models.Link.drop">drop</a></code></li>
<li><code><a title="graph.models.Link.join" href="#graph.models.Link.join">join</a></code></li>
<li><code><a title="graph.models.Link.query" href="#graph.models.Link.query">query</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="graph.models.Locations" href="#graph.models.Locations">Locations</a></code></h4>
<ul class="">
<li><code><a title="graph.models.Locations.reportWeather" href="#graph.models.Locations.reportWeather">reportWeather</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="graph.models.Observations" href="#graph.models.Observations">Observations</a></code></h4>
</li>
<li>
<h4><code><a title="graph.models.ObservedProperties" href="#graph.models.ObservedProperties">ObservedProperties</a></code></h4>
</li>
<li>
<h4><code><a title="graph.models.Providers" href="#graph.models.Providers">Providers</a></code></h4>
</li>
<li>
<h4><code><a title="graph.models.Sensors" href="#graph.models.Sensors">Sensors</a></code></h4>
</li>
<li>
<h4><code><a title="graph.models.TaskingCapabilities" href="#graph.models.TaskingCapabilities">TaskingCapabilities</a></code></h4>
</li>
<li>
<h4><code><a title="graph.models.Tasks" href="#graph.models.Tasks">Tasks</a></code></h4>
</li>
<li>
<h4><code><a title="graph.models.Things" href="#graph.models.Things">Things</a></code></h4>
<ul class="">
<li><code><a title="graph.models.Things.catalog" href="#graph.models.Things.catalog">catalog</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="graph.models.User" href="#graph.models.User">User</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
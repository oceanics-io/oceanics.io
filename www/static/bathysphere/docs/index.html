<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>bathysphere API documentation</title>
<meta name="description" content="The basic building blocks and utilities for graph queries are
contained in this default import." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>bathysphere</code></h1>
</header>
<section id="section-intro">
<p>The basic building blocks and utilities for graph queries are
contained in this default import.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># pylint: disable=invalid-name,too-few-public-methods,eval-used
&#34;&#34;&#34;
The basic building blocks and utilities for graph queries are
contained in this default import.
&#34;&#34;&#34;
from itertools import repeat
from pathlib import Path
from functools import reduce
from json import dumps

from connexion import App
from flask_cors import CORS
from prance import ResolvingParser, ValidationError

from typing import Callable, Generator, Any

from neo4j import Driver, GraphDatabase
from retry import retry
from requests import post

from datetime import datetime, date
from collections import deque
from multiprocessing import Pool
from itertools import repeat
from decimal import Decimal
from typing import Coroutine, Any
from asyncio import new_event_loop, set_event_loop, BaseEventLoop
from json import dumps

import operator
import pathlib
from yaml import Loader, load as load_yml

def loadAppConfig(sources: (str) = (&#34;bathysphere.yml&#34;, )) -&gt; dict:
    &#34;&#34;&#34;
    Load known entities and services at initialization.
    &#34;&#34;&#34;

    def renderConfig(x: str):
        &#34;&#34;&#34;
        Open the local config directory and process entries into dict structures
        &#34;&#34;&#34;
        with open(pathlib.Path(f&#34;config/{x}&#34;), &#34;r&#34;) as fid:
            items = fid.read().split(&#34;---&#34;)
        return list(map(load_yml, items, repeat(Loader, len(items))))

    def reverseDictionary(a: dict, b: dict) -&gt; dict:
        &#34;&#34;&#34;
        Flip the nestedness of the dict from a list to have top level keys for each `kind`
        &#34;&#34;&#34;
        if not isinstance(a, dict):
            raise ValueError(
                &#34;Expected dictionary values. Type is instead {}.&#34;.format(type(a))
            )

        if b is not None:
            key = b.pop(&#34;kind&#34;)
            if key not in a.keys():
                a[key] = [b]
            else:
                a[key].append(b)
        return a

    items = reduce(operator.add, map(renderConfig, sources), [])
    return reduce(reverseDictionary, items, {})


RESTRICTED = {&#34;User&#34;, &#34;Providers&#34;, &#34;Root&#34;}  # core Nodes are treated differently than other entities

class polymorphic:
    &#34;&#34;&#34;
    Class decorator for allowing methods to be class or instance
    &#34;&#34;&#34;

    def __init__(self, f):
        &#34;&#34;&#34;
        Wrap the object
        &#34;&#34;&#34;
        self.f = f

    def __get__(self, instance, owner):
        &#34;&#34;&#34;
        Hoist the function if necessary
        &#34;&#34;&#34;
        if instance is not None:
            wrt = instance
        else:
            wrt = owner

        def newfunc(*args, **kwargs):
            &#34;&#34;&#34;
            Wrapped function that calls the reference method
            &#34;&#34;&#34;
            return self.f(wrt, *args, **kwargs)

        return newfunc


def processKeyValueInbound(keyValue: (str, Any), null: bool = False) -&gt; str or None:
    &#34;&#34;&#34;
    Convert a String key and Any value into a Cypher representation
    for making the graph query.
    &#34;&#34;&#34;
    key, value = keyValue
    if key[0] == &#34;_&#34;:
        return None

    if &#34;location&#34; in key and isinstance(value, dict):

        if value.get(&#34;type&#34;) == &#34;Point&#34;:

            coord = value[&#34;coordinates&#34;]
            if len(coord) == 2:
                values = f&#34;x: {coord[1]}, y: {coord[0]}, crs:&#39;wgs-84&#39;&#34;  
            elif len(coord) == 3:
                values = f&#34;x: {coord[1]}, y: {coord[0]}, z: {coord[2]}, crs:&#39;wgs-84-3d&#39;&#34;
            else:
                # TODO: deal with location stuff in a different way, and don&#39;t auto include
                # the point type in processKeyValueOutbound. Seems to work for matching now.
                # raise ValueError(f&#34;Location coordinates are of invalid format: {coord}&#34;)
                return None
            return f&#34;{key}: point({{{values}}})&#34;

        if value.get(&#34;type&#34;) == &#34;Polygon&#34;:
            return f&#34;{key}: &#39;{dumps(value)}&#39;&#34;

        if value.get(&#34;type&#34;) == &#34;Network&#34;:
            return f&#34;{key}: &#39;{dumps(value)}&#39;&#34;


    if isinstance(value, (list, tuple, dict)):
        return f&#34;{key}: &#39;{dumps(value)}&#39;&#34;

    if isinstance(value, str) and value and value[0] == &#34;$&#34;:
        # TODO: This hardcoding is bad, but the $ picks up credentials
        if len(value) &lt; 64:
            return f&#34;{key}: {value}&#34;

    if value is not None:
        return f&#34;{key}: {dumps(value)}&#34;

    if null:
        return f&#34;{key}: NULL&#34;

    return None


def executeQuery(
    db: Driver, method: Callable, kwargs: (dict,)=(), read_only: bool = True
) -&gt; None or (Any,):
    &#34;&#34;&#34;
    Execute one or more cypher queries in an equal number of transactions against the
    Neo4j graph database.
    &#34;&#34;&#34;
    with db.session() as session:
        _transact = session.read_transaction if read_only else session.write_transaction
        if kwargs:
            return [_transact(method, **each) for each in kwargs]
        return _transact(method)


@retry(tries=2, delay=1, backoff=1)
def connect(host: str, port: int, accessKey: str, default: str = &#34;neo4j&#34;) -&gt; Driver:
    &#34;&#34;&#34;
    Connect to a database manager. Try docker networking, or fallback to local host.
    likely that the db has been accessed and setup previously

    TODO: should use SSL, but Neo4j 4.0 introduced some bugs
    https://community.neo4j.com/t/neo4j-python-driver-throwing-errors/13822/2
    &#34;&#34;&#34;
    db = None
    for auth in ((default, accessKey), (default, default)):
        try:
            db = GraphDatabase.driver(uri=f&#34;bolt://{host}:{port}&#34;, auth=auth, encrypted=False)
        except Exception as ex:  # pylint: disable=broad-except
            print(f&#34;{ex} on {host}:{port} with {auth}&#34;)
            continue
        if auth == (default, default) and accessKey != default:
            response = post(
                f&#34;http://{host}:7474/user/neo4j/password&#34;,
                auth=auth,
                json={&#34;password&#34;: accessKey},
            )
            if not response.ok:
                raise ConnectionError(f&#34;Problem changing Neo4j default password: {response}&#34;) 
        return db

    if db is None:
        print(f&#34;Could not connect to Neo4j database @ {host}:{port}&#34;)


__pdoc__ = {
    &#34;test&#34;: False
    # submodules will be skipped in doc generation
}
app = App(__name__, options={&#34;swagger_ui&#34;: False})
CORS(app.app)

try:
    appConfig = loadAppConfig()
    services = filter(
        lambda x: &#34;bathysphere-api&#34; == x[&#34;spec&#34;][&#34;name&#34;], appConfig[&#34;Locations&#34;]
    )
    config = next(services)[&#34;metadata&#34;][&#34;config&#34;]
    relativePath = config.get(&#34;specPath&#34;)
except StopIteration:
    raise ValueError(&#34;Invalid YAML configuration file.&#34;)

try:
    absolutePath = str(Path(relativePath).absolute())
except FileNotFoundError as ex:
    raise FileNotFoundError(f&#34;Specification not found: {relativePath}&#34;)

try:
    parser = ResolvingParser(absolutePath, lazy=True, strict=True)
    parser.parse()
except ValidationError as ex:
    print(ex.args[0])
    raise Exception(&#34;Could not parse OpenAPI specification.&#34;)
else:
    app.add_api(parser.specification, base_path=config.get(&#34;basePath&#34;))



# def locations(vertex_buffer: array, after=0, before=None, bs=100):
#     &#34;&#34;&#34;
#     Create a bunch of points in the graph
#     &#34;&#34;&#34;
#     cls = &#34;Locations&#34;
#     n = min(len(vertex_buffer), before)
#     np = count(cls)

#     while after &lt; n:
#         size = min(n - after, bs)
#         indices = [ii + np for ii in range(after, after + size)]
#         subset = vertex_buffer[indices, :]
#         batch(cls, list(subset), indices)
#         after += size

#     return {&#34;after&#34;: after, &#34;before&#34;: before}


# def _edges(points, indices, topology, neighbors, cells):
#     &#34;&#34;&#34;Initialize edge arrays&#34;&#34;&#34;

#     tri = len(indices)
#     shape = (tri, 3)
#     full = (*shape, 2)
#     nodes = zeros(full, dtype=int) - 1  # indices of side-of nodes
#     cells = zeros(full, dtype=int) - 1  # indices of side-of elements
#     center = zeros(full, dtype=float)
#     ends = zeros((*full, 2), dtype=float)
#     bound = zeros(shape, dtype=bool)

#     for cell in range(tri):
#         children = topology[cell, :]
#         count = 0
#         for each in neighbors[cell]:  # edges which have been not set already

#             cells[cell, count, :] = [cell, each]
#             side_of = intersect1d(children, topology[each, :], assume_unique=True)
#             nodes[cell, count, :] = side_of
#             center[cell, count, :] = points[side_of, :2].mean(dim=1)  # edge center
#             ends[cell, count, :, :] = cells[each], center[cell, count]
#             count += 1

#         boundary[cell, :2] = True  # mark edges as boundaries

#     dx = ends[:, :, 1, 0] - ends[:, :, 0, 0]
#     dy = ends[:, :, 1, 1] - ends[:, :, 0, 1]

#     return {
#         &#34;boundary&#34;: bound,
#         &#34;length&#34;: (dx ** 2 + dy ** 2) ** 0.5,
#         &#34;angle&#34;: arctan2(dx, dy),
#         &#34;cells&#34;: cells,
#         &#34;center&#34;: center,
#         &#34;nodes&#34;: nodes,
#         &#34;ends&#34;: ends,
#     }


#
# def vertexNeighbors(cls, tx, node):
#     &#34;&#34;&#34;
#     Get node parents and node neighbors
#
#     :param tx:
#     :param node:
#     :return:
#     &#34;&#34;&#34;
#     a = cls._match(&#34;Nodes&#34;, node, &#34;a&#34;)
#     b = cls._match(&#34;Nodes&#34;, &#34;b&#34;)
#     chain = &#34;(a)-[:SIDE_OF]-&gt;(:Element)&lt;-[:SIDE_OF]-&#34;
#     command = &#34; &#34;.join([a, &#34;MATCH&#34;, chain + b, &#34;MERGE&#34;, &#34;(a)-[:NEIGHBORS]-(b)&#34;])
#     tx.run(command, id=node)
#
#
# def _topology(tx, nodes, index):
#     &#34;&#34;&#34;
#     Create parent-child relationships
#
#     :param tx: Implicit transmit
#     :param nodes: vertices, indices
#     :param index: element identifier
#     :return:
#     &#34;&#34;&#34;
#     tx.run(
#         &#34;MATCH (n1:Node {id: $node1}) &#34;
#         + &#34;MATCH (n2:Node {id: $node2}) &#34;
#         + &#34;MATCH (n3:Node {id: $node3}) &#34;
#         + &#34;MATCH (e:Element {id: $index}) &#34;
#         + &#34;CREATE (n1)-[: SIDE_OF]-&gt;(e) &#34;
#         + &#34;CREATE (n2)-[: SIDE_OF]-&gt;(e) &#34;
#         + &#34;CREATE (n3)-[: SIDE_OF]-&gt;(e) &#34;,
#         node1=int(nodes[0]),
#         node2=int(nodes[1]),
#         node3=int(nodes[2]),
#         index=index,
#     )
#
#
# def _neighbors(mesh):
#     &#34;&#34;&#34;
#     Make queries and use results to build topological relationships.
#
#     :param mesh:
#     :return:
#     &#34;&#34;&#34;
#     kwargs = [{&#34;identity&#34;: ii for ii in range(mesh.nodes.n)}]
#     _write(_neighbors, kwargs)
#
#
# def _create_blanks(graph, nn, ne):
#     &#34;&#34;&#34;
#     Setup new sphere
#     &#34;&#34;&#34;
#     graph.create(&#34;Elements&#34;, range(ne), repeat(None, ne))
#     graph.index(&#34;Elements&#34;, &#34;id&#34;)
#     graph.create(&#34;Nodes&#34;, range(nn), repeat(None, nn))
#     graph.index(&#34;Nodes&#34;, &#34;id&#34;)
#
# #
# def _neighbor(root, cls, tx, id):
#     &#34;&#34;&#34;
#     Get node parents and node neighbors
#
#     :param tx:
#     :param node:
#     :return:
#     &#34;&#34;&#34;
#     a = _node(&#34;a&#34;, cls, id)
#     b = _node(&#34;b&#34;, cls, id)
#     command = f&#34;MATCH {a}-[:SIDE_OF]-&gt;(:{root})&lt;-{b} MERGE (a)-[:Neighbors]-(b)&#34;
#     tx.run(command, id=id)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="bathysphere.functions" href="functions.html">bathysphere.functions</a></code></dt>
<dd>
<div class="desc"><p>The functions module of the graph API contains handlers for secure
calls. These are exposed as a Cloud Function calling Connexion/Flask.</p></div>
</dd>
<dt><code class="name"><a title="bathysphere.models" href="models.html">bathysphere.models</a></code></dt>
<dd>
<div class="desc"><p>The models module of the graph API contains extensions to the common
models, for storing and accessing data in a Neo4j database.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="bathysphere.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>host: str, port: int, accessKey: str, default: str = 'neo4j') ‑> neo4j.Driver</span>
</code></dt>
<dd>
<div class="desc"><p>Connect to a database manager. Try docker networking, or fallback to local host.
likely that the db has been accessed and setup previously</p>
<p>TODO: should use SSL, but Neo4j 4.0 introduced some bugs
<a href="https://community.neo4j.com/t/neo4j-python-driver-throwing-errors/13822/2">https://community.neo4j.com/t/neo4j-python-driver-throwing-errors/13822/2</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@retry(tries=2, delay=1, backoff=1)
def connect(host: str, port: int, accessKey: str, default: str = &#34;neo4j&#34;) -&gt; Driver:
    &#34;&#34;&#34;
    Connect to a database manager. Try docker networking, or fallback to local host.
    likely that the db has been accessed and setup previously

    TODO: should use SSL, but Neo4j 4.0 introduced some bugs
    https://community.neo4j.com/t/neo4j-python-driver-throwing-errors/13822/2
    &#34;&#34;&#34;
    db = None
    for auth in ((default, accessKey), (default, default)):
        try:
            db = GraphDatabase.driver(uri=f&#34;bolt://{host}:{port}&#34;, auth=auth, encrypted=False)
        except Exception as ex:  # pylint: disable=broad-except
            print(f&#34;{ex} on {host}:{port} with {auth}&#34;)
            continue
        if auth == (default, default) and accessKey != default:
            response = post(
                f&#34;http://{host}:7474/user/neo4j/password&#34;,
                auth=auth,
                json={&#34;password&#34;: accessKey},
            )
            if not response.ok:
                raise ConnectionError(f&#34;Problem changing Neo4j default password: {response}&#34;) 
        return db

    if db is None:
        print(f&#34;Could not connect to Neo4j database @ {host}:{port}&#34;)</code></pre>
</details>
</dd>
<dt id="bathysphere.executeQuery"><code class="name flex">
<span>def <span class="ident">executeQuery</span></span>(<span>db: neo4j.Driver, method: Callable, kwargs: (<class 'dict'>,) = (), read_only: bool = True) ‑> (typing.Any,)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute one or more cypher queries in an equal number of transactions against the
Neo4j graph database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def executeQuery(
    db: Driver, method: Callable, kwargs: (dict,)=(), read_only: bool = True
) -&gt; None or (Any,):
    &#34;&#34;&#34;
    Execute one or more cypher queries in an equal number of transactions against the
    Neo4j graph database.
    &#34;&#34;&#34;
    with db.session() as session:
        _transact = session.read_transaction if read_only else session.write_transaction
        if kwargs:
            return [_transact(method, **each) for each in kwargs]
        return _transact(method)</code></pre>
</details>
</dd>
<dt id="bathysphere.loadAppConfig"><code class="name flex">
<span>def <span class="ident">loadAppConfig</span></span>(<span>sources: str = ('bathysphere.yml',)) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Load known entities and services at initialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadAppConfig(sources: (str) = (&#34;bathysphere.yml&#34;, )) -&gt; dict:
    &#34;&#34;&#34;
    Load known entities and services at initialization.
    &#34;&#34;&#34;

    def renderConfig(x: str):
        &#34;&#34;&#34;
        Open the local config directory and process entries into dict structures
        &#34;&#34;&#34;
        with open(pathlib.Path(f&#34;config/{x}&#34;), &#34;r&#34;) as fid:
            items = fid.read().split(&#34;---&#34;)
        return list(map(load_yml, items, repeat(Loader, len(items))))

    def reverseDictionary(a: dict, b: dict) -&gt; dict:
        &#34;&#34;&#34;
        Flip the nestedness of the dict from a list to have top level keys for each `kind`
        &#34;&#34;&#34;
        if not isinstance(a, dict):
            raise ValueError(
                &#34;Expected dictionary values. Type is instead {}.&#34;.format(type(a))
            )

        if b is not None:
            key = b.pop(&#34;kind&#34;)
            if key not in a.keys():
                a[key] = [b]
            else:
                a[key].append(b)
        return a

    items = reduce(operator.add, map(renderConfig, sources), [])
    return reduce(reverseDictionary, items, {})</code></pre>
</details>
</dd>
<dt id="bathysphere.processKeyValueInbound"><code class="name flex">
<span>def <span class="ident">processKeyValueInbound</span></span>(<span>keyValue: (<class 'str'>, typing.Any), null: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a String key and Any value into a Cypher representation
for making the graph query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def processKeyValueInbound(keyValue: (str, Any), null: bool = False) -&gt; str or None:
    &#34;&#34;&#34;
    Convert a String key and Any value into a Cypher representation
    for making the graph query.
    &#34;&#34;&#34;
    key, value = keyValue
    if key[0] == &#34;_&#34;:
        return None

    if &#34;location&#34; in key and isinstance(value, dict):

        if value.get(&#34;type&#34;) == &#34;Point&#34;:

            coord = value[&#34;coordinates&#34;]
            if len(coord) == 2:
                values = f&#34;x: {coord[1]}, y: {coord[0]}, crs:&#39;wgs-84&#39;&#34;  
            elif len(coord) == 3:
                values = f&#34;x: {coord[1]}, y: {coord[0]}, z: {coord[2]}, crs:&#39;wgs-84-3d&#39;&#34;
            else:
                # TODO: deal with location stuff in a different way, and don&#39;t auto include
                # the point type in processKeyValueOutbound. Seems to work for matching now.
                # raise ValueError(f&#34;Location coordinates are of invalid format: {coord}&#34;)
                return None
            return f&#34;{key}: point({{{values}}})&#34;

        if value.get(&#34;type&#34;) == &#34;Polygon&#34;:
            return f&#34;{key}: &#39;{dumps(value)}&#39;&#34;

        if value.get(&#34;type&#34;) == &#34;Network&#34;:
            return f&#34;{key}: &#39;{dumps(value)}&#39;&#34;


    if isinstance(value, (list, tuple, dict)):
        return f&#34;{key}: &#39;{dumps(value)}&#39;&#34;

    if isinstance(value, str) and value and value[0] == &#34;$&#34;:
        # TODO: This hardcoding is bad, but the $ picks up credentials
        if len(value) &lt; 64:
            return f&#34;{key}: {value}&#34;

    if value is not None:
        return f&#34;{key}: {dumps(value)}&#34;

    if null:
        return f&#34;{key}: NULL&#34;

    return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="bathysphere.polymorphic"><code class="flex name class">
<span>class <span class="ident">polymorphic</span></span>
<span>(</span><span>f)</span>
</code></dt>
<dd>
<div class="desc"><p>Class decorator for allowing methods to be class or instance</p>
<p>Wrap the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class polymorphic:
    &#34;&#34;&#34;
    Class decorator for allowing methods to be class or instance
    &#34;&#34;&#34;

    def __init__(self, f):
        &#34;&#34;&#34;
        Wrap the object
        &#34;&#34;&#34;
        self.f = f

    def __get__(self, instance, owner):
        &#34;&#34;&#34;
        Hoist the function if necessary
        &#34;&#34;&#34;
        if instance is not None:
            wrt = instance
        else:
            wrt = owner

        def newfunc(*args, **kwargs):
            &#34;&#34;&#34;
            Wrapped function that calls the reference method
            &#34;&#34;&#34;
            return self.f(wrt, *args, **kwargs)

        return newfunc</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="bathysphere.functions" href="functions.html">bathysphere.functions</a></code></li>
<li><code><a title="bathysphere.models" href="models.html">bathysphere.models</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="bathysphere.connect" href="#bathysphere.connect">connect</a></code></li>
<li><code><a title="bathysphere.executeQuery" href="#bathysphere.executeQuery">executeQuery</a></code></li>
<li><code><a title="bathysphere.loadAppConfig" href="#bathysphere.loadAppConfig">loadAppConfig</a></code></li>
<li><code><a title="bathysphere.processKeyValueInbound" href="#bathysphere.processKeyValueInbound">processKeyValueInbound</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="bathysphere.polymorphic" href="#bathysphere.polymorphic">polymorphic</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>
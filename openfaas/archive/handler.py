from os import getenv
from json import dumps
from ftplib import FTP
import hmac
import hashlib
from json import loads
from functools import reduce


def searchTree(pattern, filesystem):
    # type: (str, dict) -> None or str
    """
    Recursively search a directory structure for a key.
    Call this on the result of `index`

    :param filesystem: paths
    :param pattern: search key
    :return:
    """
    for key, level in filesystem.items():
        if key == pattern:
            return key
        try:
            result = searchTree(pattern, level)
        except AttributeError:
            result = None
        if result:
            return f"{key}/{result}"
    return None


def syncFtp(ftp, remote, local, filesystem=None):
    # type: (FTP, str, str, dict) -> int
    path = searchTree(filesystem=filesystem, pattern=remote)
    with open(local, "wb+") as fid:
        return int(ftp.retrbinary(f"RETR {path}", fid.write))


def indexFtp(ftp, node=".", depth=0, limit=None, metadata=None, parent=None):
    # type: (FTP, str, int, int or None, dict or None, dict) -> None
    """
    Build directory structure recursively.

    :param ftp: persistent ftp connection
    :param node: node in current working directory
    :param depth: current depth, do not set
    :param limit: maximum depth,
    :param metadata: pass the object metadata down one level
    :param parent:
    :return:
    """

    def _map(rec):
        values = rec.split()
        key = values.pop().strip()
        return {key: values}

    if depth == 0 and parent is None:
        parent = create(
            db=graph,
            obj=Locations(
                **{"name": "FTP Server", "description": "Autogenerated FTP Server"}
            ),
        )

    if limit is None or depth <= limit:
        try:
            _ = ftp.cwd(node)  # target is a file
        except:
            create(
                db=graph,
                obj=Proxy(
                    **{"name": node, "description": "Autogenerated", "url": node}
                ),
                links=[parent],
            )

        else:
            collection = create(
                db=graph,
                obj=Proxy(
                    **{"name": node, "description": "Autogenerated", "url": node}
                ),
                links=[parent],
            )

            files = []
            ftp.retrlines("LIST", files.append)
            for k, v in reduce(lambda x, y: {**x, **y}, map(_map, files), {}).items():
                indexFtp(
                    ftp=ftp,
                    graph=graph,
                    node=k,
                    depth=depth + 1,
                    limit=limit,
                    metadata=v,
                    parent=collection,
                )

            if node != ".":
                _ = ftp.cwd("..")


def handle(req):
    # We receive the hashed message in form of a header
    """
    Index a filesystem, and create a bunch of async tasks to generate:
    -Catalog
    -Collections
    -Items
    -Assets


    :param req:
    :return:
    """

    if getenv("Http_Method") != "POST":
        print(dumps({"Error": "Require POST"}))
        exit(403)

    with open("/var/openfaas/secrets/payload-secret", "r") as secretContent:
        _hash = getenv("Http_Hmac")
        expectedMAC = hmac.new(secretContent.read().encode(), req.encode(), hashlib.sha1)
        if (_hash[5:] if "sha1=" in _hash else _hash) != expectedMAC.hexdigest():
            print(dumps({"Error": "HMAC validation"}))
            exit(403)

    print(dumps({"Error": "Not implemented"}))
    exit(504)

    body = loads(req)
    host = body.get("host", "misclab.umeoce.maine.edu",)
    root = body.get("root", ("users", "misclab", "coastal_sat"))
    ftp = FTP(host, timeout=4)
    assert "230" in ftp.login()  # attach if no open socket
    assert ftp.sock
    if root is not None:
        _ = ftp.cwd(root)
    indexFtp(ftp)



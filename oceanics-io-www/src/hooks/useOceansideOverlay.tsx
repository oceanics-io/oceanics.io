import { useEffect, useState, useReducer, useRef } from "react";
import { lichen, orange } from "../palette";
import useWasmRuntime from "./useWasmRuntime";
import type {PrismCursor} from "oceanics-io-wasm-www";
import {rotatePath, eventCoordinates, inverse} from "../workers/shared";


type IOceansideOverlay = {
    gridSize: number;
    backgroundColor: string;
}

type ListenArgs = {key: string; repeat: boolean;}

/**
 * The `Oceanside` hook provides all of the functionality to
 * embed the game/visualization engine in any React app.
 * 
 * The interface consists of two canvases. One canvas displays 
 * the navigation minimap, and the other is where the animated 
 * game tiles are rendered. 
 * 
 * A text block displays the current datetime and score. 
 * 
 * Tile asset references are used to pre-load all of the
 * sprite data for animations. 
 * 
 * @param {Object} args - Arguments object
 * @param {number} args.gridSize - Integer height and width of grid subset. The number of tiles visible is the square of `gridSize`, so scores are higher for larger.
 * @param {number} args.worldSize - Integer height and width of global grid. The total number of tiles, and therefore the probability of finding certain features, is the square of `worldSize`. 
 * @param {number} args.waterLevel - Fraction of tidal evolution. Each tile has an elevation value. Tiles above `waterLevel` are always land, and therfore worth nothing. Other wet tiles become mud depending on the tidal cycle and their elevation.
 * @param {number} args.actionsPerDay - The `actionsPerDay` property determines how quickly time passes, and how many things you can interact with per day. This ultimately puts a limit on the score you can earn.
 * @param {String} args.endTurnMessage - message to display when no actions remain
 * @param {String} args.overlayColor - color to draw metadata and overlays.
 * @param {String} args.backgroundColor - color of animation loop blending
 * @param {String} args.font - font for metadata overlays
 */
export const useOceansideOverlay = ({
    gridSize,
    backgroundColor = "#00000000",
}: IOceansideOverlay) => {

    /**
     * Canvas reference.
     */
    const overlay = useRef<HTMLCanvasElement|null>(null);

    /**
     * Runtime will be passed to calling Hook or Component. 
     */
    const { runtime } = useWasmRuntime();

    /**
     * Complex cursor handled in Rust
     */
    const [cursor, setCursor] = useState<PrismCursor|null>(null);

    /**
     * When runtime loads, create a cursor instance.
     */
    useEffect(()=>{
        if (!runtime) return;
        setCursor(new runtime.PrismCursor(0.0, 0.0, window.devicePixelRatio, gridSize));
    }, [ runtime ]);
    
    /**
     * Clamp custom cursor to the discrete grid.
     */
    const [ clamp, setClamp ] = useState(false);
    
    /**
     * Toggle the key state when it is pressed and released.
     * There is technically no need for the default case.
     * 
     * The initial value of the state is taken from the second
     * arg to `useReducer`.
     *
     *Add and remove keypress listeners as necessary. These
     * will call the `setKeys` method generated by `useReducer`
     * to logicaly update the array of pressed keys. 
     */
    const [keys, setKeys] = useReducer(
        (state: {[index: string]: string|boolean}, {type, key}: {type: string; key: string;}) => {
            switch (type) {
                case "keydown":
                    return { ...state, [key]: true };
                case "keyup":
                    return { ...state, [key]: false };
                default:
                    return state;
            }
        }, 
        ["Shift", "C"].reduce(
            (acc, key) => {
                return {
                    ...acc,
                    [key.toLowerCase()]: false
                };
            }, {}
        )
    );

    
    useEffect(() => {
        const listeners = ["keyup", "keydown"].map((type: "keyup"|"keydown") => {
            const listen = ({key, repeat}: {key: string; repeat: boolean;}) => {
                const symbol = key.toLowerCase();
                if (repeat || !keys.hasOwnProperty(symbol)) return;
                if (keys[symbol] === ("keyup" === type)) setKeys({ type, key: symbol });  
            };
            window.addEventListener(type, listen, true);
            return [type, listen];
        });

        const removeListener = (each: [string, (arg: ListenArgs)=>void]) => window.removeEventListener(...each, true);

        return () => { listeners.forEach(removeListener) };
    }, [ keys ]);
  

    useEffect(() => {
        if (Object.values(keys).every(x => x)) setClamp(!clamp);
    }, [ keys ]);

   
    //
    useEffect(() => {
        if (
            !overlay || 
            !overlay.current ||
            !cursor
        ) return;
        const canvas: HTMLCanvasElement = overlay.current;
        canvas.addEventListener("mousemove", (event) => {
            const xy = eventCoordinates(event, canvas);
            cursor.update(...xy);
        });
    
    }, [ cursor, overlay ]);


    /**
     * Draw the visible area to the board canvas using the 
     * tile set object. 
     */
    useEffect(() => {
        if (
            !overlay || 
            !overlay.current || 
            !cursor ||
            !runtime
        ) return;

        const canvas: HTMLCanvasElement = overlay.current;
        const ctx = canvas.getContext(`2d`);
        if (!ctx) throw TypeError("Rendering Context is Null")
        
        [canvas.width, canvas.height] = ["width", "height"].map(
            dim => getComputedStyle(canvas).getPropertyValue(dim).slice(0, -2)
        ).map(x => Number(x) * window.devicePixelRatio);
        const { width, height } = canvas;

        runtime.clear_rect_blending(ctx, width, height, backgroundColor);
        
        const Δx = 1; 
        const Δy = 1;
        const [x, y]: [number, number] = [cursor.x(), cursor.y()];

        const cellSize = width/gridSize;
        const [inverted] = inverse([[x*cellSize, y*cellSize]], width, gridSize).map(pt => pt.map(x=>x/cellSize));
        
        [
            {upperLeft: [x, y], color: orange},
            {upperLeft: inverted, color: lichen}
        ].map(({color, upperLeft})=>{

            const [x, y] = upperLeft.map(dim => clamp ? Math.floor(dim) : dim);

            const cellA: [number, number][] = [
                [x, y],
                [x + Δx, y],
                [x + Δx, y + Δy],
                [x, y + Δy]
            ].map(
                ([x, y]) => [x*cellSize, y*cellSize]
            );
            
            const cellB: [number, number][] = rotatePath(
                cellA.map(([x, y]) => [x/Math.sqrt(2), y/Math.sqrt(2)]), 
                Math.PI/4
            ).map(
                ([x,y])=>[
                    x + (Math.floor(0.5*gridSize) + 1.25)*cellSize/Math.sqrt(2), 
                    0.5*y
                ]
            );

            ctx.strokeStyle = color;
            ctx.lineWidth = 2.0;

            [cellA, cellB].forEach(cell => {
                ctx.beginPath();
                ctx.moveTo(...cell[0]);
                cell.slice(1, 4).forEach(pt => ctx.lineTo(...pt));
                ctx.closePath();
                ctx.stroke(); 
            });

            ctx.beginPath();
            for (let ii=0; ii<4; ii++) {
                ctx.moveTo(...cellA[ii]);
                ctx.lineTo(...cellB[ii]);
            }
            ctx.stroke();
        });
  
    }, [ clamp, cursor ]);
    
    return {
        ref: overlay
    }  
};

export default useOceansideOverlay;
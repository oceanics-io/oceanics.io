---
title: Autogenerating interfaces from OpenAPI specifications
date: "2020-11-21T15:00:00.000Z"
description: |
    I always start development on an API by writing the OpenAPI specification. 
    Python backends that we deploy use `prance` and `connexion` to validate traffic, so any specification is guaranteed to be correct.
    Seemed like a good idea to just transpile that YAML into frontend code. 


tags: [interface, openapi, ux, documentation, react hooks]
---

## Motivation

Some people I have worked with find writing specifications a bit fussy. My love of specs has contributed to failing technical interviews, and even being fired.

I'm not sure whether internal specs are as feared as formal standards, but in both cases it takes a long view to appreciate their value.

The idea is not that the spec is inflexible and unchangin, but that it is a single source of truth, a "contract" between the frontend and backend. It removes the need for almost any boilerplate validation inside your business logic. And, unlike hard-coding all your business logic, it is language agnostic.

The style that I prefer is putting most of the nit-picky stuff in YAML and then writing thin generic code to transport and transform it. 

With OpenAPI and automatic validation, you start to realize how sloppy people are. I turned on response validation once (after weeks of warnings), and it broke half of a large production API.

I go through all that trouble to keep the toil out of writing backend services. But, it's hard to get people to use an API directly, and I get a lot of requests for graphical interfaces. 

Why not generate these directly from the spec, for any API, rather than hand-coding it?

## Approach

I'm going to show an example with our [Bivalve API](https://bivalve.oceanics.io). The documentation page is built with ReDoc, and we're going to use a similar style, but produce forms instead of docs. 

This is not going to go into callbacks or sending form requests to the server, just parsing the spec into a visual representation.

I tried writing a parser, but handling the edge cases was time consuming, and there are good open source options available. We'll use the `@apidevtools/swagger-parser` library. 
 
Swagger is what OpenAPI used to be called.

We'll also use React Hooks.

You can see the result at the [end of the page](#example-specification).

### OpenAPI parsing hook

We'll put the specification loading and parsing logic into a custom React Hook rather than compiling materialized views during the bundling process.

This reusable hook lets us recycle the code for other components that consume the API. It will live in `src/hooks/useOpenApiLoader.jsx`, and provide state references to assets used in rendering the interface. 

#### Inputs

The hook function takes `specUrl` and `scrapeIndexPage` as inputs. 

The former is the location of the spec itself, and the second is a boolean that determines whether additional data from the `/` route will loaded to populate inputs like selection options. 

The simplest use is:
```JavaScript
const {apiSpec, methods} = useOpenApiLoader({specUrl});
```

#### Hooks
There are three state effects.

First the spec itself is loaded and parsed: 

```JavaScript
// useOpenApiLoader.jsx
const [apiSpec, setApiSpec] = useState(null);
useEffect(()=>{
    SwaggerParser.validate(specUrl, (err, api) => {
        if (err) console.error(err);
        else setApiSpec(api);
    });   
},[]);
```

Once the spec state has been set we trigger additional processing steps to extract information in a more useful format.

If the scraping option is enabled, we'll retrieve the base server route. For our APIs this is usually an index, or list of available resources or collections.

```JavaScript
// useOpenApiLoader.jsx
const [index, setIndex] = useState(null); // loaded from API
useEffect(()=>{
    if (!scrapeIndexPage || !apiSpec) return;
    
    fetch(apiSpec.servers[0].url)
        .then(response => response.json())
        .then(indexPage => {setIndex(indexPage)});

}, [apiSpec]);
```

The above will break if no `servers` object is present, and needs some error handling. 

We will want to generate a form for each pair of paths and methods. We start by flattening the spec structure and transforming the items. 

```JavaScript
// useOpenApiLoader.jsx
const flattenSpecOperations = ({paths}) =>
    Object.entries(paths).flatMap(([path, schema]) => 
        Object.entries(schema)
            .map(([method, schema]) => Object({path, method, schema}))
        );

const [methods, setMethods] = useState([]);
useEffect(()=>{
    if (!apiSpec) return;
    setMethods(flattenSpecOperations(apiSpec));
}, [apiSpec])
```

#### Result

The custom hook function returns an object with the attributes `apiSpec`, `index`, and `methods`. These are all React state references, and will be set asynchronously. 


### OpenAPI form transformer hook

Another custom hook provides the code that transforms the loaded spec 
into Form elements. I won't go over our Form component here, but you can find it in the `src/components` directory.

There are some discrepancies between OpenAPI schemas, and HTML form inputs that we need to rectify, and we need to strip out `readOnly` properties. 

The full hook is this:

```JavaScript
// useOpenApiForm.jsx
const schemaToInput = ({
    name, 
    schema, 
    ...props
}) => {
    let type;
    let options = null;
    if (schema !== undefined){
        type = schema.type;
        if ("enum" in schema) {
            type = "select";
            options = schema.enum;
        } else if (type === "string") {
            type = "text";
        } else if (type === "integer") {
            type = "number";
        } 
    }

    return Object({
        id: name
            .split(/([A-Z][a-z]+)/)
            .filter(word => word)
            .map(word => word.toLowerCase())
            .join(" "), 
        type,
        options,
        ...props
    });
};

const parseContent = (content) => 
    Object.entries(
        content["application/json"].schema.properties
    ).flatMap(([k, v]) => {
        let value = v;
        while ("items" in value) {
            value = value.items;
        }
        if ("properties" in value) {
            return Object.entries(value.properties);
        } else {
            return [[k, value]];
        }
    }).map(
        ([k, v])=>Object({name: k, ...v})
    ).filter(({readOnly=null})=>!readOnly);


export default ({parameters, requestBody}) => {

    const [view, setView] = useState(null); // rendered data

    useEffect(()=>{
        setView({
            query: (parameters || []).map(schemaToInput),
            body: requestBody ? parseContent(requestBody.content) : null
        });
    },[]);

    return view;
}
```

Probably doesn't need to be in it's own file, but it's a bit less cluttery. We'll want to reuse that capability in other API interfaces, that have a bit more customization and domain specific language features. 


### `OpenApi` components

Our component is going to be functional, and use hooks. It will be composed from a `Header` subcomponent, and `Operation` subcomponents for each pair of path and HTTP method.

We'll use a `styled-component` as a place holder while the data-driven components load their data:

```JavaScript
// OpenApi.jsx

const Placeholder = styled.div`
    border-top: 1px dashed ${grey};
    border-bottom: 1px dashed ${grey};
    font-size: x-large;
    padding: 2rem;
`;

export default ({
    specUrl,
    service,
}) => {

    const {apiSpec, methods} = useOpenApiLoader({specUrl});
    
    return <div> 
        {
            !apiSpec ? 
            <Placeholder>{`Loading ${specUrl}...`}</Placeholder> :
            <Header info={apiSpec.info}/>
        }
        <div>
        {
            !methods ? 
            <Placeholder>{`Loading methods...`}</Placeholder> :
            methods.map(props => 
                <StyledOperation {...{
                    key: props.path+props.method, 
                    service: service,
                    ...props
                }}/>
            )
        }
        </div>
    </div> 
}
```

Not going to worry about the CSS too much here. The important part is that we are taking the `methods` from `useOpenApiLoader` and transforming these into `Operations`.

One thing to note is that we destructured nested request body fields. It would be possible to structure the interface to reflect object nesting with headers or labels. 

Instead, we'll have to use the API schema to re-structure the fields before they are submitted. 


#### API metdata

The `Header` component is metadata about the API itself:
```JavaScript
// OpenApi.jsx
const parseYamlText = (text, prefix="title") => 
    YAML.parse(text)
        .split("\n")
        .filter(paragraph => paragraph)
        .map((text, ii) => <p key={`${prefix}-text-${ii}`}>{text}</p>)

const Header = ({
    info: {
        title, 
        version,
        description
    }
}) => <div>
    <h1>{`${title}, v${version}`}</h1>
    {parseYamlText(description, "title")}
</div>
```

This doesn't really have to be a seperate component, but destructuring the `apiInfo` object is nice and terse.

Unfortunately, the OpenAPI parser we are using doesn't correctly format blocks of text from multi-line YAML strings. Instead of using the text directly, we have to parse the content again with the `yaml` library, and deal with extraneous newlines and whitespace.

The `parseYamlText` function will be reused on other long strings, usually a `description` object.

#### Operations

Like a socket, which is a pair of hostname and port, and operation is defined by a unique pair of url and HTTP method.

Really it only makes sense to do this for non-`GET` methods, but validating `GET` query parameters is a nice feature.

The `Operation` Component will use the `useOpenApiForm` hook as a transducer. There are also some toggle hooks. 

The `toggleHidden` reducer allows collapsing operations to just show a title and description.

The `toggleUpload` reducer switches between using form entry or file upload to describe the body of a HTTP request.

We'll end up with a multi-part form that shows inputs for request body and query parameters depending on what metadata are described in the spec:

```JavaScript
// OpenApi.jsx
const Operation = ({
    service,
    className,
    path,
    method,
    schema: {
        requestBody=null, 
        parameters=null,
        description,
        summary
    }
}) => {

    const view = useOpenApiForm({parameters, requestBody});
    const [hidden, toggleHidden] = useReducer(prev=>!prev, false); 
    const [upload, toggleUpload] = useReducer(prev=>!prev, false);

    const uploadInput = {
        id: "file upload",
        type: "file",
        accept: "application/json"
    }

    return <div className={className}>
        <h2 onClick={toggleHidden}>{summary}</h2>
        <h3>{"Description"}</h3>
        {parseYamlText(description, path+method)}
        <Collapse hidden={hidden}>
            {
                view && view.body ? 
                <>
                <InputWrapper 
                    type={"button"}
                    onClick={toggleUpload}
                    destructive={"true"}
                    value={`Use a ${upload ? "form" : "file"} instead`}>
                </InputWrapper>
                <h3>{upload ? "Upload JSON file" : "Request body"}</h3></> :
                null
            }

            <Form
                id={`${service}-api-body`}
                fields={view ? upload ? [uploadInput] : view.body : null}
                actions={[]}
            />
            
            {view && view.query.length ? <h3>{"Query"}</h3> : null}
            <Form
                id={`${service}-api-query`}
                fields={view ? view.query : null}
                actions={[]}
            />

            <Form
                id={`${service}-api-submit`}
                fields={null}
                actions={[{
                    value: method.toUpperCase(),
                    destructive: "true"
                }]}
            />
        </Collapse>
    </div>
};
```

A bit messy but it gets the trick done. 

The next thing to add is callbacks. It's harder to know exactly how the response data will be used when the form is submitted, so this will have to be delegated to higher-order components. 
